<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC UtiliTrack - Underground Utility Mapping</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Material Design Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/7.3.67/css/materialdesignicons.min.css" />
    
    <style>
        :root {
            /* Brand colors */
            --primary-color: #3F51B5;        /* Indigo */
            --primary-light: #7986CB;        /* Lighter indigo */
            --primary-dark: #303F9F;         /* Darker indigo */
            --secondary-color: #FF9800;      /* Orange */
            --secondary-light: #FFB74D;      /* Lighter orange */
            --secondary-dark: #F57C00;       /* Darker orange */
            --success-color: #4CAF50;        /* Green */
            --warning-color: #FFC107;        /* Amber */
            --danger-color: #F44336;         /* Red */
            --info-color: #2196F3;           /* Blue */
            
            /* UI colors */
            --bg-color: #FAFAFA;
            --card-bg: #FFFFFF;
            --text-primary: #212121;
            --text-secondary: #757575;
            --text-hint: #9E9E9E;
            --divider-color: #EEEEEE;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --overlay-bg: rgba(0, 0, 0, 0.5);
            
            /* Utility type colors */
            --water-color: #03A9F4;          /* Blue */
            --gas-color: #FFC107;            /* Amber */
            --electric-color: #FFEB3B;       /* Yellow */
            --sewer-color: #795548;          /* Brown */
            --telecom-color: #9C27B0;        /* Purple */
            --storm-color: #4CAF50;          /* Green */
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
            
            /* Animation */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Border radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-pill: 999px;
            
            /* Z-index layers */
            --z-base: 1;
            --z-elevated: 10;
            --z-dropdown: 100;
            --z-sticky: 200;
            --z-fixed: 300;
            --z-modal: 400;
            --z-popover: 500;
            --z-toast: 600;
        }

        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #121212;
                --card-bg: #1E1E1E;
                --text-primary: #E1E1E1;
                --text-secondary: #B0B0B0;
                --text-hint: #7B7B7B;
                --divider-color: #2C2C2C;
                --panel-bg: rgba(30, 30, 30, 0.95);
                --overlay-bg: rgba(0, 0, 0, 0.7);
            }
        }

        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-primary);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-hint);
            border-radius: var(--radius-pill);
        }

        /* Main container */
        .app-container {
            position: relative;
            height: 100dvh;
            width: 100vw;
            overflow: hidden;
        }

        /* Map container */
        #map {
            height: 100%;
            width: 100%;
            z-index: var(--z-base);
            transition: var(--transition-normal);
        }

        /* App Header */
        .app-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow-sm);
            display: flex;
            align-items: center;
            padding: 0 var(--spacing-md);
            z-index: var(--z-fixed);
        }

        .app-logo {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-weight: 600;
            font-size: 18px;
            color: var(--primary-color);
        }

        .app-logo i {
            font-size: 24px;
        }

        .app-actions {
            margin-left: auto;
            display: flex;
            gap: var(--spacing-sm);
        }

        /* Button styles */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            border: none;
            outline: none;
            transition: var(--transition-fast);
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--secondary-dark);
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-outline:hover {
            background-color: rgba(63, 81, 181, 0.1);
        }

        .btn-text {
            background-color: transparent;
            color: var(--primary-color);
            padding: var(--spacing-sm);
        }

        .btn-text:hover {
            background-color: rgba(63, 81, 181, 0.1);
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            border-radius: var(--radius-pill);
            background-color: var(--card-bg);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        .btn-icon:hover {
            background-color: var(--card-bg);
        }

        .btn-icon.active {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-icon i, .btn-icon .mdi {
            font-size: 20px;
        }

        .btn-fab {
            width: 56px;
            height: 56px;
            border-radius: var(--radius-pill);
            background-color: var(--primary-color);
            color: white;
            box-shadow: var(--shadow-md);
            position: absolute;
            bottom: 80px;
            right: 16px;
            z-index: var(--z-fixed);
        }

        .btn-fab i, .btn-fab .mdi {
            font-size: 24px;
        }

        .btn-fab:hover {
            background-color: var(--primary-dark);
            box-shadow: var(--shadow-lg);
        }

        /* Fab menu */
        .fab-menu {
            position: absolute;
            bottom: 148px;
            right: 16px;
            display: flex;
            flex-direction: column-reverse;
            gap: var(--spacing-sm);
            z-index: var(--z-fixed);
            pointer-events: none;
            opacity: 0;
            transform: translateY(20px);
            transition: var(--transition-normal);
        }

        .fab-menu.visible {
            pointer-events: auto;
            opacity: 1;
            transform: translateY(0);
        }

        .fab-menu-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .fab-menu-item .btn-icon {
            background-color: var(--secondary-color);
            color: white;
        }

        .fab-menu-label {
            background-color: var(--panel-bg);
            border-radius: var(--radius-md);
            padding: var(--spacing-xs) var(--spacing-md);
            font-size: 14px;
            box-shadow: var(--shadow-sm);
            white-space: nowrap;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            border-radius: var(--radius-pill);
            box-shadow: var(--shadow-md);
            padding: var(--spacing-xs);
            display: flex;
            gap: var(--spacing-xs);
            z-index: var(--z-fixed);
            max-width: calc(100% - 32px);
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .toolbar::-webkit-scrollbar {
            display: none;
        }

        .toolbar-button {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 64px;
            height: 64px;
            padding: var(--spacing-sm);
            border-radius: var(--radius-pill);
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 12px;
            transition: var(--transition-fast);
            user-select: none;
            flex-shrink: 0;
            gap: 4px;
        }

        .toolbar-button i, .toolbar-button .mdi {
            font-size: 24px;
        }

        .toolbar-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .toolbar-button.active {
            background-color: rgba(63, 81, 181, 0.15);
            color: var(--primary-color);
        }

        .toolbar-button .utility-icon {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-pill);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: var(--transition-fast);
        }

        /* Utility type specific buttons */
        .toolbar-button.water-btn .utility-icon {
            background-color: var(--water-color);
        }
        
        .toolbar-button.gas-btn .utility-icon {
            background-color: var(--gas-color);
        }
        
        .toolbar-button.electric-btn .utility-icon {
            background-color: var(--electric-color);
            color: var(--text-primary);
        }
        
        .toolbar-button.sewer-btn .utility-icon {
            background-color: var(--sewer-color);
        }
        
        .toolbar-button.telecom-btn .utility-icon {
            background-color: var(--telecom-color);
        }

        .toolbar-button.storm-btn .utility-icon {
            background-color: var(--storm-color);
        }

        .toolbar-button.active .utility-icon {
            transform: scale(1.1);
            box-shadow: var(--shadow-sm);
        }

        /* Utility line type selector */
        .line-type-selector {
            position: absolute;
            bottom: 96px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            border-radius: var(--radius-pill);
            box-shadow: var(--shadow-md);
            padding: var(--spacing-xs);
            display: flex;
            z-index: var(--z-fixed);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
        }

        .line-type-selector.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .line-type-btn {
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-pill);
            background-color: transparent;
            border: none;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 14px;
            transition: var(--transition-fast);
            user-select: none;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .line-type-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .line-type-btn.active {
            background-color: rgba(63, 81, 181, 0.15);
            color: var(--primary-color);
        }

        /* Control buttons */
        .map-controls {
            position: absolute;
            right: 16px;
            top: 72px;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: var(--z-fixed);
        }

        /* Side panel */
        .side-panel {
            position: absolute;
            top: 56px;
            right: 0;
            bottom: 0;
            width: 320px;
            max-width: 90%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow-lg);
            z-index: var(--z-modal);
            transform: translateX(100%);
            transition: var(--transition-normal);
            display: flex;
            flex-direction: column;
        }

        .side-panel.visible {
            transform: translateX(0);
        }

        .panel-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--divider-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-title {
            font-size: 18px;
            font-weight: 500;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: var(--spacing-md);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-size: 14px;
            color: var(--text-secondary);
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            border: 1px solid var(--divider-color);
            background-color: var(--card-bg);
            color: var(--text-primary);
            font-size: 16px;
            transition: var(--transition-fast);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(63, 81, 181, 0.2);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .input-group .form-control {
            flex: 1;
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--overlay-bg);
            z-index: var(--z-modal);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-md);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-container {
            background-color: var(--card-bg);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            transform: translateY(20px) scale(0.95);
            transition: var(--transition-normal);
        }

        .modal-overlay.visible .modal-container {
            transform: translateY(0) scale(1);
        }

        .modal-header {
            padding: var(--spacing-md);
            border-bottom: 1px solid var(--divider-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 500;
        }

        .modal-body {
            padding: var(--spacing-md);
            overflow-y: auto;
            max-height: 60vh;
        }

        .modal-footer {
            padding: var(--spacing-md);
            border-top: 1px solid var(--divider-color);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
        }

        /* Utility Markers and Lines */
        .utility-marker {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            border-radius: 50%;
            box-shadow: var(--shadow-sm);
            border: 2px solid white;
            font-size: 16px;
            position: relative;
            transition: transform 0.2s ease;
        }

        .utility-marker:hover {
            transform: scale(1.1);
            z-index: 10 !important;
        }

        .utility-marker .badge {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background-color: white;
            color: var(--text-primary);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            box-shadow: var(--shadow-sm);
        }

        /* Electrical box and manhole specific styles */
        .structure-marker {
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--shadow-sm);
            border: 2px solid white;
            background-color: var(--card-bg);
            color: var(--text-primary);
            transition: transform 0.2s ease;
        }

        .electrical-box {
            width: 36px;
            height: 36px;
            background-color: var(--electric-color);
            color: var(--text-primary);
        }

        .sewer-manhole {
            width: 40px;
            height: 40px;
            background-color: var(--sewer-color);
            color: white;
            border-radius: 50%;
        }

        .catch-basin {
            width: 40px;
            height: 40px;
            background-color: var(--storm-color);
            color: white;
            border-radius: 50%;
        }

        /* Animation for active drawing */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .utility-line-active {
            animation: pulse 2s infinite;
        }

        /* Drawing mode styles */
        .drawing-controls {
            position: absolute;
            bottom: 96px;
            left: 16px;
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: var(--z-fixed);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
        }

        .drawing-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* Measurement tag */
        .measurement-tag {
            background-color: var(--card-bg);
            color: var(--text-primary);
            border-radius: var(--radius-sm);
            padding: 2px 6px;
            font-size: 12px;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid var(--divider-color);
        }

        /* High accuracy editing mode */
        .editing-mode-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--panel-bg);
            padding: var(--spacing-md);
            border-top-left-radius: var(--radius-lg);
            border-top-right-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            z-index: var(--z-modal);
            transform: translateY(100%);
            transition: var(--transition-normal);
        }

        .editing-mode-container.visible {
            transform: translateY(0);
        }

        .editing-mode-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-md);
        }

        .editing-mode-title {
            font-size: 18px;
            font-weight: 500;
        }

        .editing-mode-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing-md);
        }

        .drag-handle {
            width: 40px;
            height: 5px;
            background-color: var(--divider-color);
            border-radius: var(--radius-pill);
            margin: -5px auto var(--spacing-md);
        }

        /* Notification toast */
        .toast {
            position: fixed;
            top: 72px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background-color: var(--card-bg);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            box-shadow: var(--shadow-md);
            font-size: 14px;
            z-index: var(--z-toast);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
            max-width: 80%;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        .toast.error {
            border-left: 4px solid var(--danger-color);
        }

        .toast.info {
            border-left: 4px solid var(--info-color);
        }

        /* Info card for utilities */
        .info-card {
            position: absolute;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: var(--spacing-md);
            z-index: var(--z-popover);
            max-width: 280px;
            transform: translateY(10px);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
        }

        .info-card.visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .info-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--divider-color);
        }

        .info-card-title {
            font-weight: 500;
            font-size: 16px;
        }

        .info-card-content {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
        }

        .info-card-row {
            display: flex;
            justify-content: space-between;
        }

        .info-card-label {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .info-card-value {
            font-weight: 500;
            text-align: right;
        }

        .info-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        /* Loading spinner */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: var(--z-modal);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-normal);
        }

        .loading-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Splash screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 72px;
            color: white;
            margin-bottom: var(--spacing-lg);
            animation: pulse-scale 2s infinite;
        }

        @keyframes pulse-scale {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .splash-title {
            font-size: 28px;
            font-weight: 700;
            color: white;
            margin-bottom: var(--spacing-sm);
        }

        .splash-subtitle {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .toolbar-button {
                min-width: 56px;
                height: 56px;
                font-size: 11px;
            }
            
            .toolbar-button i, .toolbar-button .mdi {
                font-size: 20px;
            }
            
            .btn-icon {
                width: 36px;
                height: 36px;
            }
            
            .btn-icon i, .btn-icon .mdi {
                font-size: 18px;
            }
            
            .btn-fab {
                width: 52px;
                height: 52px;
                bottom: 88px;
            }
        }

        /* Safe area support for iOS */
        @supports(padding: env(safe-area-inset-bottom)) {
            .toolbar {
                padding-bottom: calc(var(--spacing-xs) + env(safe-area-inset-bottom));
            }
            
            .side-panel {
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            .editing-mode-container {
                padding-bottom: calc(var(--spacing-md) + env(safe-area-inset-bottom));
            }
        }

        /* Context menu for utility items */
        .context-menu {
            position: absolute;
            background-color: var(--card-bg);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            z-index: var(--z-popover);
            min-width: 180px;
            transform: scale(0.95);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition-fast);
            overflow: hidden;
        }

        .context-menu.visible {
            transform: scale(1);
            opacity: 1;
            pointer-events: auto;
        }

        .context-menu-item {
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            transition: var(--transition-fast);
            color: var(--text-primary);
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item.danger {
            color: var(--danger-color);
        }

        .context-menu-item.danger:hover {
            background-color: rgba(244, 67, 54, 0.1);
        }

        .context-menu-item i, .context-menu-item .mdi {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        /* Chip/tag input for measurements */
        .measurement-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-sm);
        }

        .measurement-chip {
            display: flex;
            align-items: center;
            gap: 4px;
            background-color: rgba(63, 81, 181, 0.1);
            color: var(--primary-color);
            border-radius: var(--radius-pill);
            padding: 4px 10px;
            font-size: 12px;
        }

        .measurement-chip .remove-btn {
            cursor: pointer;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.1);
            font-size: 10px;
        }

        /* Selection styles for accuracy repositioning */
        .utility-line-selected {
            stroke-width: 6;
        }

        .utility-marker-selected {
            transform: scale(1.1);
            box-shadow: 0 0 0 4px rgba(63, 81, 181, 0.3);
            z-index: 1000 !important;
        }

        .edit-node {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--primary-color);
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
            cursor: move;
        }

        /* Map attribution styles */
        .leaflet-control-attribution {
            font-size: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen" id="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-layer-group"></i>
        </div>
        <div class="splash-title">CAC UtiliTrack</div>
        <div class="splash-subtitle">Premium Underground Utility Mapping</div>
    </div>

    <!-- Main Container -->
    <div class="app-container">
        <!-- Map Container -->
        <div id="map"></div>
        
        <!-- App Header -->
        <div class="app-header">
            <div class="app-logo">
                <i class="fas fa-layer-group"></i>
                <span>CAC UtiliTrack</span>
            </div>
            <div class="app-actions">
                <button class="btn-icon" id="menu-btn" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>
        
        <!-- Main Toolbar -->
        <div class="toolbar" id="main-toolbar">
            <button class="toolbar-button" id="locate-btn" title="My Location">
                <i class="fas fa-crosshairs"></i>
                <span>Locate</span>
            </button>
            <button class="toolbar-button" id="measure-btn" title="Measure">
                <i class="fas fa-ruler"></i>
                <span>Measure</span>
            </button>
            <button class="toolbar-button water-btn" id="water-btn" title="Water">
                <div class="utility-icon">
                    <i class="fas fa-tint"></i>
                </div>
                <span>Water</span>
            </button>
            <button class="toolbar-button gas-btn" id="gas-btn" title="Gas">
                <div class="utility-icon">
                    <i class="fas fa-fire"></i>
                </div>
                <span>Gas</span>
            </button>
            <button class="toolbar-button electric-btn" id="electric-btn" title="Electric">
                <div class="utility-icon">
                    <i class="fas fa-bolt"></i>
                </div>
                <span>Electric</span>
            </button>
            <button class="toolbar-button sewer-btn" id="sewer-btn" title="Sewer">
                <div class="utility-icon">
                    <i class="fas fa-toilet"></i>
                </div>
                <span>Sewer</span>
            </button>
            <button class="toolbar-button telecom-btn" id="telecom-btn" title="Telecom">
                <div class="utility-icon">
                    <i class="fas fa-phone"></i>
                </div>
                <span>Telecom</span>
            </button>
            <button class="toolbar-button storm-btn" id="storm-btn" title="Storm">
                <div class="utility-icon">
                    <i class="fas fa-cloud-rain"></i>
                </div>
                <span>Storm</span>
            </button>
            <button class="toolbar-button" id="structures-btn" title="Structures">
                <i class="fas fa-cube"></i>
                <span>Structures</span>
            </button>
        </div>
        
        <!-- Line Type Selector -->
        <div class="line-type-selector" id="line-type-selector">
            <button class="line-type-btn" data-type="main" title="Main">
                <i class="fas fa-project-diagram"></i>
                <span>Main</span>
            </button>
            <button class="line-type-btn active" data-type="service" title="Service">
                <i class="fas fa-home"></i>
                <span>Service</span>
            </button>
        </div>
        
        <!-- Map Controls -->
        <div class="map-controls">
            <button class="btn-icon" id="zoom-in-btn" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="btn-icon" id="zoom-out-btn" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="btn-icon" id="layers-btn" title="Layers">
                <i class="fas fa-layer-group"></i>
            </button>
        </div>
        
        <!-- Drawing Controls -->
        <div class="drawing-controls" id="drawing-controls">
            <button class="btn-icon" id="drawing-cancel-btn" title="Cancel">
                <i class="fas fa-times"></i>
            </button>
            <button class="btn-icon" id="drawing-finish-btn" title="Finish">
                <i class="fas fa-check"></i>
            </button>
        </div>
        
        <!-- Floating Action Button -->
        <button class="btn-fab" id="add-btn" title="Add Utility">
            <i class="fas fa-plus"></i>
        </button>
        
        <!-- FAB Menu -->
        <div class="fab-menu" id="fab-menu">
            <div class="fab-menu-item">
                <span class="fab-menu-label">Map Utility</span>
                <button class="btn-icon" id="map-utility-btn">
                    <i class="fas fa-route"></i>
                </button>
            </div>
            <div class="fab-menu-item">
                <span class="fab-menu-label">Add Found Utility</span>
                <button class="btn-icon" id="found-utility-btn">
                    <i class="fas fa-search"></i>
                </button>
            </div>
            <div class="fab-menu-item">
                <span class="fab-menu-label">Add Structure</span>
                <button class="btn-icon" id="add-structure-btn">
                    <i class="fas fa-cube"></i>
                </button>
            </div>
        </div>
        
        <!-- Side Panel - Layers -->
        <div class="side-panel" id="layers-panel">
            <div class="panel-header">
                <div class="panel-title">Map Layers</div>
                <button class="btn-icon" id="layers-close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-content">
                <div class="form-group">
                    <label>Utility Types</label>
                    <div class="toggle-list" id="utility-type-toggles">
                        <!-- Toggle list items will be dynamically added here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>Line Types</label>
                    <div class="toggle-list" id="line-type-toggles">
                        <!-- Toggle list items will be dynamically added here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>Structures</label>
                    <div class="toggle-list" id="structure-type-toggles">
                        <!-- Toggle list items will be dynamically added here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>Map Style</label>
                    <select class="form-control" id="map-style-select">
                        <option value="streets">Streets</option>
                        <option value="satellite">Satellite</option>
                        <option value="hybrid">Hybrid</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- Side Panel - Menu -->
        <div class="side-panel" id="menu-panel">
            <div class="panel-header">
                <div class="panel-title">Menu</div>
                <button class="btn-icon" id="menu-close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-content">
                <button class="btn btn-primary" style="width: 100%; margin-bottom: 16px;" id="search-location-btn">
                    <i class="fas fa-search"></i> Search Location
                </button>
                <button class="btn btn-outline" style="width: 100%; margin-bottom: 16px;" id="export-btn">
                    <i class="fas fa-file-export"></i> Export Data
                </button>
                <button class="btn btn-outline" style="width: 100%; margin-bottom: 16px;" id="import-btn">
                    <i class="fas fa-file-import"></i> Import Data
                </button>
                <div class="form-group">
                    <label>GPS Accuracy</label>
                    <select class="form-control" id="gps-accuracy-select">
                        <option value="high">High Accuracy (slower)</option>
                        <option value="balanced" selected>Balanced</option>
                        <option value="low">Low Power (faster)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Units</label>
                    <select class="form-control" id="units-select">
                        <option value="imperial" selected>Imperial (feet)</option>
                        <option value="metric">Metric (meters)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>App Info</label>
                    <div style="font-size: 14px; color: var(--text-secondary); margin-top: 8px;">
                        <p>CAC UtiliTrack v1.0.0</p>
                        <p style="margin-top: 8px;">A premium utility mapping tool by CAC</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modal - Add Found Utility -->
        <div class="modal-overlay" id="add-utility-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Add Found Utility</div>
                    <button class="btn-icon" id="add-utility-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="utility-type">Utility Type</label>
                        <select class="form-control" id="utility-type">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="sewer">Sewer</option>
                            <option value="telecom">Telecom</option>
                            <option value="storm">Storm</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Line Type</label>
                        <div class="input-group">
                            <div class="btn-group" id="line-type-btn-group">
                                <button class="btn btn-outline active" data-type="service">Service</button>
                                <button class="btn btn-outline" data-type="main">Main</button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="utility-size">Size</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="utility-size" value="4" min="0.5" step="0.5">
                            <select class="form-control" id="utility-size-unit" style="width: 80px;">
                                <option value="inches">inches</option>
                                <option value="cm">cm</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="utility-depth">Depth</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="utility-depth" value="3" min="0" step="0.5">
                            <select class="form-control" id="utility-depth-unit" style="width: 80px;">
                                <option value="feet">feet</option>
                                <option value="meters">meters</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="utility-material">Material (if known)</label>
                        <select class="form-control" id="utility-material">
                            <option value="">Unknown</option>
                            <option value="pvc">PVC</option>
                            <option value="cast-iron">Cast Iron</option>
                            <option value="ductile-iron">Ductile Iron</option>
                            <option value="steel">Steel</option>
                            <option value="copper">Copper</option>
                            <option value="hdpe">HDPE</option>
                            <option value="concrete">Concrete</option>
                            <option value="clay">Clay</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="utility-notes">Notes</label>
                        <textarea class="form-control" id="utility-notes" rows="3" placeholder="Add any additional information..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>Direction</label>
                        <div style="display: flex; justify-content: center; margin-top: 8px;">
                            <div style="width: 80px; height: 80px; border-radius: 50%; background-color: #f0f0f0; position: relative; display: flex; justify-content: center; align-items: center;">
                                <i class="fas fa-arrow-up" id="direction-arrow" style="font-size: 24px; color: var(--primary-color); transform: rotate(0deg); transition: transform 0.2s;"></i>
                            </div>
                        </div>
                        <div style="display: flex; justify-content: center; align-items: center; gap: 16px; margin-top: 16px;">
                            <button class="btn-icon" id="rotate-left-btn">
                                <i class="fas fa-undo"></i>
                            </button>
                            <span id="direction-angle">0°</span>
                            <button class="btn-icon" id="rotate-right-btn">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Measurements</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="measurement-input" placeholder="e.g., 6' from curb">
                            <button class="btn btn-outline" id="add-measurement-btn">Add</button>
                        </div>
                        <div class="measurement-tags-container" id="measurements-container">
                            <!-- Measurement tags will be added here -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="utility-photo">Photo (optional)</label>
                        <input type="file" class="form-control" id="utility-photo" accept="image/*">
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="add-utility-cancel-btn">Cancel</button>
                    <button class="btn btn-primary" id="add-utility-confirm-btn">Add Utility</button>
                </div>
            </div>
        </div>
        
        <!-- Modal - Add Structure -->
        <div class="modal-overlay" id="add-structure-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Add Structure</div>
                    <button class="btn-icon" id="add-structure-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="structure-type">Structure Type</label>
                        <select class="form-control" id="structure-type">
                            <option value="electrical-box">Electrical Box</option>
                            <option value="sewer-manhole">Sewer Manhole</option>
                            <option value="catch-basin">Catch Basin</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="structure-size">Size</label>
                        <div class="input-group">
                            <input type="number" class="form-control" id="structure-size" value="24" min="1" step="1">
                            <select class="form-control" id="structure-size-unit" style="width: 80px;">
                                <option value="inches">inches</option>
                                <option value="cm">cm</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="structure-notes">Notes</label>
                        <textarea class="form-control" id="structure-notes" rows="3" placeholder="Add any additional information..."></textarea>
                    </div>
                    <div class="form-group">
                        <label>Measurements</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="structure-measurement-input" placeholder="e.g., 5' from building">
                            <button class="btn btn-outline" id="add-structure-measurement-btn">Add</button>
                        </div>
                        <div class="measurement-tags-container" id="structure-measurements-container">
                            <!-- Measurement tags will be added here -->
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="structure-photo">Photo (optional)</label>
                        <input type="file" class="form-control" id="structure-photo" accept="image/*">
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="add-structure-cancel-btn">Cancel</button>
                    <button class="btn btn-primary" id="add-structure-confirm-btn">Add Structure</button>
                </div>
            </div>
        </div>
        
        <!-- Modal - Connect Utilities -->
        <div class="modal-overlay" id="connect-utilities-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Connect Utilities</div>
                    <button class="btn-icon" id="connect-utilities-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Connection Type</label>
                        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 8px;">
                            <button class="btn btn-outline connection-type-btn active" data-type="snap">
                                <i class="fas fa-magnet"></i> Snap Connection
                            </button>
                            <button class="btn btn-outline connection-type-btn" data-type="offset">
                                <i class="fas fa-grip-lines"></i> Offset Connection
                            </button>
                            <button class="btn btn-outline connection-type-btn" data-type="none">
                                <i class="fas fa-unlink"></i> No Connection
                            </button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="connect-utilities-cancel-btn">Cancel</button>
                    <button class="btn btn-primary" id="connect-utilities-confirm-btn">Connect</button>
                </div>
            </div>
        </div>
        
        <!-- Modal - Location Search -->
        <div class="modal-overlay" id="location-search-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Search Location</div>
                    <button class="btn-icon" id="location-search-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="search-input">Enter Address or Coordinates</label>
                        <div class="input-group">
                            <input type="text" class="form-control" id="search-input" placeholder="e.g., 123 Main St, New York, NY">
                            <button class="btn btn-outline" id="search-btn">
                                <i class="fas fa-search"></i>
                            </button>
                        </div>
                    </div>
                    <div id="search-results" style="max-height: 200px; overflow-y: auto; margin-top: 12px;">
                        <!-- Search results will be displayed here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="location-search-cancel-btn">Cancel</button>
                    <button class="btn btn-primary" id="use-current-location-btn">Use My Location</button>
                </div>
            </div>
        </div>
        
        <!-- High Accuracy Editing Mode -->
        <div class="editing-mode-container" id="editing-mode-container">
            <div class="drag-handle"></div>
            <div class="editing-mode-header">
                <div class="editing-mode-title">High Accuracy Editing</div>
                <button class="btn-icon" id="editing-mode-close-btn">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="editing-mode-controls">
                <button class="btn btn-outline" id="add-node-btn">
                    <i class="fas fa-plus"></i> Add Node
                </button>
                <button class="btn btn-outline" id="delete-node-btn">
                    <i class="fas fa-trash"></i> Delete Node
                </button>
                <button class="btn btn-outline" id="toggle-snap-btn">
                    <i class="fas fa-magnet"></i> Snap: ON
                </button>
            </div>
            <div style="margin-top: 8px;">
                <button class="btn btn-primary" style="width: 100%;" id="save-edits-btn">Save Changes</button>
            </div>
        </div>
        
        <!-- Utility Info Card -->
        <div class="info-card" id="utility-info-card">
            <div class="info-card-header">
                <div class="info-card-title">Utility Information</div>
                <button class="btn-icon" id="info-card-close-btn" style="width: 30px; height: 30px;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="info-card-content">
                <div class="info-card-row">
                    <div class="info-card-label">Type:</div>
                    <div class="info-card-value" id="info-utility-type">Water</div>
                </div>
                <div class="info-card-row">
                    <div class="info-card-label">Line Type:</div>
                    <div class="info-card-value" id="info-line-type">Service</div>
                </div>
                <div class="info-card-row">
                    <div class="info-card-label">Size:</div>
                    <div class="info-card-value" id="info-size">4 inches</div>
                </div>
                <div class="info-card-row">
                    <div class="info-card-label">Depth:</div>
                    <div class="info-card-value" id="info-depth">3 feet</div>
                </div>
                <div class="info-card-row">
                    <div class="info-card-label">Material:</div>
                    <div class="info-card-value" id="info-material">PVC</div>
                </div>
                <div class="info-card-row" id="info-measurements-row" style="display: none;">
                    <div class="info-card-label">Measurements:</div>
                    <div class="info-card-value" id="info-measurements"></div>
                </div>
                <div class="info-card-row" id="info-notes-row" style="display: none;">
                    <div class="info-card-label">Notes:</div>
                    <div class="info-card-value" id="info-notes"></div>
                </div>
            </div>
            <div class="info-card-actions">
                <button class="btn btn-outline" id="edit-utility-btn">
                    <i class="fas fa-pen"></i> Edit
                </button>
                <button class="btn btn-outline" id="high-accuracy-btn">
                    <i class="fas fa-crosshairs"></i> Reposition
                </button>
            </div>
        </div>
        
        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="edit-menu-item">
                <i class="fas fa-pen"></i>
                <span>Edit</span>
            </div>
            <div class="context-menu-item" id="reposition-menu-item">
                <i class="fas fa-crosshairs"></i>
                <span>High Accuracy Reposition</span>
            </div>
            <div class="context-menu-item" id="connect-menu-item">
                <i class="fas fa-link"></i>
                <span>Connect to Utility</span>
            </div>
            <div class="context-menu-item" id="measure-menu-item">
                <i class="fas fa-ruler"></i>
                <span>Measure From Here</span>
            </div>
            <div class="context-menu-item danger" id="delete-menu-item">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>
        
        <!-- Toast Notification -->
        <div class="toast" id="toast-notification"></div>
        
        <!-- Loading Spinner -->
        <div class="loading-overlay" id="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Show splash screen for a minimum time
            setTimeout(function() {
                const splashScreen = document.getElementById('splash-screen');
                splashScreen.style.opacity = '0';
                splashScreen.addEventListener('transitionend', function() {
                    splashScreen.style.display = 'none';
                    initApp();
                });
            }, 2000);
        });
        
        function initApp() {
            // Initialize variables
            let map;
            let userMarker;
            let currentPosition;
            let userHeading = 0;
            let selectedUtilityType = null;
            let selectedLineType = 'service';
            let isDrawingMode = false;
            let drawingPoints = [];
            let tempLine = null;
            let selectedElement = null;
            let directionAngle = 0;
            let isSnapping = true;
            let isHighAccuracyMode = false;
            let editingUtility = null;
            let editNodes = [];
            let isMeasuringMode = false;
            let measureStartPoint = null;
            let measureLine = null;
            let measureTooltip = null;
            let isFabMenuOpen = false;
            let lastContextMenuClick = null;
            
            // Measurement units
            let useMetric = false;
            
            // Undo stack
            const undoStack = [];
            const MAX_UNDO_STACK_SIZE = 100;
            
            // Map layers
            let utilitiesLayer = L.layerGroup();
            let structuresLayer = L.layerGroup();
            let measurementsLayer = L.layerGroup();
            let tempLayer = L.layerGroup();
            let editingLayer = L.layerGroup();
            
            // Data storage
            const utilities = {
                water: [],
                gas: [],
                electric: [],
                sewer: [],
                telecom: [],
                storm: []
            };
            
            const structures = [];
            const measurements = [];
            
            // Utility colors and icons
            const utilityConfig = {
                water: {
                    color: '#03A9F4',
                    icon: 'tint',
                    name: 'Water'
                },
                gas: {
                    color: '#FFC107',
                    icon: 'fire',
                    name: 'Gas'
                },
                electric: {
                    color: '#FFEB3B',
                    icon: 'bolt',
                    name: 'Electric'
                },
                sewer: {
                    color: '#795548',
                    icon: 'toilet',
                    name: 'Sewer'
                },
                telecom: {
                    color: '#9C27B0',
                    icon: 'phone',
                    name: 'Telecom'
                },
                storm: {
                    color: '#4CAF50',
                    icon: 'cloud-rain',
                    name: 'Storm'
                }
            };
            
            // Structure configurations
            const structureConfig = {
                'electrical-box': {
                    color: '#FFEB3B',
                    icon: 'bolt',
                    name: 'Electrical Box',
                    shape: 'square'
                },
                'sewer-manhole': {
                    color: '#795548',
                    icon: 'toilet',
                    name: 'Sewer Manhole',
                    shape: 'circle'
                },
                'catch-basin': {
                    color: '#4CAF50',
                    icon: 'cloud-rain',
                    name: 'Catch Basin',
                    shape: 'circle'
                }
            };
            
            // Initialize map
            function initializeMap() {
                // Create map
                map = L.map('map', {
                    center: [40.7128, -74.0060], // Default to NYC
                    zoom: 19,
                    zoomControl: false,
                    attributionControl: true
                });
                
                // Add tile layer (OpenStreetMap)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                
                // Add layers to map
                utilitiesLayer.addTo(map);
                structuresLayer.addTo(map);
                measurementsLayer.addTo(map);
                tempLayer.addTo(map);
                editingLayer.addTo(map);
                
                // Map event listeners
                map.on('click', handleMapClick);
                map.on('contextmenu', handleContextMenu);
                
                // Close context menu when map is moved
                map.on('movestart', function() {
                    hideContextMenu();
                    hideInfoCard();
                });
            }
            
            // Initialize UI event listeners
            function initializeUI() {
                // Toolbar buttons
                document.getElementById('locate-btn').addEventListener('click', getUserLocation);
                document.getElementById('measure-btn').addEventListener('click', toggleMeasureMode);
                
                // Utility type buttons
                document.getElementById('water-btn').addEventListener('click', function() {
                    selectUtilityType('water');
                });
                document.getElementById('gas-btn').addEventListener('click', function() {
                    selectUtilityType('gas');
                });
                document.getElementById('electric-btn').addEventListener('click', function() {
                    selectUtilityType('electric');
                });
                document.getElementById('sewer-btn').addEventListener('click', function() {
                    selectUtilityType('sewer');
                });
                document.getElementById('telecom-btn').addEventListener('click', function() {
                    selectUtilityType('telecom');
                });
                document.getElementById('storm-btn').addEventListener('click', function() {
                    selectUtilityType('storm');
                });
                
                // Structures button
                document.getElementById('structures-btn').addEventListener('click', function() {
                    // Toggle the FAB menu to show structure options
                    toggleFabMenu();
                });
                
                // Map controls
                document.getElementById('zoom-in-btn').addEventListener('click', function() {
                    map.zoomIn();
                });
                document.getElementById('zoom-out-btn').addEventListener('click', function() {
                    map.zoomOut();
                });
                document.getElementById('layers-btn').addEventListener('click', function() {
                    togglePanel('layers-panel');
                });
                
                // FAB button
                document.getElementById('add-btn').addEventListener('click', toggleFabMenu);
                
                // FAB menu items
                document.getElementById('map-utility-btn').addEventListener('click', function() {
                    if (!selectedUtilityType) {
                        showToast('Please select a utility type first', 'info');
                        return;
                    }
                    startDrawingMode();
                    closeFabMenu();
                });
                
                document.getElementById('found-utility-btn').addEventListener('click', function() {
                    showAddUtilityModal();
                    closeFabMenu();
                });
                
                document.getElementById('add-structure-btn').addEventListener('click', function() {
                    showAddStructureModal();
                    closeFabMenu();
                });
                
                // Drawing controls
                document.getElementById('drawing-cancel-btn').addEventListener('click', cancelDrawing);
                document.getElementById('drawing-finish-btn').addEventListener('click', completeDrawing);
                
                // Line type selector
                document.querySelectorAll('.line-type-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.line-type-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        selectedLineType = this.getAttribute('data-type');
                    });
                });
                
                // Panel close buttons
                document.getElementById('layers-close-btn').addEventListener('click', function() {
                    hidePanel('layers-panel');
                });
                
                document.getElementById('menu-close-btn').addEventListener('click', function() {
                    hidePanel('menu-panel');
                });
                
                // Menu button
                document.getElementById('menu-btn').addEventListener('click', function() {
                    togglePanel('menu-panel');
                });
                
                // Add utility modal
                document.getElementById('add-utility-close-btn').addEventListener('click', hideAddUtilityModal);
                document.getElementById('add-utility-cancel-btn').addEventListener('click', hideAddUtilityModal);
                document.getElementById('add-utility-confirm-btn').addEventListener('click', addFoundUtility);
                
                // Add structure modal
                document.getElementById('add-structure-close-btn').addEventListener('click', hideAddStructureModal);
                document.getElementById('add-structure-cancel-btn').addEventListener('click', hideAddStructureModal);
                document.getElementById('add-structure-confirm-btn').addEventListener('click', addStructure);
                
                // Connect utilities modal
                document.getElementById('connect-utilities-close-btn').addEventListener('click', hideConnectUtilitiesModal);
                document.getElementById('connect-utilities-cancel-btn').addEventListener('click', hideConnectUtilitiesModal);
                document.getElementById('connect-utilities-confirm-btn').addEventListener('click', confirmConnectUtilities);
                
                // Location search modal
                document.getElementById('location-search-close-btn').addEventListener('click', hideLocationSearchModal);
                document.getElementById('location-search-cancel-btn').addEventListener('click', hideLocationSearchModal);
                document.getElementById('use-current-location-btn').addEventListener('click', function() {
                    hideLocationSearchModal();
                    getUserLocation();
                });
                
                // Direction controls in add utility modal
                document.getElementById('rotate-left-btn').addEventListener('click', function() {
                    directionAngle = (directionAngle - 15) % 360;
                    if (directionAngle < 0) directionAngle += 360;
                    updateDirectionArrow();
                });
                
                document.getElementById('rotate-right-btn').addEventListener('click', function() {
                    directionAngle = (directionAngle + 15) % 360;
                    updateDirectionArrow();
                });
                
                // Measurement input in add utility modal
                document.getElementById('add-measurement-btn').addEventListener('click', addMeasurementTag);
                document.getElementById('measurement-input').addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        addMeasurementTag();
                    }
                });
                
                // Structure measurement input
                document.getElementById('add-structure-measurement-btn').addEventListener('click', addStructureMeasurementTag);
                document.getElementById('structure-measurement-input').addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        addStructureMeasurementTag();
                    }
                });
                
                // Line type buttons in add utility modal
                document.querySelectorAll('#line-type-btn-group .btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('#line-type-btn-group .btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                    });
                });
                
                // Connection type buttons
                document.querySelectorAll('.connection-type-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.connection-type-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                    });
                });
                
                // Info card
                document.getElementById('info-card-close-btn').addEventListener('click', hideInfoCard);
                document.getElementById('edit-utility-btn').addEventListener('click', function() {
                    if (selectedElement) {
                        editUtility(selectedElement);
                        hideInfoCard();
                    }
                });
                document.getElementById('high-accuracy-btn').addEventListener('click', function() {
                    if (selectedElement) {
                        startHighAccuracyMode(selectedElement);
                        hideInfoCard();
                    }
                });
                
                // Context menu
                document.getElementById('edit-menu-item').addEventListener('click', function() {
                    if (lastContextMenuClick && lastContextMenuClick.element) {
                        editUtility(lastContextMenuClick.element);
                        hideContextMenu();
                    }
                });
                
                document.getElementById('reposition-menu-item').addEventListener('click', function() {
                    if (lastContextMenuClick && lastContextMenuClick.element) {
                        startHighAccuracyMode(lastContextMenuClick.element);
                        hideContextMenu();
                    }
                });
                
                document.getElementById('connect-menu-item').addEventListener('click', function() {
                    if (lastContextMenuClick && lastContextMenuClick.element) {
                        startConnectUtility(lastContextMenuClick.element);
                        hideContextMenu();
                    }
                });
                
                document.getElementById('measure-menu-item').addEventListener('click', function() {
                    if (lastContextMenuClick && lastContextMenuClick.latlng) {
                        startMeasuringFrom(lastContextMenuClick.latlng);
                        hideContextMenu();
                    }
                });
                
                document.getElementById('delete-menu-item').addEventListener('click', function() {
                    if (lastContextMenuClick && lastContextMenuClick.element) {
                        deleteUtility(lastContextMenuClick.element);
                        hideContextMenu();
                    }
                });
                
                // High accuracy editing mode
                document.getElementById('editing-mode-close-btn').addEventListener('click', cancelHighAccuracyMode);
                document.getElementById('save-edits-btn').addEventListener('click', saveHighAccuracyEdits);
                document.getElementById('add-node-btn').addEventListener('click', addEditNode);
                document.getElementById('delete-node-btn').addEventListener('click', deleteEditNode);
                document.getElementById('toggle-snap-btn').addEventListener('click', toggleSnap);
                
                // Menu items
                document.getElementById('search-location-btn').addEventListener('click', showLocationSearchModal);
                document.getElementById('export-btn').addEventListener('click', exportData);
                document.getElementById('import-btn').addEventListener('click', importData);
                
                // Search in location modal
                document.getElementById('search-btn').addEventListener('click', searchLocation);
                document.getElementById('search-input').addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        searchLocation();
                    }
                });
                
                // Units selector
                document.getElementById('units-select').addEventListener('change', function() {
                    useMetric = this.value === 'metric';
                    updateMeasurementDisplay();
                });
                
                // Create layer toggles
                initLayerToggles();
                
                // Make drag handle for editing mode work
                const dragHandle = document.querySelector('.drag-handle');
                const editingModeContainer = document.getElementById('editing-mode-container');
                
                let isDragging = false;
                let startY = 0;
                let initialHeight = 0;
                
                dragHandle.addEventListener('touchstart', function(e) {
                    isDragging = true;
                    startY = e.touches[0].clientY;
                    initialHeight = editingModeContainer.offsetHeight;
                    e.preventDefault();
                });
                
                document.addEventListener('touchmove', function(e) {
                    if (!isDragging) return;
                    
                    const deltaY = startY - e.touches[0].clientY;
                    const newHeight = initialHeight + deltaY;
                    
                    // Limit the height between 150px and 80% of window height
                    const maxHeight = window.innerHeight * 0.8;
                    const constrainedHeight = Math.max(150, Math.min(newHeight, maxHeight));
                    
                    editingModeContainer.style.height = constrainedHeight + 'px';
                });
                
                document.addEventListener('touchend', function() {
                    isDragging = false;
                });
                
                // Global click listener to close things
                document.addEventListener('click', function(e) {
                    // Close FAB menu when clicking outside
                    if (isFabMenuOpen && !e.target.closest('#fab-menu') && !e.target.closest('#add-btn')) {
                        closeFabMenu();
                    }
                });
                
                // Handle escape key
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        // Cancel drawing
                        if (isDrawingMode) {
                            cancelDrawing();
                        }
                        
                        // Cancel measuring
                        if (isMeasuringMode) {
                            cancelMeasuring();
                        }
                        
                        // Cancel high accuracy mode
                        if (isHighAccuracyMode) {
                            cancelHighAccuracyMode();
                        }
                        
                        // Hide modals
                        hideAddUtilityModal();
                        hideAddStructureModal();
                        hideConnectUtilitiesModal();
                        hideLocationSearchModal();
                        
                        // Hide panels
                        hidePanel('layers-panel');
                        hidePanel('menu-panel');
                        
                        // Hide context menu and info card
                        hideContextMenu();
                        hideInfoCard();
                        
                        // Close FAB menu
                        closeFabMenu();
                    }
                });
            }
            
            // Initialize layer toggles
            function initLayerToggles() {
                const utilityToggleContainer = document.getElementById('utility-type-toggles');
                const lineToggleContainer = document.getElementById('line-type-toggles');
                const structureToggleContainer = document.getElementById('structure-type-toggles');
                
                // Clear containers
                utilityToggleContainer.innerHTML = '';
                lineToggleContainer.innerHTML = '';
                structureToggleContainer.innerHTML = '';
                
                // Add utility type toggles
                for (const type in utilityConfig) {
                    const config = utilityConfig[type];
                    
                    // Create toggle item
                    const toggleItem = document.createElement('div');
                    toggleItem.className = 'toggle-item';
                    toggleItem.style.display = 'flex';
                    toggleItem.style.justifyContent = 'space-between';
                    toggleItem.style.alignItems = 'center';
                    toggleItem.style.padding = '8px 0';
                    toggleItem.style.borderBottom = '1px solid var(--divider-color)';
                    
                    // Create label
                    const label = document.createElement('div');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    
                    // Create color indicator
                    const colorIndicator = document.createElement('div');
                    colorIndicator.style.width = '16px';
                    colorIndicator.style.height = '16px';
                    colorIndicator.style.backgroundColor = config.color;
                    colorIndicator.style.borderRadius = '4px';
                    
                    // Create name
                    const name = document.createElement('span');
                    name.textContent = config.name;
                    
                    // Assemble label
                    label.appendChild(colorIndicator);
                    label.appendChild(name);
                    
                    // Create toggle switch
                    const toggleSwitch = document.createElement('label');
                    toggleSwitch.className = 'toggle-switch';
                    toggleSwitch.style.position = 'relative';
                    toggleSwitch.style.display = 'inline-block';
                    toggleSwitch.style.width = '40px';
                    toggleSwitch.style.height = '20px';
                    
                    // Create checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.dataset.type = type;
                    checkbox.style.opacity = '0';
                    checkbox.style.width = '0';
                    checkbox.style.height = '0';
                    
                    // Add event listener to toggle utility visibility
                    checkbox.addEventListener('change', function() {
                        toggleUtilityVisibility(type, this.checked);
                    });
                    
                    // Create slider
                    const slider = document.createElement('span');
                    slider.className = 'toggle-slider';
                    slider.style.position = 'absolute';
                    slider.style.cursor = 'pointer';
                    slider.style.top = '0';
                    slider.style.left = '0';
                    slider.style.right = '0';
                    slider.style.bottom = '0';
                    slider.style.backgroundColor = '#ccc';
                    slider.style.transition = '.3s';
                    slider.style.borderRadius = '34px';
                    
                    // Create slider thumb
                    slider.innerHTML = `
                        <style>
                            .toggle-slider:before {
                                position: absolute;
                                content: "";
                                height: 16px;
                                width: 16px;
                                left: 2px;
                                bottom: 2px;
                                background-color: white;
                                transition: .3s;
                                border-radius: 50%;
                            }
                            input:checked + .toggle-slider {
                                background-color: var(--primary-color);
                            }
                            input:checked + .toggle-slider:before {
                                transform: translateX(20px);
                            }
                        </style>
                    `;
                    
                    // Assemble toggle switch
                    toggleSwitch.appendChild(checkbox);
                    toggleSwitch.appendChild(slider);
                    
                    // Assemble toggle item
                    toggleItem.appendChild(label);
                    toggleItem.appendChild(toggleSwitch);
                    
                    // Add to container
                    structureToggleContainer.appendChild(toggleItem);
                }
            }
            
            // Toggle utility visibility
            function toggleUtilityVisibility(type, visible) {
                utilities[type].forEach(utility => {
                    if (utility.line) {
                        if (visible) {
                            utilitiesLayer.addLayer(utility.line);
                            if (utility.marker) utilitiesLayer.addLayer(utility.marker);
                        } else {
                            utilitiesLayer.removeLayer(utility.line);
                            if (utility.marker) utilitiesLayer.removeLayer(utility.marker);
                        }
                    }
                });
            }
            
            // Toggle line type visibility
            function toggleLineTypeVisibility(lineType, visible) {
                for (const type in utilities) {
                    utilities[type].forEach(utility => {
                        if (utility.lineType === lineType && utility.line) {
                            if (visible) {
                                utilitiesLayer.addLayer(utility.line);
                                if (utility.marker) utilitiesLayer.addLayer(utility.marker);
                            } else {
                                utilitiesLayer.removeLayer(utility.line);
                                if (utility.marker) utilitiesLayer.removeLayer(utility.marker);
                            }
                        }
                    });
                }
            }
            
            // Toggle structure visibility
            function toggleStructureVisibility(type, visible) {
                structures.forEach(structure => {
                    if (structure.type === type && structure.marker) {
                        if (visible) {
                            structuresLayer.addLayer(structure.marker);
                        } else {
                            structuresLayer.removeLayer(structure.marker);
                        }
                    }
                });
            }
            
            // Select utility type
            function selectUtilityType(type) {
                // Reset all buttons
                document.querySelectorAll('.toolbar-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Set active button
                document.getElementById(`${type}-btn`).classList.add('active');
                
                // Set selected utility type
                selectedUtilityType = type;
                
                // Update utility type in add utility modal
                document.getElementById('utility-type').value = type;
                
                // Show line type selector
                document.getElementById('line-type-selector').classList.add('visible');
                
                // Show toast notification
                showToast(`Selected ${utilityConfig[type].name} utility`, 'info');
            }
            
            // Toggle FAB menu
            function toggleFabMenu() {
                const fabMenu = document.getElementById('fab-menu');
                if (fabMenu.classList.contains('visible')) {
                    closeFabMenu();
                } else {
                    openFabMenu();
                }
            }
            
            // Open FAB menu
            function openFabMenu() {
                document.getElementById('fab-menu').classList.add('visible');
                document.getElementById('add-btn').innerHTML = '<i class="fas fa-times"></i>';
                isFabMenuOpen = true;
            }
            
            // Close FAB menu
            function closeFabMenu() {
                document.getElementById('fab-menu').classList.remove('visible');
                document.getElementById('add-btn').innerHTML = '<i class="fas fa-plus"></i>';
                isFabMenuOpen = false;
            }
            
            // Toggle panel visibility
            function togglePanel(panelId) {
                const panel = document.getElementById(panelId);
                if (panel.classList.contains('visible')) {
                    hidePanel(panelId);
                } else {
                    showPanel(panelId);
                }
            }
            
            // Show panel
            function showPanel(panelId) {
                // Hide all panels first
                document.querySelectorAll('.side-panel').forEach(panel => {
                    panel.classList.remove('visible');
                });
                
                // Show the requested panel
                document.getElementById(panelId).classList.add('visible');
            }
            
            // Hide panel
            function hidePanel(panelId) {
                document.getElementById(panelId).classList.remove('visible');
            }
            
            // Show toast notification
            function showToast(message, type = 'info') {
                const toast = document.getElementById('toast-notification');
                toast.textContent = message;
                toast.className = 'toast'; // Reset class
                toast.classList.add(type);
                toast.classList.add('visible');
                
                // Hide after 3 seconds
                setTimeout(() => {
                    toast.classList.remove('visible');
                }, 3000);
            }
            
            // Show modal
            function showModal(modalId) {
                document.getElementById(modalId).classList.add('visible');
            }
            
            // Hide modal
            function hideModal(modalId) {
                document.getElementById(modalId).classList.remove('visible');
            }
            
            // Show add utility modal
            function showAddUtilityModal() {
                // Reset form
                document.getElementById('utility-type').value = selectedUtilityType || 'water';
                document.getElementById('utility-size').value = '4';
                document.getElementById('utility-depth').value = '3';
                document.getElementById('utility-material').value = '';
                document.getElementById('utility-notes').value = '';
                document.getElementById('utility-photo').value = '';
                document.getElementById('measurements-container').innerHTML = '';
                
                // Reset line type buttons
                document.querySelectorAll('#line-type-btn-group .btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`#line-type-btn-group [data-type="${selectedLineType}"]`).classList.add('active');
                
                // Reset direction
                directionAngle = 0;
                updateDirectionArrow();
                
                // Show modal
                showModal('add-utility-modal');
            }
            
            // Hide add utility modal
            function hideAddUtilityModal() {
                hideModal('add-utility-modal');
            }
            
            // Show add structure modal
            function showAddStructureModal() {
                // Reset form
                document.getElementById('structure-type').value = 'electrical-box';
                document.getElementById('structure-size').value = '24';
                document.getElementById('structure-notes').value = '';
                document.getElementById('structure-photo').value = '';
                document.getElementById('structure-measurements-container').innerHTML = '';
                
                // Show modal
                showModal('add-structure-modal');
            }
            
            // Hide add structure modal
            function hideAddStructureModal() {
                hideModal('add-structure-modal');
            }
            
            // Show connect utilities modal
            function showConnectUtilitiesModal() {
                // Reset connection type buttons
                document.querySelectorAll('.connection-type-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector('.connection-type-btn[data-type="snap"]').classList.add('active');
                
                // Show modal
                showModal('connect-utilities-modal');
            }
            
            // Hide connect utilities modal
            function hideConnectUtilitiesModal() {
                hideModal('connect-utilities-modal');
            }
            
            // Show location search modal
            function showLocationSearchModal() {
                // Clear search input and results
                document.getElementById('search-input').value = '';
                document.getElementById('search-results').innerHTML = '';
                
                // Show modal
                showModal('location-search-modal');
            }
            
            // Hide location search modal
            function hideLocationSearchModal() {
                hideModal('location-search-modal');
            }
            
            // Update direction arrow
            function updateDirectionArrow() {
                document.getElementById('direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                document.getElementById('direction-angle').textContent = `${directionAngle}°`;
            }
            
            // Add measurement tag to utility
            function addMeasurementTag() {
                const input = document.getElementById('measurement-input');
                const measurement = input.value.trim();
                
                if (measurement) {
                    const container = document.getElementById('measurements-container');
                    
                    // Create tag element
                    const tag = document.createElement('div');
                    tag.className = 'measurement-chip';
                    
                    const tagText = document.createElement('span');
                    tagText.textContent = measurement;
                    
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    
                    removeBtn.addEventListener('click', function() {
                        tag.remove();
                    });
                    
                    tag.appendChild(tagText);
                    tag.appendChild(removeBtn);
                    container.appendChild(tag);
                    
                    // Clear input
                    input.value = '';
                }
            }
            
            // Add measurement tag to structure
            function addStructureMeasurementTag() {
                const input = document.getElementById('structure-measurement-input');
                const measurement = input.value.trim();
                
                if (measurement) {
                    const container = document.getElementById('structure-measurements-container');
                    
                    // Create tag element
                    const tag = document.createElement('div');
                    tag.className = 'measurement-chip';
                    
                    const tagText = document.createElement('span');
                    tagText.textContent = measurement;
                    
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                    
                    removeBtn.addEventListener('click', function() {
                        tag.remove();
                    });
                    
                    tag.appendChild(tagText);
                    tag.appendChild(removeBtn);
                    container.appendChild(tag);
                    
                    // Clear input
                    input.value = '';
                }
            }
            
            // Show info card for utility
            function showInfoCard(element, latlng) {
                if (!element) return;
                
                const infoCard = document.getElementById('utility-info-card');
                
                // Find utility data
                let utilityData;
                let isStructure = false;
                
                if (element.utility) {
                    utilityData = element.utility;
                } else if (element.lineType || element.marker) {
                    // This is a utility line or marker
                    for (const type in utilities) {
                        const found = utilities[type].find(u => u.line === element || u.marker === element);
                        if (found) {
                            utilityData = found;
                            break;
                        }
                    }
                } else {
                    // Check if this is a structure
                    const structure = structures.find(s => s.marker === element);
                    if (structure) {
                        utilityData = structure;
                        isStructure = true;
                    }
                }
                
                if (!utilityData) return;
                
                // Update info card content
                if (isStructure) {
                    document.querySelector('.info-card-title').textContent = 'Structure Information';
                    document.getElementById('info-utility-type').textContent = structureConfig[utilityData.type].name;
                    document.getElementById('info-line-type').parentNode.style.display = 'none';
                    document.getElementById('info-size').textContent = `${utilityData.size} ${utilityData.sizeUnit}`;
                    document.getElementById('info-depth').parentNode.style.display = 'none';
                    document.getElementById('info-material').parentNode.style.display = 'none';
                } else {
                    document.querySelector('.info-card-title').textContent = 'Utility Information';
                    document.getElementById('info-utility-type').textContent = utilityConfig[utilityData.type].name;
                    document.getElementById('info-line-type').parentNode.style.display = 'flex';
                    document.getElementById('info-line-type').textContent = utilityData.lineType === 'main' ? 'Main' : 'Service';
                    document.getElementById('info-size').textContent = `${utilityData.size} ${utilityData.sizeUnit}`;
                    document.getElementById('info-depth').textContent = `${utilityData.depth} ${utilityData.depthUnit}`;
                    document.getElementById('info-material').textContent = utilityData.material || 'Unknown';
                }
                
                // Show/hide measurements
                if (utilityData.measurements && utilityData.measurements.length > 0) {
                    document.getElementById('info-measurements-row').style.display = 'flex';
                    document.getElementById('info-measurements').textContent = utilityData.measurements.join(', ');
                } else {
                    document.getElementById('info-measurements-row').style.display = 'none';
                }
                
                // Show/hide notes
                if (utilityData.notes) {
                    document.getElementById('info-notes-row').style.display = 'flex';
                    document.getElementById('info-notes').textContent = utilityData.notes;
                } else {
                    document.getElementById('info-notes-row').style.display = 'none';
                }
                
                // Position the info card
                if (!latlng && element.getLatLng) {
                    latlng = element.getLatLng();
                } else if (!latlng && utilityData.marker) {
                    latlng = utilityData.marker.getLatLng();
                }
                
                if (latlng) {
                    const point = map.latLngToContainerPoint(latlng);
                    infoCard.style.left = `${point.x + 20}px`;
                    infoCard.style.top = `${point.y - 20}px`;
                }
                
                // Show the card
                infoCard.classList.add('visible');
                
                // Store reference to the selected element
                selectedElement = {
                    element: element,
                    utility: utilityData,
                    isStructure: isStructure
                };
            }
            
            // Hide info card
            function hideInfoCard() {
                document.getElementById('utility-info-card').classList.remove('visible');
            }
            
            // Show context menu
            function showContextMenu(e, element) {
                const contextMenu = document.getElementById('context-menu');
                
                // Position context menu
                contextMenu.style.left = `${e.containerPoint.x}px`;
                contextMenu.style.top = `${e.containerPoint.y}px`;
                
                // Store last context menu click data
                lastContextMenuClick = {
                    element: element,
                    latlng: e.latlng
                };
                
                // Show menu items based on element type
                if (element) {
                    // Check if this is a utility or structure
                    let isUtility = false;
                    let isStructure = false;
                    
                    for (const type in utilities) {
                        const utility = utilities[type].find(u => u.line === element || u.marker === element);
                        if (utility) {
                            isUtility = true;
                            break;
                        }
                    }
                    
                    if (!isUtility) {
                        const structure = structures.find(s => s.marker === element);
                        if (structure) {
                            isStructure = true;
                        }
                    }
                    
                    // Show/hide menu items
                    document.getElementById('edit-menu-item').style.display = 'flex';
                    document.getElementById('reposition-menu-item').style.display = 'flex';
                    document.getElementById('connect-menu-item').style.display = isUtility ? 'flex' : 'none';
                    document.getElementById('measure-menu-item').style.display = 'flex';
                    document.getElementById('delete-menu-item').style.display = 'flex';
                } else {
                    // No element, just map click
                    document.getElementById('edit-menu-item').style.display = 'none';
                    document.getElementById('reposition-menu-item').style.display = 'none';
                    document.getElementById('connect-menu-item').style.display = 'none';
                    document.getElementById('measure-menu-item').style.display = 'flex';
                    document.getElementById('delete-menu-item').style.display = 'none';
                }
                
                // Show the menu
                contextMenu.classList.add('visible');
                
                // Prevent browser context menu
                e.originalEvent.preventDefault();
            }
            
            // Hide context menu
            function hideContextMenu() {
                document.getElementById('context-menu').classList.remove('visible');
            }
            
            // Get user location
            function getUserLocation() {
                showToast('Locating...', 'info');
                
                // Check if geolocation is available
                if (navigator.geolocation) {
                    const accuracy = document.getElementById('gps-accuracy-select').value;
                    const options = {
                        enableHighAccuracy: accuracy === 'high',
                        timeout: 10000,
                        maximumAge: 0
                    };
                    
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            // Store position
                            currentPosition = [position.coords.latitude, position.coords.longitude];
                            
                            // Update user marker or create if not exists
                            if (userMarker) {
                                userMarker.setLatLng(currentPosition);
                            } else {
                                // Create user marker with directional icon
                                const userMarkerIcon = L.divIcon({
                                    html: '<div style="width: 24px; height: 24px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white; box-shadow: var(--shadow-sm); display: flex; align-items: center; justify-content: center; color: white;">' +
                                        '<i class="fas fa-location-arrow" style="transform: rotate(' + userHeading + 'deg);"></i>' +
                                        '</div>',
                                    className: '',
                                    iconSize: [24, 24],
                                    iconAnchor: [12, 12]
                                });
                                
                                userMarker = L.marker(currentPosition, {
                                    icon: userMarkerIcon,
                                    zIndexOffset: 1000
                                }).addTo(map);
                                
                                // Add accuracy circle
                                userMarker.accuracyCircle = L.circle(currentPosition, {
                                    radius: position.coords.accuracy,
                                    color: 'var(--primary-color)',
                                    fillColor: 'rgba(63, 81, 181, 0.15)',
                                    fillOpacity: 0.5,
                                    weight: 1
                                }).addTo(map);
                            }
                            
                            // Update accuracy circle
                            if (userMarker.accuracyCircle) {
                                userMarker.accuracyCircle.setLatLng(currentPosition);
                                userMarker.accuracyCircle.setRadius(position.coords.accuracy);
                            }
                            
                            // Center map on user location
                            map.setView(currentPosition, 19);
                            
                            // Watch for heading changes if available
                            if (window.DeviceOrientationEvent) {
                                window.addEventListener('deviceorientation', function(e) {
                                    if (e.webkitCompassHeading) {
                                        // iOS devices
                                        userHeading = e.webkitCompassHeading;
                                    } else if (e.alpha) {
                                        // Android devices
                                        userHeading = 360 - e.alpha;
                                    }
                                    
                                    // Update user marker icon
                                    if (userMarker) {
                                        const userMarkerIcon = L.divIcon({
                                            html: '<div style="width: 24px; height: 24px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white; box-shadow: var(--shadow-sm); display: flex; align-items: center; justify-content: center; color: white;">' +
                                                '<i class="fas fa-location-arrow" style="transform: rotate(' + userHeading + 'deg);"></i>' +
                                                '</div>',
                                            className: '',
                                            iconSize: [24, 24],
                                            iconAnchor: [12, 12]
                                        });
                                        
                                        userMarker.setIcon(userMarkerIcon);
                                    }
                                }, false);
                            }
                            
                            // Watch position for updates
                            if (window.watchPositionId) {
                                navigator.geolocation.clearWatch(window.watchPositionId);
                            }
                            
                            window.watchPositionId = navigator.geolocation.watchPosition(
                                function(position) {
                                    // Update current position
                                    currentPosition = [position.coords.latitude, position.coords.longitude];
                                    
                                    // Update user marker
                                    if (userMarker) {
                                        userMarker.setLatLng(currentPosition);
                                        
                                        // Update accuracy circle
                                        if (userMarker.accuracyCircle) {
                                            userMarker.accuracyCircle.setLatLng(currentPosition);
                                            userMarker.accuracyCircle.setRadius(position.coords.accuracy);
                                        }
                                    }
                                },
                                function(error) {
                                    console.error('Error watching position:', error);
                                },
                                options
                            );
                            
                            showToast('Location found!', 'success');
                        },
                        function(error) {
                            console.error('Error getting location:', error);
                            
                            let errorMsg = 'Could not get your location.';
                            if (error.code === 1) {
                                errorMsg = 'Location access denied. Please enable GPS permissions.';
                            } else if (error.code === 2) {
                                errorMsg = 'Location unavailable. Try again later.';
                            } else if (error.code === 3) {
                                errorMsg = 'Location request timed out. Try again.';
                            }
                            
                            showToast(errorMsg, 'error');
                        },
                        options
                    );
                } else {
                    showToast('Geolocation is not supported by this browser.', 'error');
                }
            }
            
            // Start drawing mode
            function startDrawingMode() {
                if (!selectedUtilityType) {
                    showToast('Please select a utility type first', 'info');
                    return;
                }
                
                // Set drawing mode
                isDrawingMode = true;
                drawingPoints = [];
                
                // Show drawing controls
                document.getElementById('drawing-controls').classList.add('visible');
                
                // Hide line type selector
                document.getElementById('line-type-selector').classList.remove('visible');
                
                // Update status
                showToast(`Click on the map to start mapping a ${utilityConfig[selectedUtilityType].name} ${selectedLineType}`, 'info');
            }
            
            // Cancel drawing
            function cancelDrawing() {
                // Reset drawing mode
                isDrawingMode = false;
                drawingPoints = [];
                
                // Remove temporary line
                if (tempLine) {
                    tempLayer.removeLayer(tempLine);
                    tempLine = null;
                }
                
                // Hide drawing controls
                document.getElementById('drawing-controls').classList.remove('visible');
                
                // Show line type selector if utility type is selected
                if (selectedUtilityType) {
                    document.getElementById('line-type-selector').classList.add('visible');
                }
                
                // Update status
                showToast('Drawing cancelled', 'info');
            }
            
            // Complete drawing
            function completeDrawing() {
                if (drawingPoints.length < 2) {
                    showToast('Please add at least 2 points to create a utility line', 'warning');
                    return;
                }
                
                // Remove temporary line
                if (tempLine) {
                    tempLayer.removeLayer(tempLine);
                    tempLine = null;
                }
                
                // Create the utility
                const utilityId = 'utility-' + Date.now();
                const utilityType = selectedUtilityType;
                const lineType = selectedLineType;
                
                // Create smoother line with Bezier curve
                const smoothedPoints = applySmoothingToLine(drawingPoints);
                
                // Create utility data
                const utilityData = {
                    id: utilityId,
                    type: utilityType,
                    lineType: lineType,
                    points: smoothedPoints,
                    size: 4, // Default size
                    sizeUnit: 'inches',
                    depth: 3, // Default depth
                    depthUnit: 'feet',
                    material: '', // Unknown material
                    measurements: [],
                    notes: '',
                    createdAt: new Date()
                };
                
                // Create utility visual elements
                createUtilityVisuals(utilityData);
                
                // Add to utilities collection
                utilities[utilityType].push(utilityData);
                
                // Reset drawing mode
                isDrawingMode = false;
                drawingPoints = [];
                
                // Hide drawing controls
                document.getElementById('drawing-controls').classList.remove('visible');
                
                // Show line type selector
                if (selectedUtilityType) {
                    document.getElementById('line-type-selector').classList.add('visible');
                }
                
                // Check for nearby utilities to connect
                const nearbyUtilities = findNearbyUtilities(smoothedPoints[0], utilityType);
                if (nearbyUtilities.length > 0) {
                    // Store for connect dialog
                    selectedElement = {
                        utility: utilityData,
                        nearbyUtilities: nearbyUtilities
                    };
                    
                    // Show connect dialog
                    showConnectUtilitiesModal();
                } else {
                    // No nearby utilities, just show success message
                    showToast(`${utilityConfig[utilityType].name} ${lineType} added successfully`, 'success');
                }
            }
            
            // Add a found utility
            function addFoundUtility() {
                if (!map) return;
                
                // Get form values
                const utilityType = document.getElementById('utility-type').value;
                const lineType = document.querySelector('#line-type-btn-group .btn.active').getAttribute('data-type');
                const size = parseFloat(document.getElementById('utility-size').value) || 4;
                const sizeUnit = document.getElementById('utility-size-unit').value;
                const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                const depthUnit = document.getElementById('utility-depth-unit').value;
                const material = document.getElementById('utility-material').value;
                const notes = document.getElementById('utility-notes').value;
                
                // Get measurements
                const measurementTags = document.querySelectorAll('#measurements-container .measurement-chip');
                const measurements = Array.from(measurementTags).map(tag => tag.querySelector('span').textContent);
                
                // Get center of map as location
                const center = map.getCenter();
                
                // Create end point based on direction angle
                const startPoint = center;
                const endPoint = calculateEndPoint(startPoint, directionAngle, 10); // 10 meters length
                
                // Create utility data
                const utilityId = 'utility-' + Date.now();
                const utilityData = {
                    id: utilityId,
                    type: utilityType,
                    lineType: lineType,
                    points: [startPoint, endPoint],
                    size: size,
                    sizeUnit: sizeUnit,
                    depth: depth,
                    depthUnit: depthUnit,
                    material: material,
                    measurements: measurements,
                    notes: notes,
                    angle: directionAngle,
                    createdAt: new Date()
                };
                
                // Process photo if uploaded
                const photoInput = document.getElementById('utility-photo');
                if (photoInput.files && photoInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        utilityData.photo = e.target.result;
                        
                        // Create utility visuals
                        createUtilityVisuals(utilityData);
                        
                        // Add to utilities collection
                        utilities[utilityType].push(utilityData);
                        
                        // Hide modal
                        hideAddUtilityModal();
                        
                        // Show success message
                        showToast(`${utilityConfig[utilityType].name} ${lineType} added successfully`, 'success');
                    };
                    reader.readAsDataURL(photoInput.files[0]);
                } else {
                    // Create utility visuals
                    createUtilityVisuals(utilityData);
                    
                    // Add to utilities collection
                    utilities[utilityType].push(utilityData);
                    
                    // Hide modal
                    hideAddUtilityModal();
                    
                    // Show success message
                    showToast(`${utilityConfig[utilityType].name} ${lineType} added successfully`, 'success');
                }
                
                // Check for nearby utilities to connect
                const nearbyUtilities = findNearbyUtilities(startPoint, utilityType);
                if (nearbyUtilities.length > 0) {
                    // Store for connect dialog
                    selectedElement = {
                        utility: utilityData,
                        nearbyUtilities: nearbyUtilities
                    };
                    
                    // Show connect dialog after short delay to let the modal close
                    setTimeout(() => {
                        showConnectUtilitiesModal();
                    }, 300);
                }
            }
            
            // Add a structure
            function addStructure() {
                if (!map) return;
                
                // Get form values
                const structureType = document.getElementById('structure-type').value;
                const size = parseFloat(document.getElementById('structure-size').value) || 24;
                const sizeUnit = document.getElementById('structure-size-unit').value;
                const notes = document.getElementById('structure-notes').value;
                
                // Get measurements
                const measurementTags = document.querySelectorAll('#structure-measurements-container .measurement-chip');
                const measurements = Array.from(measurementTags).map(tag => tag.querySelector('span').textContent);
                
                // Get center of map as location
                const center = map.getCenter();
                
                // Create structure data
                const structureId = 'structure-' + Date.now();
                const structureData = {
                    id: structureId,
                    type: structureType,
                    position: center,
                    size: size,
                    sizeUnit: sizeUnit,
                    measurements: measurements,
                    notes: notes,
                    createdAt: new Date()
                };
                
                // Process photo if uploaded
                const photoInput = document.getElementById('structure-photo');
                if (photoInput.files && photoInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        structureData.photo = e.target.result;
                        
                        // Create structure marker
                        createStructureMarker(structureData);
                        
                        // Add to structures collection
                        structures.push(structureData);
                        
                        // Hide modal
                        hideAddStructureModal();
                        
                        // Show success message
                        showToast(`${structureConfig[structureType].name} added successfully`, 'success');
                    };
                    reader.readAsDataURL(photoInput.files[0]);
                } else {
                    // Create structure marker
                    createStructureMarker(structureData);
                    
                    // Add to structures collection
                    structures.push(structureData);
                    
                    // Hide modal
                    hideAddStructureModal();
                    
                    // Show success message
                    showToast(`${structureConfig[structureType].name} added successfully`, 'success');
                }
            }
            
            // Create utility visuals
            function createUtilityVisuals(utilityData) {
                // Get utility color
                const color = utilityConfig[utilityData.type].color;
                
                // Create polyline
                const polyline = L.polyline(utilityData.points, {
                    color: color,
                    weight: utilityData.lineType === 'main' ? 6 : 4,
                    opacity: 1,
                    className: `utility-line ${utilityData.lineType}`
                }).addTo(utilitiesLayer);
                
                // Create marker at start point
                const markerIcon = createUtilityMarkerIcon(utilityData);
                const marker = L.marker(utilityData.points[0], {
                    icon: markerIcon,
                    draggable: false
                }).addTo(utilitiesLayer);
                
                // Store references
                utilityData.line = polyline;
                utilityData.marker = marker;
                
                // Add event listeners
                polyline.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showInfoCard(polyline);
                });
                
                marker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showInfoCard(marker);
                });
                
                // Add context menu
                polyline.on('contextmenu', function(e) {
                    showContextMenu(e, polyline);
                });
                
                marker.on('contextmenu', function(e) {
                    showContextMenu(e, marker);
                });
                
                return { polyline, marker };
            }
            
            // Create utility marker icon
            function createUtilityMarkerIcon(utilityData) {
                const config = utilityConfig[utilityData.type];
                
                // Create HTML for the icon
                const html = `
                    <div class="utility-marker" style="background-color: ${config.color};">
                        <i class="fas fa-${config.icon}"></i>
                        ${utilityData.lineType === 'main' ? '<div class="badge">M</div>' : ''}
                    </div>
                `;
                
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
            }
            
            // Create structure marker
            function createStructureMarker(structureData) {
                const config = structureConfig[structureData.type];
                
                // Create HTML for the icon
                let html = '';
                if (structureData.type === 'electrical-box') {
                    html = `
                        <div class="structure-marker electrical-box">
                            <i class="fas fa-${config.icon}"></i>
                        </div>
                    `;
                } else if (structureData.type === 'sewer-manhole') {
                    html = `
                        <div class="structure-marker sewer-manhole">
                            <i class="fas fa-${config.icon}"></i>
                        </div>
                    `;
                } else if (structureData.type === 'catch-basin') {
                    html = `
                        <div class="structure-marker catch-basin">
                            <i class="fas fa-${config.icon}"></i>
                        </div>
                    `;
                }
                
                const icon = L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                // Create marker
                const marker = L.marker(structureData.position, {
                    icon: icon,
                    draggable: false
                }).addTo(structuresLayer);
                
                // Store reference
                structureData.marker = marker;
                
                // Add event listeners
                marker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showInfoCard(marker);
                });
                
                marker.on('contextmenu', function(e) {
                    showContextMenu(e, marker);
                });
                
                return marker;
            }
            
            // Find nearby utilities
            function findNearbyUtilities(point, utilityType) {
                const result = [];
                const maxDistance = 20; // meters
                
                // Check all utilities of the same type
                utilities[utilityType].forEach(utility => {
                    // Skip if same utility
                    if (utility.points[0].equals(point)) return;
                    
                    // Check distance to start and end points
                    const startPoint = utility.points[0];
                    const endPoint = utility.points[utility.points.length - 1];
                    
                    const startDistance = map.distance(point, startPoint);
                    const endDistance = map.distance(point, endPoint);
                    
                    if (startDistance <= maxDistance) {
                        result.push({
                            utility: utility,
                            point: startPoint,
                            distance: startDistance,
                            isStart: true
                        });
                    }
                    
                    if (endDistance <= maxDistance) {
                        result.push({
                            utility: utility,
                            point: endPoint,
                            distance: endDistance,
                            isStart: false
                        });
                    }
                });
                
                // Sort by distance
                result.sort((a, b) => a.distance - b.distance);
                
                return result;
            }
            
            // Start connect utility
            function startConnectUtility(element) {
                // Find utility data
                let utilityData;
                for (const type in utilities) {
                    const found = utilities[type].find(u => u.line === element || u.marker === element);
                    if (found) {
                        utilityData = found;
                        break;
                    }
                }
                
                if (!utilityData) return;
                
                // Find nearby utilities
                const startPoint = utilityData.points[0];
                const endPoint = utilityData.points[utilityData.points.length - 1];
                
                const nearbyUtilities = findNearbyUtilities(startPoint, utilityData.type)
                    .concat(findNearbyUtilities(endPoint, utilityData.type));
                
                // Remove duplicates
                const uniqueNearby = nearbyUtilities.filter((utility, index, self) => 
                    index === self.findIndex(u => u.utility.id === utility.utility.id)
                );
                
                if (uniqueNearby.length > 0) {
                    // Store for connect dialog
                    selectedElement = {
                        utility: utilityData,
                        nearbyUtilities: uniqueNearby
                    };
                    
                    // Show connect dialog
                    showConnectUtilitiesModal();
                } else {
                    showToast('No nearby utilities to connect to', 'info');
                }
            }
            
            // Confirm connect utilities
            function confirmConnectUtilities() {
                if (!selectedElement || !selectedElement.utility || !selectedElement.nearbyUtilities) {
                    hideConnectUtilitiesModal();
                    return;
                }
                
                const utility = selectedElement.utility;
                const nearestUtility = selectedElement.nearbyUtilities[0];
                const connectionType = document.querySelector('.connection-type-btn.active').getAttribute('data-type');
                
                if (connectionType === 'none') {
                    // No connection, just close dialog
                    hideConnectUtilitiesModal();
                    return;
                }
                
                // Connect the utilities
                connectUtilities(utility, nearestUtility, connectionType);
                
                // Hide dialog
                hideConnectUtilitiesModal();
                
                // Show success message
                showToast('Utilities connected successfully', 'success');
            }
            
            // Connect utilities
            function connectUtilities(utility, nearUtility, connectionType) {
                // Determine connection points
                const utilityStartPoint = utility.points[0];
                const utilityEndPoint = utility.points[utility.points.length - 1];
                
                const nearUtilityPoint = nearUtility.point;
                
                // Determine which point to connect from
                let connectFromStartOfUtility = true;
                if (map.distance(utilityEndPoint, nearUtilityPoint) < map.distance(utilityStartPoint, nearUtilityPoint)) {
                    connectFromStartOfUtility = false;
                }
                
                let newPoints = [...utility.points];
                
                // Create connection based on type
                if (connectionType === 'snap') {
                    // Snap connection - directly connect points
                    if (connectFromStartOfUtility) {
                        // Update start point
                        newPoints[0] = nearUtilityPoint;
                    } else {
                        // Update end point
                        newPoints[newPoints.length - 1] = nearUtilityPoint;
                    }
                } else if (connectionType === 'offset') {
                    // Offset connection - create a curve or bend
                    if (connectFromStartOfUtility) {
                        // Create a smooth curve from start to near point
                        newPoints = createSmoothConnection(nearUtilityPoint, newPoints);
                    } else {
                        // Create a smooth curve from end to near point
                        const reversedPoints = [...newPoints].reverse();
                        const smoothedReversed = createSmoothConnection(nearUtilityPoint, reversedPoints);
                        newPoints = smoothedReversed.reverse();
                    }
                }
                
                // Update utility line
                if (utility.line) {
                    utility.line.setLatLngs(newPoints);
                }
                
                // Update points in data
                utility.points = newPoints;
                
                // Update marker position
                if (utility.marker) {
                    utility.marker.setLatLng(newPoints[0]);
                }
                
                // Store connection in data
                utility.connectedTo = nearUtility.utility.id;
                nearUtility.utility.connections = nearUtility.utility.connections || [];
                nearUtility.utility.connections.push(utility.id);
            }
            
            // Create smooth connection between points
            function createSmoothConnection(targetPoint, points) {
                if (points.length < 2) return [targetPoint, ...points];
                
                // Add intermediate points to create a smooth curve
                const firstPoint = points[0];
                const secondPoint = points[1];
                
                // Calculate direction vectors
                const v1 = {
                    lat: targetPoint.lat - firstPoint.lat,
                    lng: targetPoint.lng - firstPoint.lng
                };
                
                const v2 = {
                    lat: secondPoint.lat - firstPoint.lat,
                    lng: secondPoint.lng - firstPoint.lng
                };
                
                // Calculate control point - perpendicular to both vectors
                const midPoint = {
                    lat: (targetPoint.lat + firstPoint.lat) / 2,
                    lng: (targetPoint.lng + firstPoint.lng) / 2
                };
                
                // Create smooth curve with bezier interpolation
                const curve = [];
                const steps = 5;
                
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const lat = bezierInterpolation(targetPoint.lat, midPoint.lat, firstPoint.lat, t);
                    const lng = bezierInterpolation(targetPoint.lng, midPoint.lng, firstPoint.lng, t);
                    curve.push(L.latLng(lat, lng));
                }
                
                // Add original points (except first)
                const result = [...curve, ...points.slice(1)];
                return result;
            }
            
            // Bezier interpolation
            function bezierInterpolation(p0, p1, p2, t) {
                return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
            }
            
            // Apply smoothing to line
            function applySmoothingToLine(points) {
                if (points.length <= 2) return points;
                
                const result = [];
                result.push(points[0]); // Include first point
                
                // Apply bezier smoothing between points
                for (let i = 0; i < points.length - 2; i++) {
                    const p0 = points[i];
                    const p1 = points[i + 1];
                    const p2 = points[i + 2];
                    
                    // Calculate control points
                    const controlPoint1 = {
                        lat: (p0.lat + p1.lat) / 2,
                        lng: (p0.lng + p1.lng) / 2
                    };
                    
                    const controlPoint2 = {
                        lat: (p1.lat + p2.lat) / 2,
                        lng: (p1.lng + p2.lng) / 2
                    };
                    
                    // Add intermediate points
                    const steps = 5;
                    for (let j = 1; j <= steps; j++) {
                        const t = j / steps;
                        
                        // Quadratic bezier interpolation
                        const lat = (1 - t) * (1 - t) * p0.lat + 2 * (1 - t) * t * p1.lat + t * t * p2.lat;
                        const lng = (1 - t) * (1 - t) * p0.lng + 2 * (1 - t) * t * p1.lng + t * t * p2.lng;
                        
                        result.push(L.latLng(lat, lng));
                    }
                }
                
                result.push(points[points.length - 1]); // Include last point
                
                return result;
            }
            
            // Calculate end point from start point and direction
            function calculateEndPoint(startPoint, angleDegrees, distance) {
                // Convert angle to radians (0 is North, clockwise)
                const angleRadians = (90 - angleDegrees) * Math.PI / 180;
                
                // Earth's radius in meters
                const earthRadius = 6378137;
                
                // Convert lat/lon to radians
                const lat1 = startPoint.lat * Math.PI / 180;
                const lon1 = startPoint.lng * Math.PI / 180;
                
                // Calculate new point
                const lat2 = Math.asin(
                    Math.sin(lat1) * Math.cos(distance / earthRadius) +
                    Math.cos(lat1) * Math.sin(distance / earthRadius) * Math.cos(angleRadians)
                );
                
                const lon2 = lon1 + Math.atan2(
                    Math.sin(angleRadians) * Math.sin(distance / earthRadius) * Math.cos(lat1),
                    Math.cos(distance / earthRadius) - Math.sin(lat1) * Math.sin(lat2)
                );
                
                // Convert back to degrees
                return L.latLng(lat2 * 180 / Math.PI, lon2 * 180 / Math.PI);
            }
            
            // Start high accuracy repositioning mode
            function startHighAccuracyMode(element) {
                // Find utility data
                let utilityData;
                let isStructure = false;
                
                if (element.utility) {
                    utilityData = element.utility;
                    isStructure = element.isStructure;
                } else {
                    // Check utilities
                    for (const type in utilities) {
                        const found = utilities[type].find(u => u.line === element || u.marker === element);
                        if (found) {
                            utilityData = found;
                            break;
                        }
                    }
                    
                    // Check structures if not found
                    if (!utilityData) {
                        const structure = structures.find(s => s.marker === element);
                        if (structure) {
                            utilityData = structure;
                            isStructure = true;
                        }
                    }
                }
                
                if (!utilityData) return;
                
                // Set editing mode
                isHighAccuracyMode = true;
                editingUtility = utilityData;
                editNodes = [];
                
                // Enable editing mode container
                document.getElementById('editing-mode-container').classList.add('visible');
                
                // Highlight the element being edited
                if (isStructure) {
                    // Structure marker editing
                    if (utilityData.marker) {
                        utilityData.marker._icon.classList.add('utility-marker-selected');
                        
                        // Create a draggable edit node
                        const editNode = L.marker(utilityData.position, {
                            draggable: true,
                            icon: L.divIcon({
                                html: '<div class="edit-node"></div>',
                                className: '',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(editingLayer);
                        
                        // Add drag events
                        editNode.on('drag', function(e) {
                            // Update structure position
                            utilityData.position = e.latlng;
                            
                            // Update marker position
                            utilityData.marker.setLatLng(e.latlng);
                        });
                        
                        editNodes.push(editNode);
                    }
                } else {
                    // Utility line editing
                    if (utilityData.line) {
                        utilityData.line._path.classList.add('utility-line-selected');
                        
                        // Create draggable nodes for each point in the line
                        utilityData.points.forEach((point, index) => {
                            const editNode = L.marker(point, {
                                draggable: true,
                                icon: L.divIcon({
                                    html: '<div class="edit-node"></div>',
                                    className: '',
                                    iconSize: [12, 12],
                                    iconAnchor: [6, 6]
                                })
                            }).addTo(editingLayer);
                            
                            // Add drag events
                            editNode.on('drag', function(e) {
                                // Update point in array
                                utilityData.points[index] = e.latlng;
                                
                                // Update line
                                utilityData.line.setLatLngs(utilityData.points);
                                
                                // Update marker if this is the first point
                                if (index === 0 && utilityData.marker) {
                                    utilityData.marker.setLatLng(e.latlng);
                                }
                            });
                            
                            editNodes.push(editNode);
                        });
                    }
                }
                
                // Zoom in for more accurate editing
                map.setView(
                    isStructure ? utilityData.position : utilityData.points[0],
                    21
                );
                
                // Show toast
                showToast('High accuracy editing mode activated. Drag nodes to reposition.', 'info');
            }
            
            // Add a new edit node
            function addEditNode() {
                if (!isHighAccuracyMode || !editingUtility) return;
                
                // Check if this is a structure
                const isStructure = editingUtility.hasOwnProperty('position');
                
                if (isStructure) {
                    // Can't add nodes to structures
                    showToast('Cannot add nodes to structures', 'warning');
                    return;
                }
                
                // Find the longest segment to add a node to
                let longestSegmentIndex = 0;
                let longestSegmentLength = 0;
                
                for (let i = 0; i < editingUtility.points.length - 1; i++) {
                    const point1 = editingUtility.points[i];
                    const point2 = editingUtility.points[i + 1];
                    const distance = map.distance(point1, point2);
                    
                    if (distance > longestSegmentLength) {
                        longestSegmentLength = distance;
                        longestSegmentIndex = i;
                    }
                }
                
                // Create a midpoint
                const point1 = editingUtility.points[longestSegmentIndex];
                const point2 = editingUtility.points[longestSegmentIndex + 1];
                
                const midpoint = L.latLng(
                    (point1.lat + point2.lat) / 2,
                    (point1.lng + point2.lng) / 2
                );
                
                // Add the midpoint to the utility points
                editingUtility.points.splice(longestSegmentIndex + 1, 0, midpoint);
                
                // Update the line
                editingUtility.line.setLatLngs(editingUtility.points);
                
                // Clear existing edit nodes
                editNodes.forEach(node => {
                    editingLayer.removeLayer(node);
                });
                editNodes = [];
                
                // Create new edit nodes
                editingUtility.points.forEach((point, index) => {
                    const editNode = L.marker(point, {
                        draggable: true,
                        icon: L.divIcon({
                            html: '<div class="edit-node"></div>',
                            className: '',
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(editingLayer);
                    
                    // Add drag events
                    editNode.on('drag', function(e) {
                        // Update point in array
                        editingUtility.points[index] = e.latlng;
                        
                        // Update line
                        editingUtility.line.setLatLngs(editingUtility.points);
                        
                        // Update marker if this is the first point
                        if (index === 0 && editingUtility.marker) {
                            editingUtility.marker.setLatLng(e.latlng);
                        }
                    });
                    
                    editNodes.push(editNode);
                });
                
                // Show toast
                showToast('Node added', 'success');
            }
            
            // Delete an edit node
            function deleteEditNode() {
                if (!isHighAccuracyMode || !editingUtility) return;
                
                // Check if this is a structure
                const isStructure = editingUtility.hasOwnProperty('position');
                
                if (isStructure) {
                    // Can't delete nodes from structures
                    showToast('Cannot delete nodes from structures', 'warning');
                    return;
                }
                
                // Need at least 2 points for a line
                if (editingUtility.points.length <= 2) {
                    showToast('Cannot delete more nodes: minimum 2 nodes required', 'warning');
                    return;
                }
                
                // Find the closest node to the center of the map
                const mapCenter = map.getCenter();
                let closestNodeIndex = 0;
                let closestNodeDistance = Infinity;
                
                for (let i = 0; i < editingUtility.points.length; i++) {
                    const distance = map.distance(mapCenter, editingUtility.points[i]);
                    if (distance < closestNodeDistance) {
                        closestNodeDistance = distance;
                        closestNodeIndex = i;
                    }
                }
                
                // Don't delete first or last point of it's a connection to another utility
                if ((closestNodeIndex === 0 || closestNodeIndex === editingUtility.points.length - 1) && 
                    editingUtility.connectedTo) {
                    showToast('Cannot delete connection point', 'warning');
                    return;
                }
                
                // Remove the point
                editingUtility.points.splice(closestNodeIndex, 1);
                
                // Update the line
                editingUtility.line.setLatLngs(editingUtility.points);
                
                // Clear existing edit nodes
                editNodes.forEach(node => {
                    editingLayer.removeLayer(node);
                });
                editNodes = [];
                
                // Create new edit nodes
                editingUtility.points.forEach((point, index) => {
                    const editNode = L.marker(point, {
                        draggable: true,
                        icon: L.divIcon({
                            html: '<div class="edit-node"></div>',
                            className: '',
                            iconSize: [12, 12],
                            iconAnchor: [6, 6]
                        })
                    }).addTo(editingLayer);
                    
                    // Add drag events
                    editNode.on('drag', function(e) {
                        // Update point in array
                        editingUtility.points[index] = e.latlng;
                        
                        // Update line
                        editingUtility.line.setLatLngs(editingUtility.points);
                        
                        // Update marker if this is the first point
                        if (index === 0 && editingUtility.marker) {
                            editingUtility.marker.setLatLng(e.latlng);
                        }
                    });
                    
                    editNodes.push(editNode);
                });
                
                // Show toast
                showToast('Node deleted', 'success');
            }
            
            // Toggle snap mode
            function toggleSnap() {
                isSnapping = !isSnapping;
                
                // Update button text
                const btn = document.getElementById('toggle-snap-btn');
                btn.innerHTML = `<i class="fas fa-magnet"></i> Snap: ${isSnapping ? 'ON' : 'OFF'}`;
                
                // Show toast
                showToast(`Snap mode ${isSnapping ? 'enabled' : 'disabled'}`, 'info');
            }
            
            // Save high accuracy edits
            function saveHighAccuracyEdits() {
                if (!isHighAccuracyMode || !editingUtility) return;
                
                // Remove highlight
                if (editingUtility.line) {
                    editingUtility.line._path.classList.remove('utility-line-selected');
                }
                
                if (editingUtility.marker) {
                    editingUtility.marker._icon.classList.remove('utility-marker-selected');
                }
                
                // Clear edit nodes
                editNodes.forEach(node => {
                    editingLayer.removeLayer(node);
                });
                editNodes = [];
                
                // Reset editing mode
                isHighAccuracyMode = false;
                editingUtility = null;
                
                // Hide editing mode container
                document.getElementById('editing-mode-container').classList.remove('visible');
                
                // Show toast
                showToast('Changes saved successfully', 'success');
            }
            
            // Cancel high accuracy mode
            function cancelHighAccuracyMode() {
                if (!isHighAccuracyMode || !editingUtility) return;
                
                // Remove highlight
                if (editingUtility.line) {
                    editingUtility.line._path.classList.remove('utility-line-selected');
                }
                
                if (editingUtility.marker) {
                    editingUtility.marker._icon.classList.remove('utility-marker-selected');
                }
                
                // Clear edit nodes
                editNodes.forEach(node => {
                    editingLayer.removeLayer(node);
                });
                editNodes = [];
                
                // Reset editing mode
                isHighAccuracyMode = false;
                editingUtility = null;
                
                // Hide editing mode container
                document.getElementById('editing-mode-container').classList.remove('visible');
                
                // Show toast
                showToast('Editing cancelled', 'info');
            }
            
            // Toggle measure mode
            function toggleMeasureMode() {
                if (isMeasuringMode) {
                    cancelMeasuring();
                } else {
                    startMeasuringMode();
                }
            }
            
            // Start measuring mode
            function startMeasuringMode() {
                // Set measuring mode
                isMeasuringMode = true;
                
                // Highlight the measure button
                document.getElementById('measure-btn').classList.add('active');
                
                // Show toast
                showToast('Click on the map to start measuring', 'info');
            }
            
            // Start measuring from a specific point
            function startMeasuringFrom(latlng) {
                // Set measuring mode
                isMeasuringMode = true;
                measureStartPoint = latlng;
                
                // Highlight the measure button
                document.getElementById('measure-btn').classList.add('active');
                
                // Create start marker
                const startMarker = L.marker(measureStartPoint, {
                    icon: L.divIcon({
                        html: '<div style="width: 12px; height: 12px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white;"></div>',
                        className: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(measurementsLayer);
                
                // Create tooltip
                const tooltip = L.divIcon({
                    html: '<div class="measurement-tag">Click to measure</div>',
                    className: '',
                    iconSize: [100, 20],
                    iconAnchor: [50, 10]
                });
                
                measureTooltip = L.marker(measureStartPoint, {
                    icon: tooltip
                }).addTo(measurementsLayer);
                
                // Create temporary line
                measureLine = L.polyline([measureStartPoint, measureStartPoint], {
                    color: 'var(--primary-color)',
                    weight: 2,
                    dashArray: '5,5'
                }).addTo(measurementsLayer);
                
                // Show toast
                showToast('Click on the map to complete measurement', 'info');
            }
            
            // Complete measurement
            function completeMeasurement(endPoint) {
                if (!isMeasuringMode || !measureStartPoint) return;
                
                // Calculate distance
                const distance = map.distance(measureStartPoint, endPoint);
                
                // Create permanent markers and line
                const startMarker = L.marker(measureStartPoint, {
                    icon: L.divIcon({
                        html: '<div style="width: 12px; height: 12px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white;"></div>',
                        className: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(measurementsLayer);
                
                const endMarker = L.marker(endPoint, {
                    icon: L.divIcon({
                        html: '<div style="width: 12px; height: 12px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white;"></div>',
                        className: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    })
                }).addTo(measurementsLayer);
                
                // Format distance
                let formattedDistance;
                if (useMetric) {
                    formattedDistance = distance < 1000
                        ? `${distance.toFixed(1)} m`
                        : `${(distance / 1000).toFixed(2)} km`;
                } else {
                    const feet = distance * 3.28084;
                    formattedDistance = feet < 1000
                        ? `${feet.toFixed(1)} ft`
                        : `${(feet / 5280).toFixed(2)} mi`;
                }
                
                // Create measurement line with label
                const line = L.polyline([measureStartPoint, endPoint], {
                    color: 'var(--primary-color)',
                    weight: 2
                }).addTo(measurementsLayer);
                
                // Add label at midpoint
                const midpoint = L.latLng(
                    (measureStartPoint.lat + endPoint.lat) / 2,
                    (measureStartPoint.lng + endPoint.lng) / 2
                );
                
                const label = L.marker(midpoint, {
                    icon: L.divIcon({
                        html: `<div class="measurement-tag">${formattedDistance}</div>`,
                        className: '',
                        iconSize: [100, 20],
                        iconAnchor: [50, 10]
                    })
                }).addTo(measurementsLayer);
                
                // Store measurement data
                const measurementId = 'measurement-' + Date.now();
                const measurementData = {
                    id: measurementId,
                    startPoint: measureStartPoint,
                    endPoint: endPoint,
                    distance: distance,
                    startMarker: startMarker,
                    endMarker: endMarker,
                    line: line,
                    label: label
                };
                
                measurements.push(measurementData);
                
                // Clean up temporary elements
                if (measureLine) {
                    measurementsLayer.removeLayer(measureLine);
                    measureLine = null;
                }
                
                if (measureTooltip) {
                    measurementsLayer.removeLayer(measureTooltip);
                    measureTooltip = null;
                }
                
                // Reset measuring mode
                isMeasuringMode = false;
                measureStartPoint = null;
                
                // Unhighlight measure button
                document.getElementById('measure-btn').classList.remove('active');
                
                // Show toast
                showToast(`Measurement: ${formattedDistance}`, 'success');
                
                return measurementData;
            }
            
            // Cancel measuring
            function cancelMeasuring() {
                // Clean up temporary elements
                if (measureLine) {
                    measurementsLayer.removeLayer(measureLine);
                    measureLine = null;
                }
                
                if (measureTooltip) {
                    measurementsLayer.removeLayer(measureTooltip);
                    measureTooltip = null;
                }
                
                // Reset measuring mode
                isMeasuringMode = false;
                measureStartPoint = null;
                
                // Unhighlight measure button
                document.getElementById('measure-btn').classList.remove('active');
                
                // Show toast
                showToast('Measuring cancelled', 'info');
            }
            
            // Update measurement display when units change
            function updateMeasurementDisplay() {
                measurements.forEach(measurement => {
                    // Calculate distance
                    const distance = measurement.distance;
                    
                    // Format distance
                    let formattedDistance;
                    if (useMetric) {
                        formattedDistance = distance < 1000
                            ? `${distance.toFixed(1)} m`
                            : `${(distance / 1000).toFixed(2)} km`;
                    } else {
                        const feet = distance * 3.28084;
                        formattedDistance = feet < 1000
                            ? `${feet.toFixed(1)} ft`
                            : `${(feet / 5280).toFixed(2)} mi`;
                    }
                    
                    // Update label
                    if (measurement.label) {
                        const midpoint = L.latLng(
                            (measurement.startPoint.lat + measurement.endPoint.lat) / 2,
                            (measurement.startPoint.lng + measurement.endPoint.lng) / 2
                        );
                        
                        const icon = L.divIcon({
                            html: `<div class="measurement-tag">${formattedDistance}</div>`,
                            className: '',
                            iconSize: [100, 20],
                            iconAnchor: [50, 10]
                        });
                        
                        measurement.label.setIcon(icon);
                    }
                });
            }
            
            // Edit utility
            function editUtility(element) {
                // Find utility data
                let utilityData;
                let isStructure = false;
                
                if (element.utility) {
                    utilityData = element.utility;
                    isStructure = element.isStructure;
                } else {
                    // Check utilities
                    for (const type in utilities) {
                        const found = utilities[type].find(u => u.line === element || u.marker === element);
                        if (found) {
                            utilityData = found;
                            break;
                        }
                    }
                    
                    // Check structures if not found
                    if (!utilityData) {
                        const structure = structures.find(s => s.marker === element);
                        if (structure) {
                            utilityData = structure;
                            isStructure = true;
                        }
                    }
                }
                
                if (!utilityData) return;
                
                // Show edit modal based on type
                if (isStructure) {
                    // Set up structure edit modal
                    document.getElementById('structure-type').value = utilityData.type;
                    document.getElementById('structure-size').value = utilityData.size || 24;
                    document.getElementById('structure-notes').value = utilityData.notes || '';
                    
                    // Clear and repopulate measurements
                    document.getElementById('structure-measurements-container').innerHTML = '';
                    if (utilityData.measurements && utilityData.measurements.length > 0) {
                        utilityData.measurements.forEach(measurement => {
                            const container = document.getElementById('structure-measurements-container');
                            
                            // Create tag element
                            const tag = document.createElement('div');
                            tag.className = 'measurement-chip';
                            
                            const tagText = document.createElement('span');
                            tagText.textContent = measurement;
                            
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove-btn';
                            removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                            
                            removeBtn.addEventListener('click', function() {
                                tag.remove();
                            });
                            
                            tag.appendChild(tagText);
                            tag.appendChild(removeBtn);
                            container.appendChild(tag);
                        });
                    }
                    
                    // Store the structure being edited
                    selectedElement = {
                        element: element,
                        utility: utilityData,
                        isStructure: true
                    };
                    
                    // Show the structure edit modal
                    showModal('add-structure-modal');
                    
                    // Change button text to "Update"
                    document.getElementById('add-structure-confirm-btn').textContent = 'Update Structure';
                    document.querySelector('#add-structure-modal .modal-title').textContent = 'Edit Structure';
                    
                    // Override confirm button action
                    document.getElementById('add-structure-confirm-btn').onclick = function() {
                        updateStructure();
                    };
                } else {
                    // Set up utility edit modal
                    document.getElementById('utility-type').value = utilityData.type;
                    document.getElementById('utility-size').value = utilityData.size || 4;
                    document.getElementById('utility-size-unit').value = utilityData.sizeUnit || 'inches';
                    document.getElementById('utility-depth').value = utilityData.depth || 3;
                    document.getElementById('utility-depth-unit').value = utilityData.depthUnit || 'feet';
                    document.getElementById('utility-material').value = utilityData.material || '';
                    document.getElementById('utility-notes').value = utilityData.notes || '';
                    
                    // Set line type
                    document.querySelectorAll('#line-type-btn-group .btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#line-type-btn-group [data-type="${utilityData.lineType}"]`).classList.add('active');
                    
                    // Set direction angle
                    directionAngle = utilityData.angle || 0;
                    updateDirectionArrow();
                    
                    // Clear and repopulate measurements
                    document.getElementById('measurements-container').innerHTML = '';
                    if (utilityData.measurements && utilityData.measurements.length > 0) {
                        utilityData.measurements.forEach(measurement => {
                            const container = document.getElementById('measurements-container');
                            
                            // Create tag element
                            const tag = document.createElement('div');
                            tag.className = 'measurement-chip';
                            
                            const tagText = document.createElement('span');
                            tagText.textContent = measurement;
                            
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove-btn';
                            removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                            
                            removeBtn.addEventListener('click', function() {
                                tag.remove();
                            });
                            
                            tag.appendChild(tagText);
                            tag.appendChild(removeBtn);
                            container.appendChild(tag);
                        });
                    }
                    
                    // Store the utility being edited
                    selectedElement = {
                        element: element,
                        utility: utilityData,
                        isStructure: false
                    };
                    
                    // Show the utility edit modal
                    showModal('add-utility-modal');
                    
                    // Change button text to "Update"
                    document.getElementById('add-utility-confirm-btn').textContent = 'Update Utility';
                    document.querySelector('#add-utility-modal .modal-title').textContent = 'Edit Utility';
                    
                    // Override confirm button action
                    document.getElementById('add-utility-confirm-btn').onclick = function() {
                        updateUtility();
                    };
                }
            }
            
            // Update utility
            function updateUtility() {
                if (!selectedElement || !selectedElement.utility || selectedElement.isStructure) {
                    hideAddUtilityModal();
                    return;
                }
                
                const utility = selectedElement.utility;
                
                // Get form values
                const utilityType = document.getElementById('utility-type').value;
                const lineType = document.querySelector('#line-type-btn-group .btn.active').getAttribute('data-type');
                const size = parseFloat(document.getElementById('utility-size').value) || 4;
                const sizeUnit = document.getElementById('utility-size-unit').value;
                const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                const depthUnit = document.getElementById('utility-depth-unit').value;
                const material = document.getElementById('utility-material').value;
                const notes = document.getElementById('utility-notes').value;
                
                // Get measurements
                const measurementTags = document.querySelectorAll('#measurements-container .measurement-chip');
                const measurements = Array.from(measurementTags).map(tag => tag.querySelector('span').textContent);
                
                // Update utility data
                utility.type = utilityType;
                utility.lineType = lineType;
                utility.size = size;
                utility.sizeUnit = sizeUnit;
                utility.depth = depth;
                utility.depthUnit = depthUnit;
                utility.material = material;
                utility.measurements = measurements;
                utility.notes = notes;
                utility.angle = directionAngle;
                
                // Process photo if uploaded
                const photoInput = document.getElementById('utility-photo');
                if (photoInput.files && photoInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        utility.photo = e.target.result;
                        
                        // Update visuals
                        updateUtilityVisuals(utility);
                        
                        // Hide modal
                        hideAddUtilityModal();
                        
                        // Show success message
                        showToast('Utility updated successfully', 'success');
                    };
                    reader.readAsDataURL(photoInput.files[0]);
                } else {
                    // Update visuals
                    updateUtilityVisuals(utility);
                    
                    // Hide modal
                    hideAddUtilityModal();
                    
                    // Show success message
                    showToast('Utility updated successfully', 'success');
                }
                
                // Reset the confirm button action
                document.getElementById('add-utility-confirm-btn').onclick = addFoundUtility;
                document.getElementById('add-utility-confirm-btn').textContent = 'Add Utility';
                document.querySelector('#add-utility-modal .modal-title').textContent = 'Add Found Utility';
                
                // Reset selected element
                selectedElement = null;
            }
            
            // Update structure
            function updateStructure() {
                if (!selectedElement || !selectedElement.utility || !selectedElement.isStructure) {
                    hideAddStructureModal();
                    return;
                }
                
                const structure = selectedElement.utility;
                
                // Get form values
                const structureType = document.getElementById('structure-type').value;
                const size = parseFloat(document.getElementById('structure-size').value) || 24;
                const sizeUnit = document.getElementById('structure-size-unit').value;
                const notes = document.getElementById('structure-notes').value;
                
                // Get measurements
                const measurementTags = document.querySelectorAll('#structure-measurements-container .measurement-chip');
                const measurements = Array.from(measurementTags).map(tag => tag.querySelector('span').textContent);
                
                // Update structure data
                structure.type = structureType;
                structure.size = size;
                structure.sizeUnit = sizeUnit;
                structure.measurements = measurements;
                structure.notes = notes;
                
                // Process photo if uploaded
                const photoInput = document.getElementById('structure-photo');
                if (photoInput.files && photoInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        structure.photo = e.target.result;
                        
                        // Update visuals
                        updateStructureVisuals(structure);
                        
                        // Hide modal
                        hideAddStructureModal();
                        
                        // Show success message
                        showToast('Structure updated successfully', 'success');
                    };
                    reader.readAsDataURL(photoInput.files[0]);
                } else {
                    // Update visuals
                    updateStructureVisuals(structure);
                    
                    // Hide modal
                    hideAddStructureModal();
                    
                    // Show success message
                    showToast('Structure updated successfully', 'success');
                }
                
                // Reset the confirm button action
                document.getElementById('add-structure-confirm-btn').onclick = addStructure;
                document.getElementById('add-structure-confirm-btn').textContent = 'Add Structure';
                document.querySelector('#add-structure-modal .modal-title').textContent = 'Add Structure';
                
                // Reset selected element
                selectedElement = null;
            }
            
            // Update utility visuals
            function updateUtilityVisuals(utility) {
                // Remove old elements
                if (utility.line) {
                    utilitiesLayer.removeLayer(utility.line);
                }
                
                if (utility.marker) {
                    utilitiesLayer.removeLayer(utility.marker);
                }
                
                // Create new visual elements
                const visuals = createUtilityVisuals(utility);
                
                // Update references
                utility.line = visuals.polyline;
                utility.marker = visuals.marker;
            }
            
            // Update structure visuals
            function updateStructureVisuals(structure) {
                // Remove old marker
                if (structure.marker) {
                    structuresLayer.removeLayer(structure.marker);
                }
                
                // Create new marker
                const marker = createStructureMarker(structure);
                
                // Update reference
                structure.marker = marker;
            }
            
            // Delete utility
            function deleteUtility(element) {
                // Find utility data
                let utilityData;
                let isStructure = false;
                
                if (element.utility) {
                    utilityData = element.utility;
                    isStructure = element.isStructure;
                } else {
                    // Check utilities
                    for (const type in utilities) {
                        const found = utilities[type].find(u => u.line === element || u.marker === element);
                        if (found) {
                            utilityData = found;
                            break;
                        }
                    }
                    
                    // Check structures if not found
                    if (!utilityData) {
                        const structure = structures.find(s => s.marker === element);
                        if (structure) {
                            utilityData = structure;
                            isStructure = true;
                        }
                    }
                }
                
                if (!utilityData) return;
                
                // Confirm deletion
                if (!confirm(`Are you sure you want to delete this ${isStructure ? 'structure' : 'utility'}?`)) {
                    return;
                }
                
                if (isStructure) {
                    // Remove visual elements
                    if (utilityData.marker) {
                        structuresLayer.removeLayer(utilityData.marker);
                    }
                    
                    // Remove from structures array
                    const index = structures.findIndex(s => s.id === utilityData.id);
                    if (index !== -1) {
                        structures.splice(index, 1);
                    }
                    
                    // Show success message
                    showToast('Structure deleted successfully', 'success');
                } else {
                    // Remove visual elements
                    if (utilityData.line) {
                        utilitiesLayer.removeLayer(utilityData.line);
                    }
                    
                    if (utilityData.marker) {
                        utilitiesLayer.removeLayer(utilityData.marker);
                    }
                    
                    // Remove from utilities array
                    const index = utilities[utilityData.type].findIndex(u => u.id === utilityData.id);
                    if (index !== -1) {
                        utilities[utilityData.type].splice(index, 1);
                    }
                    
                    // Show success message
                    showToast('Utility deleted successfully', 'success');
                }
            }
            
            // Search location
            function searchLocation() {
                const query = document.getElementById('search-input').value.trim();
                
                if (!query) {
                    showToast('Please enter a search query', 'warning');
                    return;
                }
                
                // Show loading
                document.getElementById('loading-overlay').classList.add('visible');
                
                // Use Nominatim API for geocoding
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`)
                    .then(response => response.json())
                    .then(data => {
                        // Hide loading
                        document.getElementById('loading-overlay').classList.remove('visible');
                        
                        if (data && data.length > 0) {
                            // Show results
                            const resultsContainer = document.getElementById('search-results');
                            resultsContainer.innerHTML = '';
                            
                            data.slice(0, 5).forEach(result => {
                                const resultItem = document.createElement('div');
                                resultItem.style.padding = '10px';
                                resultItem.style.borderBottom = '1px solid var(--divider-color)';
                                resultItem.style.cursor = 'pointer';
                                resultItem.textContent = result.display_name;
                                
                                resultItem.addEventListener('click', function() {
                                    // Go to this location
                                    map.setView([result.lat, result.lon], 19);
                                    
                                    // Hide modal
                                    hideLocationSearchModal();
                                });
                                
                                resultsContainer.appendChild(resultItem);
                            });
                        } else {
                            // No results
                            const resultsContainer = document.getElementById('search-results');
                            resultsContainer.innerHTML = '<div style="padding: 10px; color: var(--text-secondary);">No results found</div>';
                        }
                    })
                    .catch(error => {
                        console.error('Error searching for location:', error);
                        
                        // Hide loading
                        document.getElementById('loading-overlay').classList.remove('visible');
                        
                        // Show error
                        showToast('Error searching for location', 'error');
                    });
            }
            
            // Export data
            function exportData() {
                // Create export data object
                const exportData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    center: map.getCenter(),
                    zoom: map.getZoom(),
                    utilities: utilities,
                    structures: structures,
                    measurements: measurements
                };
                
                // Convert to JSON
                const json = JSON.stringify(exportData, (key, value) => {
                    // Handle circular references
                    if (key === 'line' || key === 'marker' || key === 'startMarker' || key === 'endMarker' || key === 'label' || key === 'accuracyCircle') {
                        return undefined;
                    }
                    return value;
                }, 2);
                
                // Create download link
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `utilitrack_export_${new Date().toISOString().slice(0, 10)}.json`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show success message
                showToast('Data exported successfully', 'success');
            }
            
            // Import data
            function importData() {
                // Create file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/json';
                
                // Add change event
                fileInput.addEventListener('change', function() {
                    if (fileInput.files && fileInput.files[0]) {
                        const file = fileInput.files[0];
                        const reader = new FileReader();
                        
                        // Show loading
                        document.getElementById('loading-overlay').classList.add('visible');
                        
                        reader.onload = function(e) {
                            try {
                                // Parse JSON
                                const importData = JSON.parse(e.target.result);
                                
                                // Validate data
                                if (!importData.version || !importData.utilities || !importData.structures) {
                                    throw new Error('Invalid import file format');
                                }
                                
                                // Confirm import
                                if (confirm(`This will replace all current data with imported data. Continue?`)) {
                                    // Clear current data
                                    for (const type in utilities) {
                                        utilities[type].forEach(utility => {
                                            if (utility.line) utilitiesLayer.removeLayer(utility.line);
                                            if (utility.marker) utilitiesLayer.removeLayer(utility.marker);
                                        });
                                        utilities[type] = [];
                                    }
                                    
                                    structures.forEach(structure => {
                                        if (structure.marker) structuresLayer.removeLayer(structure.marker);
                                    });
                                    structures.length = 0;
                                    
                                    measurements.forEach(measurement => {
                                        if (measurement.startMarker) measurementsLayer.removeLayer(measurement.startMarker);
                                        if (measurement.endMarker) measurementsLayer.removeLayer(measurement.endMarker);
                                        if (measurement.line) measurementsLayer.removeLayer(measurement.line);
                                        if (measurement.label) measurementsLayer.removeLayer(measurement.label);
                                    });
                                    measurements.length = 0;
                                    
                                    // Import utilities
                                    for (const type in importData.utilities) {
                                        importData.utilities[type].forEach(utility => {
                                            // Recreate utility visuals
                                            const visuals = createUtilityVisuals(utility);
                                            utility.line = visuals.polyline;
                                            utility.marker = visuals.marker;
                                            
                                            // Add to utilities collection
                                            utilities[type].push(utility);
                                        });
                                    }
                                    
                                    // Import structures
                                    importData.structures.forEach(structure => {
                                        // Recreate structure marker
                                        const marker = createStructureMarker(structure);
                                        structure.marker = marker;
                                        
                                        // Add to structures collection
                                        structures.push(structure);
                                    });
                                    
                                    // Import measurements if present
                                    if (importData.measurements) {
                                        importData.measurements.forEach(measurement => {
                                            // Recreate measurement visuals
                                            const startMarker = L.marker(measurement.startPoint, {
                                                icon: L.divIcon({
                                                    html: '<div style="width: 12px; height: 12px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white;"></div>',
                                                    className: '',
                                                    iconSize: [12, 12],
                                                    iconAnchor: [6, 6]
                                                })
                                            }).addTo(measurementsLayer);
                                            
                                            const endMarker = L.marker(measurement.endPoint, {
                                                icon: L.divIcon({
                                                    html: '<div style="width: 12px; height: 12px; background-color: var(--primary-color); border-radius: 50%; border: 2px solid white;"></div>',
                                                    className: '',
                                                    iconSize: [12, 12],
                                                    iconAnchor: [6, 6]
                                                })
                                            }).addTo(measurementsLayer);
                                            
                                            const line = L.polyline([measurement.startPoint, measurement.endPoint], {
                                                color: 'var(--primary-color)',
                                                weight: 2
                                            }).addTo(measurementsLayer);
                                            
                                            // Format distance
                                            let formattedDistance;
                                            if (useMetric) {
                                                formattedDistance = measurement.distance < 1000
                                                    ? `${measurement.distance.toFixed(1)} m`
                                                    : `${(measurement.distance / 1000).toFixed(2)} km`;
                                            } else {
                                                const feet = measurement.distance * 3.28084;
                                                formattedDistance = feet < 1000
                                                    ? `${feet.toFixed(1)} ft`
                                                    : `${(feet / 5280).toFixed(2)} mi`;
                                            }
                                            
                                            // Calculate midpoint
                                            const midpoint = L.latLng(
                                                (measurement.startPoint.lat + measurement.endPoint.lat) / 2,
                                                (measurement.startPoint.lng + measurement.endPoint.lng) / 2
                                            );
                                            
                                            const label = L.marker(midpoint, {
                                                icon: L.divIcon({
                                                    html: `<div class="measurement-tag">${formattedDistance}</div>`,
                                                    className: '',
                                                    iconSize: [100, 20],
                                                    iconAnchor: [50, 10]
                                                })
                                            }).addTo(measurementsLayer);
                                            
                                            // Update measurement references
                                            measurement.startMarker = startMarker;
                                            measurement.endMarker = endMarker;
                                            measurement.line = line;
                                            measurement.label = label;
                                            
                                            // Add to measurements collection
                                            measurements.push(measurement);
                                        });
                                    }
                                    
                                    // Set map view
                                    if (importData.center && importData.zoom) {
                                        map.setView([importData.center.lat, importData.center.lng], importData.zoom);
                                    }
                                    
                                    // Show success message
                                    showToast('Data imported successfully', 'success');
                                }
                            } catch (error) {
                                console.error('Error importing data:', error);
                                showToast('Error importing data: ' + error.message, 'error');
                            }
                            
                            // Hide loading
                            document.getElementById('loading-overlay').classList.remove('visible');
                        };
                        
                        reader.onerror = function() {
                            // Hide loading
                            document.getElementById('loading-overlay').classList.remove('visible');
                            
                            // Show error
                            showToast('Error reading file', 'error');
                        };
                        
                        reader.readAsText(file);
                    }
                });
                
                // Trigger file input click
                fileInput.click();
            }
            
            // Handle map click event
            function handleMapClick(e) {
                // Hide context menu and info card
                hideContextMenu();
                hideInfoCard();
                
                // Handle click based on current mode
                if (isDrawingMode) {
                    // Add point to drawing
                    drawingPoints.push(e.latlng);
                    
                    // Update temp line
                    if (drawingPoints.length === 1) {
                        // First click, create temp line
                        tempLine = L.polyline([e.latlng, e.latlng], {
                            color: utilityConfig[selectedUtilityType].color,
                            weight: selectedLineType === 'main' ? 6 : 4,
                            opacity: 0.7,
                            dashArray: '5,5'
                        }).addTo(tempLayer);
                        
                        // Add mousemove listener
                        map.on('mousemove', updateTempLine);
                    } else {
                        // Update temp line
                        if (tempLine) {
                            tempLine.setLatLngs(drawingPoints.concat([e.latlng]));
                        }
                    }
                } else if (isMeasuringMode) {
                    if (!measureStartPoint) {
                        // Start a new measurement
                        startMeasuringFrom(e.latlng);
                    } else {
                        // Complete measurement
                        completeMeasurement(e.latlng);
                    }
                }
            }
            
            // Update temporary line during drawing
            function updateTempLine(e) {
                if (isDrawingMode && tempLine && drawingPoints.length > 0) {
                    // Create a copy of drawing points and add mouse position
                    const points = drawingPoints.concat([e.latlng]);
                    tempLine.setLatLngs(points);
                    
                    // Update measure tooltip if measuring
                    if (isMeasuringMode && measureTooltip && measureStartPoint) {
                        // Calculate distance
                        const distance = map.distance(measureStartPoint, e.latlng);
                        
                        // Format distance
                        let formattedDistance;
                        if (useMetric) {
                            formattedDistance = distance < 1000
                                ? `${distance.toFixed(1)} m`
                                : `${(distance / 1000).toFixed(2)} km`;
                        } else {
                            const feet = distance * 3.28084;
                            formattedDistance = feet < 1000
                                ? `${feet.toFixed(1)} ft`
                                : `${(feet / 5280).toFixed(2)} mi`;
                        }
                        
                        // Update tooltip
                        const tooltip = L.divIcon({
                            html: `<div class="measurement-tag">${formattedDistance}</div>`,
                            className: '',
                            iconSize: [100, 20],
                            iconAnchor: [50, 10]
                        });
                        
                        measureTooltip.setIcon(tooltip);
                        
                        // Update tooltip position
                        const midpoint = L.latLng(
                            (measureStartPoint.lat + e.latlng.lat) / 2,
                            (measureStartPoint.lng + e.latlng.lng) / 2
                        );
                        measureTooltip.setLatLng(midpoint);
                        
                        // Update line
                        measureLine.setLatLngs([measureStartPoint, e.latlng]);
                    }
                }
            }
            
            // Handle context menu event
            function handleContextMenu(e) {
                // Get element at click point
                const element = getElementAtPoint(e.latlng);
                
                // Show context menu
                showContextMenu(e, element);
            }
            
            // Get element at point
            function getElementAtPoint(latlng) {
                let closestElement = null;
                let closestDistance = Infinity;
                
                // Check utilities
                for (const type in utilities) {
                    utilities[type].forEach(utility => {
                        if (utility.marker) {
                            const distance = map.distance(latlng, utility.marker.getLatLng());
                            if (distance < 10 && distance < closestDistance) {
                                closestElement = utility.marker;
                                closestDistance = distance;
                            }
                        }
                        
                        if (utility.line) {
                            const points = utility.line.getLatLngs();
                            for (let i = 0; i < points.length - 1; i++) {
                                const distance = distanceToSegment(latlng, points[i], points[i + 1]);
                                if (distance < 10 && distance < closestDistance) {
                                    closestElement = utility.line;
                                    closestDistance = distance;
                                }
                            }
                        }
                    });
                }
                
                // Check structures
                structures.forEach(structure => {
                    if (structure.marker) {
                        const distance = map.distance(latlng, structure.marker.getLatLng());
                        if (distance < 10 && distance < closestDistance) {
                            closestElement = structure.marker;
                            closestDistance = distance;
                        }
                    }
                });
                
                return closestElement;
            }
            
            // Calculate distance from point to segment
            function distanceToSegment(point, segmentStart, segmentEnd) {
                // Convert to layer points (pixels)
                const p = map.latLngToLayerPoint(point);
                const p1 = map.latLngToLayerPoint(segmentStart);
                const p2 = map.latLngToLayerPoint(segmentEnd);
                
                // Calculate vectors
                const x = p.x;
                const y = p.y;
                const x1 = p1.x;
                const y1 = p1.y;
                const x2 = p2.x;
                const y2 = p2.y;
                
                // Calculate squared length of segment
                const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                
                // If segment is a point, return distance to that point
                if (l2 === 0) {
                    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
                }
                
                // Calculate projection of point onto segment
                let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;
                
                // Clamp t to [0, 1]
                t = Math.max(0, Math.min(1, t));
                
                // Calculate nearest point on segment
                const projX = x1 + t * (x2 - x1);
                const projY = y1 + t * (y2 - y1);
                
                // Calculate distance to nearest point
                return Math.sqrt((x - projX) * (x - projX) + (y - projY) * (y - projY));
            }
            
            // Initialize the app
            initializeMap();
            initializeUI();
            
            // Add event listener for window resize
            window.addEventListener('resize', function() {
                // Reposition info card if visible
                if (document.getElementById('utility-info-card').classList.contains('visible') && selectedElement) {
                    // Get position of selected element
                    let position;
                    if (selectedElement.element.getLatLng) {
                        position = selectedElement.element.getLatLng();
                    } else if (selectedElement.utility && selectedElement.utility.marker) {
                        position = selectedElement.utility.marker.getLatLng();
                    }
                    
                    if (position) {
                        const point = map.latLngToContainerPoint(position);
                        const infoCard = document.getElementById('utility-info-card');
                        infoCard.style.left = `${point.x + 20}px`;
                        infoCard.style.top = `${point.y - 20}px`;
                    }
                }
            });
            
            // Remove event listeners on unload
            window.addEventListener('beforeunload', function() {
                if (window.watchPositionId) {
                    navigator.geolocation.clearWatch(window.watchPositionId);
                }
            });
        }
    </script>
</body>
</html>
                                 {
                                position: absolute;
                                content: "";
                                height: 16px;
                                width: 16px;
                                left: 2px;
                                bottom: 2px;
                                background-color: white;
                                transition: .3s;
                                border-radius: 50%;
                            }
                            input:checked + .toggle-slider {
                                background-color: var(--primary-color);
                            }
                            input:checked + .toggle-slider:before {
                                transform: translateX(20px);
                            }
                        </style>
                    `;
                    
                    // Assemble toggle switch
                    toggleSwitch.appendChild(checkbox);
                    toggleSwitch.appendChild(slider);
                    
                    // Assemble toggle item
                    toggleItem.appendChild(label);
                    toggleItem.appendChild(toggleSwitch);
                    
                    // Add to container
                    utilityToggleContainer.appendChild(toggleItem);
                }
                
                // Add line type toggles
                const lineTypes = [
                    {id: 'main', name: 'Mains', icon: 'project-diagram'},
                    {id: 'service', name: 'Services', icon: 'home'}
                ];
                
                lineTypes.forEach(type => {
                    // Create toggle item
                    const toggleItem = document.createElement('div');
                    toggleItem.className = 'toggle-item';
                    toggleItem.style.display = 'flex';
                    toggleItem.style.justifyContent = 'space-between';
                    toggleItem.style.alignItems = 'center';
                    toggleItem.style.padding = '8px 0';
                    toggleItem.style.borderBottom = '1px solid var(--divider-color)';
                    
                    // Create label
                    const label = document.createElement('div');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    
                    // Create icon
                    const icon = document.createElement('i');
                    icon.className = `fas fa-${type.icon}`;
                    icon.style.width = '16px';
                    icon.style.textAlign = 'center';
                    
                    // Create name
                    const name = document.createElement('span');
                    name.textContent = type.name;
                    
                    // Assemble label
                    label.appendChild(icon);
                    label.appendChild(name);
                    
                    // Create toggle switch
                    const toggleSwitch = document.createElement('label');
                    toggleSwitch.className = 'toggle-switch';
                    toggleSwitch.style.position = 'relative';
                    toggleSwitch.style.display = 'inline-block';
                    toggleSwitch.style.width = '40px';
                    toggleSwitch.style.height = '20px';
                    
                    // Create checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.dataset.type = type.id;
                    checkbox.style.opacity = '0';
                    checkbox.style.width = '0';
                    checkbox.style.height = '0';
                    
                    // Add event listener to toggle line type visibility
                    checkbox.addEventListener('change', function() {
                        toggleLineTypeVisibility(type.id, this.checked);
                    });
                    
                    // Create slider
                    const slider = document.createElement('span');
                    slider.className = 'toggle-slider';
                    slider.style.position = 'absolute';
                    slider.style.cursor = 'pointer';
                    slider.style.top = '0';
                    slider.style.left = '0';
                    slider.style.right = '0';
                    slider.style.bottom = '0';
                    slider.style.backgroundColor = '#ccc';
                    slider.style.transition = '.3s';
                    slider.style.borderRadius = '34px';
                    
                    // Create slider thumb
                    slider.innerHTML = `
                        <style>
                            .toggle-slider:before {
                                position: absolute;
                                content: "";
                                height: 16px;
                                width: 16px;
                                left: 2px;
                                bottom: 2px;
                                background-color: white;
                                transition: .3s;
                                border-radius: 50%;
                            }
                            input:checked + .toggle-slider {
                                background-color: var(--primary-color);
                            }
                            input:checked + .toggle-slider:before {
                                transform: translateX(20px);
                            }
                        </style>
                    `;
                    
                    // Assemble toggle switch
                    toggleSwitch.appendChild(checkbox);
                    toggleSwitch.appendChild(slider);
                    
                    // Assemble toggle item
                    toggleItem.appendChild(label);
                    toggleItem.appendChild(toggleSwitch);
                    
                    // Add to container
                    lineToggleContainer.appendChild(toggleItem);
                });
                
                // Add structure type toggles
                for (const type in structureConfig) {
                    const config = structureConfig[type];
                    
                    // Create toggle item
                    const toggleItem = document.createElement('div');
                    toggleItem.className = 'toggle-item';
                    toggleItem.style.display = 'flex';
                    toggleItem.style.justifyContent = 'space-between';
                    toggleItem.style.alignItems = 'center';
                    toggleItem.style.padding = '8px 0';
                    toggleItem.style.borderBottom = '1px solid var(--divider-color)';
                    
                    // Create label
                    const label = document.createElement('div');
                    label.style.display = 'flex';
                    label.style.alignItems = 'center';
                    label.style.gap = '8px';
                    
                    // Create color indicator
                    const colorIndicator = document.createElement('div');
                    colorIndicator.style.width = '16px';
                    colorIndicator.style.height = '16px';
                    colorIndicator.style.backgroundColor = config.color;
                    colorIndicator.style.borderRadius = config.shape === 'circle' ? '50%' : '4px';
                    
                    // Create name
                    const name = document.createElement('span');
                    name.textContent = config.name;
                    
                    // Assemble label
                    label.appendChild(colorIndicator);
                    label.appendChild(name);
                    
                    // Create toggle switch
                    const toggleSwitch = document.createElement('label');
                    toggleSwitch.className = 'toggle-switch';
                    toggleSwitch.style.position = 'relative';
                    toggleSwitch.style.display = 'inline-block';
                    toggleSwitch.style.width = '40px';
                    toggleSwitch.style.height = '20px';
                    
                    // Create checkbox
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = true;
                    checkbox.dataset.type = type;
                    checkbox.style.opacity = '0';
                    checkbox.style.width = '0';
                    checkbox.style.height = '0';
                    
                    // Add event listener to toggle structure visibility
                    checkbox.addEventListener('change', function() {
                        toggleStructureVisibility(type, this.checked);
                    });
                    
                    // Create slider
                    const slider = document.createElement('span');
                    slider.className = 'toggle-slider';
                    slider.style.position = 'absolute';
                    slider.style.cursor = 'pointer';
                    slider.style.top = '0';
                    slider.style.left = '0';
                    slider.style.right = '0';
                    slider.style.bottom = '0';
                    slider.style.backgroundColor = '#ccc';
                    slider.style.transition = '.3s';
                    slider.style.borderRadius = '34px';
                    
                    // Create slider thumb
                    slider.innerHTML = `
                        <style>
                            .toggle-slider:before
