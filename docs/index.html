<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FlowMaster Pro 3.0</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Material Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <style>
        :root {
            --primary-color: #0075ff;
            --secondary-color: #ffcc00;
            --accent-color: #ff3e30;
            --success-color: #00c853;
            --dark-color: #263238;
            --light-color: #f5f5f5;
            --text-color: #212121;
            --gray-color: #757575;
            --panel-bg: rgba(255, 255, 255, 0.97);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --rounded: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            color: var(--text-color);
            background-color: var(--light-color);
        }

        .app-container {
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* Top Action Bar */
        .action-bar {
            position: absolute;
            top: 12px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
            pointer-events: none;
        }

        .action-group {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .action-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
        }

        .action-button i {
            font-size: 20px;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Drawing Toolbar */
        .drawing-toolbar {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 12px;
            background-color: var(--panel-bg);
            border-radius: 24px;
            padding: 6px;
            box-shadow: var(--shadow);
        }

        .tool-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
        }

        .tool-button i {
            font-size: 24px;
        }

        .tool-button:active {
            transform: scale(0.95);
        }

        .tool-button.street-tool.active {
            background-color: var(--primary-color);
            color: white;
            border-color: white;
        }

        .tool-button.curb-tool.active {
            background-color: var(--secondary-color);
            color: var(--dark-color);
            border-color: white;
        }

        .tool-button.high-point-tool.active {
            background-color: #ff9800;
            color: white;
            border-color: white;
        }

        .tool-button.catch-basin-tool.active {
            background-color: #2196f3;
            color: white;
            border-color: white;
        }

        /* Layer Toggle Panel */
        .layer-panel {
            position: absolute;
            top: 12px;
            right: 10px;
            z-index: 1000;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 12px;
            box-shadow: var(--shadow);
            min-width: 200px;
            transform: translateX(220px);
            transition: transform 0.3s ease;
        }

        .layer-panel.visible {
            transform: translateX(0);
        }

        .layer-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .layer-panel-title {
            font-weight: 600;
            font-size: 16px;
        }

        .layer-panel-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--dark-color);
            font-size: 18px;
        }

        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .layer-toggle:last-child {
            margin-bottom: 0;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .toggle-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .street-indicator {
            background-color: var(--primary-color);
        }

        .curb-indicator {
            background-color: var(--secondary-color);
        }

        .basin-indicator {
            color: #2196f3;
            font-size: 14px;
        }

        .highpoint-indicator {
            color: #ff9800;
            font-size: 14px;
        }

        /* Pitch Input Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 20px;
            width: 90%;
            max-width: 320px;
            box-shadow: var(--shadow);
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pitch-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .pitch-adjust-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--light-color);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
        }

        .pitch-value {
            font-size: 24px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .modal-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: 16px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: var(--rounded);
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .cancel-btn {
            background-color: var(--light-color);
            color: var(--dark-color);
        }

        .confirm-btn {
            background-color: var(--primary-color);
            color: white;
        }

        .modal-btn:active {
            transform: scale(0.98);
        }

        /* Help Modal */
        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .help-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 480px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .help-title {
            font-size: 20px;
            font-weight: 600;
        }

        .help-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
        }

        .help-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        .help-text {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .feature-list {
            list-style: none;
        }

        .feature-item {
            display: flex;
            margin-bottom: 16px;
            align-items: flex-start;
        }

        .feature-icon {
            flex-shrink: 0;
            width: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: var(--primary-color);
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--dark-color);
            color: white;
            border-radius: var(--rounded);
            padding: 12px 20px;
            z-index: 2000;
            box-shadow: var(--shadow);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        /* Map Styling */
        .pitch-arrow {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .pitch-arrow svg {
            width: 100%;
            height: 100%;
        }

        .street-arrow path {
            fill: var(--primary-color);
        }

        .curb-arrow path {
            fill: var(--secondary-color);
        }

        .street-line {
            stroke: var(--primary-color);
            stroke-width: 5;
            stroke-dasharray: none;
        }

        .curb-line {
            stroke: var(--secondary-color);
            stroke-width: 5;
            stroke-dasharray: none;
        }

        .catch-basin-icon {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            background-color: #2196f3;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
        }

        .high-point-icon {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: var(--dark-color);
            background-color: #ff9800;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
        }

        .trapped-water-area {
            fill: rgba(255, 0, 0, 0.3);
            stroke: #ff0000;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 0.9; }
            100% { opacity: 0.6; }
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .splash-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--light-color);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            padding: 8px 0;
            z-index: 1500;
            min-width: 160px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item i {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        /* Street paths highlighting */
        .leaflet-overlay-pane path.highlight-street {
            stroke: rgba(0, 117, 255, 0.3);
            stroke-width: 12;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .leaflet-overlay-pane path.highlight-curb-left,
        .leaflet-overlay-pane path.highlight-curb-right {
            stroke: rgba(255, 204, 0, 0.3);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        /* Status bar */
        .status-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 999;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-bar i {
            color: var(--primary-color);
        }

        /* Style adjustments for smaller screens */
        @media (max-width: 480px) {
            .drawing-toolbar {
                padding: 4px;
                gap: 8px;
            }

            .tool-button {
                width: 48px;
                height: 48px;
            }

            .tool-button i {
                font-size: 20px;
            }

            .action-button {
                width: 42px;
                height: 42px;
            }

            .action-button i {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-water"></i>
        </div>
        <div class="splash-title">FlowMaster Pro</div>
        <div class="splash-subtitle">Professional Drainage Planning Tool</div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Map Element -->
        <div id="map"></div>

        <!-- Top Action Bar -->
        <div class="action-bar">
            <div class="action-group">
                <button class="action-button" id="locate-btn" title="My Location">
                    <i class="fas fa-crosshairs"></i>
                </button>
                <button class="action-button" id="undo-btn" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            </div>
            <div class="action-group">
                <button class="action-button" id="layers-btn" title="Toggle Layers">
                    <i class="fas fa-layer-group"></i>
                </button>
                <button class="action-button" id="help-btn" title="Help">
                    <i class="fas fa-question"></i>
                </button>
            </div>
        </div>

        <!-- Layer Toggle Panel -->
        <div class="layer-panel" id="layer-panel">
            <div class="layer-panel-header">
                <div class="layer-panel-title">Visibility Layers</div>
                <button class="layer-panel-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="layer-toggle">
                <div class="toggle-label">
                    <div class="toggle-indicator street-indicator"></div>
                    Street Pitches
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="street-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="layer-toggle">
                <div class="toggle-label">
                    <div class="toggle-indicator curb-indicator"></div>
                    Curb Pitches
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="curb-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="layer-toggle">
                <div class="toggle-label">
                    <i class="fas fa-chevron-up toggle-indicator highpoint-indicator"></i>
                    High Points
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="highpoint-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="layer-toggle">
                <div class="toggle-label">
                    <i class="fas fa-drain toggle-indicator basin-indicator"></i>
                    Catch Basins
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="basin-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="layer-toggle">
                <div class="toggle-label">
                    <i class="fas fa-exclamation-triangle toggle-indicator" style="color: var(--accent-color);"></i>
                    Trapped Water
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="trapped-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <!-- Drawing Toolbar -->
        <div class="drawing-toolbar">
            <button class="tool-button street-tool" id="street-tool" title="Draw Street Pitch">
                <i class="fas fa-road"></i>
            </button>
            <button class="tool-button curb-tool" id="curb-tool" title="Draw Curb Pitch">
                <i class="fas fa-grip-lines"></i>
            </button>
            <button class="tool-button high-point-tool" id="high-point-tool" title="Add High Point">
                <i class="fas fa-chevron-up"></i>
            </button>
            <button class="tool-button catch-basin-tool" id="catch-basin-tool" title="Add Catch Basin">
                <i class="fas fa-drain"></i>
            </button>
            <button class="tool-button" id="clear-tool" title="Clear All">
                <i class="fas fa-trash"></i>
            </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <i class="fas fa-info-circle"></i>
            <span id="status-text">Select a tool to begin</span>
        </div>

        <!-- Pitch Input Modal -->
        <div class="modal-overlay" id="pitch-modal">
            <div class="modal-container">
                <div class="modal-header" id="pitch-modal-title">Set Pitch Percentage</div>
                <div class="modal-content">
                    <div class="pitch-input-container">
                        <button class="pitch-adjust-btn" id="decrease-pitch">
                            <i class="fas fa-minus"></i>
                        </button>
                        <div class="pitch-value" id="pitch-value">2.0%</div>
                        <button class="pitch-adjust-btn" id="increase-pitch">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn cancel-btn" id="cancel-pitch">Cancel</button>
                        <button class="modal-btn confirm-btn" id="confirm-pitch">Confirm</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="reverse-direction">
                <i class="fas fa-exchange-alt"></i>
                <span>Reverse Direction</span>
            </div>
            <div class="context-menu-item" id="delete-item">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="help-modal" id="help-modal">
            <div class="help-container">
                <div class="help-header">
                    <div class="help-title">FlowMaster Pro Help</div>
                    <button class="help-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="help-content">
                    <div class="help-section">
                        <div class="help-section-title">Getting Started</div>
                        <p class="help-text">FlowMaster Pro helps you plan water drainage on construction sites. The app uses real street data, allowing you to mark pitches and drainage points accurately on actual roads.</p>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Drawing Tools</div>
                        <ul class="feature-list">
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-road"></i>
                                </div>
                                <div>
                                    <strong>Street Pitch</strong> - Draw blue slope lines on streets to indicate drainage direction.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-grip-lines"></i>
                                </div>
                                <div>
                                    <strong>Curb Pitch</strong> - Draw yellow slope lines on curbs to indicate drainage direction.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-chevron-up"></i>
                                </div>
                                <div>
                                    <strong>High Points</strong> - Mark the highest elevation points where water flows away from.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-drain"></i>
                                </div>
                                <div>
                                    <strong>Catch Basins</strong> - Mark drainage points where water will collect.
                                </div>
                            </li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Special Features</div>
                        <ul class="feature-list">
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-exchange-alt"></i>
                                </div>
                                <div>
                                    <strong>Reverse Direction</strong> - Right-click or long-press on a pitch line to reverse its flow direction.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-exclamation-triangle"></i>
                                </div>
                                <div>
                                    <strong>Trapped Water Detection</strong> - The app automatically highlights areas where water will be trapped (when pitches flow toward each other).
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-layer-group"></i>
                                </div>
                                <div>
                                    <strong>Layer Visibility</strong> - Toggle visibility of different elements (streets, curbs, catch basins) from the layers panel.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-undo"></i>
                                </div>
                                <div>
                                    <strong>Undo</strong> - Easily undo your last action with the undo button.
                                </div>
                            </li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Tips</div>
                        <p class="help-text">• Street pitches automatically snap to the actual roads<br>
                        • Curb pitches automatically snap to the edges of roads<br>
                        • Right-click or long-press any element to access more options<br>
                        • Use the center button to return to your current location<br>
                        • Red highlighted areas indicate where water will be trapped</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Notification -->
        <div class="notification" id="notification">
            <i class="fas fa-info-circle"></i>
            <span id="notification-text">Notification message</span>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for splash screen
            setTimeout(() => {
                document.querySelector('.splash-screen').style.opacity = 0;
                setTimeout(() => {
                    document.querySelector('.splash-screen').style.display = 'none';
                    initApp();
                }, 500);
            }, 2000);

            function initApp() {
                // Initialize variables
                let map, userMarker, currentPosition;
                let activeDrawingMode = null;
                let pitchPercent = 2.0;
                let currentDrawingType = null;
                let tempLine = null;
                let drawingPoints = [];
                let isDrawing = false;
                let undoStack = [];
                let selectedElement = null;
                
                // Feature layers
                let streetPitchesLayer = L.layerGroup();
                let curbPitchesLayer = L.layerGroup();
                let highPointsLayer = L.layerGroup();
                let catchBasinsLayer = L.layerGroup();
                let trappedWaterLayer = L.layerGroup();
                
                // Overlay layers for streets and curbs
                let streetsOverlay = L.layerGroup();
                let curbsLeftOverlay = L.layerGroup();
                let curbsRightOverlay = L.layerGroup();
                
                // Road data storage
                let roadData = {
                    streets: [],
                    curbs: []
                };
                
                // Initialize map
                initMap();
                
                // Initialize UI interactions
                initUIHandlers();
                
                function initMap() {
                    // Create map with default view (will be updated with user location)
                    map = L.map('map', {
                        zoomControl: false
                    }).setView([0, 0], 2);
                    
                    // Add zoom control to bottom left
                    L.control.zoom({
                        position: 'bottomleft'
                    }).addTo(map);
                    
                    // Add OpenStreetMap tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        maxZoom: 22
                    }).addTo(map);
                    
                    // Add feature layers to map
                    streetPitchesLayer.addTo(map);
                    curbPitchesLayer.addTo(map);
                    highPointsLayer.addTo(map);
                    catchBasinsLayer.addTo(map);
                    trappedWaterLayer.addTo(map);
                    
                    // Add overlay layers
                    streetsOverlay.addTo(map);
                    curbsLeftOverlay.addTo(map);
                    curbsRightOverlay.addTo(map);
                    
                    // Get user location
                    getUserLocation();
                    
                    // Map event listeners
                    map.on('click', handleMapClick);
                    map.on('mousemove', handleMouseMove);
                    map.on('contextmenu', handleContextMenu);
                    map.on('movestart', hideContextMenu);
                    
                    // Listen for zoom end to fetch road data
                    map.on('zoomend', function() {
                        fetchRoadData();
                    });
                    
                    // Listen for move end to fetch road data
                    map.on('moveend', function() {
                        fetchRoadData();
                    });
                }
                
                function getUserLocation() {
                    // Update status
                    updateStatus('Finding your location...');
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Check if geolocation is available
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(function(position) {
                            // Store position
                            currentPosition = [position.coords.latitude, position.coords.longitude];
                            
                            // Update map center
                            map.setView(currentPosition, 19);
                            
                            // Create user marker if not exists
                            if (!userMarker) {
                                userMarker = L.circleMarker(currentPosition, {
                                    radius: 8,
                                    fillColor: '#2962ff',
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(map);
                            } else {
                                userMarker.setLatLng(currentPosition);
                            }
                            
                            // Fetch road data for this location
                            fetchRoadData();
                            
                            // Update status
                            updateStatus('Select a tool to begin');
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Watch position for updates
                            navigator.geolocation.watchPosition(function(position) {
                                // Update current position
                                currentPosition = [position.coords.latitude, position.coords.longitude];
                                
                                // Update user marker
                                if (userMarker) {
                                    userMarker.setLatLng(currentPosition);
                                }
                            }, function(error) {
                                console.error('Error watching position:', error);
                            }, {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 5000
                            });
                            
                        }, function(error) {
                            console.error('Error getting location:', error);
                            
                            // Update status
                            updateStatus('Location access denied. Please enable GPS.');
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Set default view to New York City
                            map.setView([40.7128, -74.0060], 18);
                            
                            // Fetch road data for this location
                            fetchRoadData();
                        }, {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 5000
                        });
                    } else {
                        // Update status
                        updateStatus('Geolocation not supported in this browser');
                        
                        // Hide loading overlay
                        document.querySelector('.loading-overlay').style.display = 'none';
                        
                        // Set default view to New York City
                        map.setView([40.7128, -74.0060], 18);
                        
                        // Fetch road data for this location
                        fetchRoadData();
                    }
                }
                
                function fetchRoadData() {
                    // Only fetch if zoom level is high enough for detailed road data
                    if (map.getZoom() < 16) {
                        updateStatus('Zoom in to see detailed road data');
                        return;
                    }
                    
                    updateStatus('Loading road data...');
                    
                    // Get map bounds
                    const bounds = map.getBounds();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();
                    
                    // Use Overpass API to fetch road data (streets)
                    const overpassApiUrl = 'https://overpass-api.de/api/interpreter';
                    
                    // Query for highways (roads)
                    const query = `[out:json];
                        way[highway][highway!~"pedestrian|path|footway|cycleway|steps|service|track"]
                            (${south},${west},${north},${east});
                        out body geom;`;
                    
                    // Clear existing overlay data
                    streetsOverlay.clearLayers();
                    curbsLeftOverlay.clearLayers();
                    curbsRightOverlay.clearLayers();
                    
                    // Clear road data
                    roadData.streets = [];
                    roadData.curbs = [];
                    
                    // Fetch data using CORS proxy
                    fetch(overpassApiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        },
                        body: 'data=' + encodeURIComponent(query)
                    })
                    .then(response => response.json())
                    .then(data => {
                        processRoadData(data);
                    })
                    .catch(error => {
                        console.error('Error fetching road data:', error);
                        updateStatus('Error loading road data. Using fallback data.');
                        
                        // Use fallback road data centered on current map view
                        createFallbackRoadData();
                    });
                }
                
                function processRoadData(data) {
                    // Process roads from Overpass API response
                    if (data && data.elements) {
                        data.elements.forEach(element => {
                            if (element.type === 'way' && element.geometry) {
                                // Convert geometry to LatLng array
                                const nodes = element.geometry.map(node => [node.lat, node.lon]);
                                
                                if (nodes.length > 1) {
                                    // Store street data
                                    const streetId = `street-${element.id}`;
                                    roadData.streets.push({
                                        id: streetId,
                                        nodes: nodes,
                                        osmId: element.id,
                                        tags: element.tags || {}
                                    });
                                    
                                    // Create street overlay
                                    const street = L.polyline(nodes, {
                                        color: 'rgba(0, 0, 0, 0)',
                                        weight: 12,
                                        className: 'highlight-street',
                                        id: streetId
                                    }).addTo(streetsOverlay);
                                    
                                    // Generate curbs on both sides of the street
                                    const curbsData = generateCurbsForStreet(nodes, streetId);
                                    roadData.curbs.push(...curbsData);
                                }
                            }
                        });
                        
                        updateStatus('Road data loaded. Select a tool to begin.');
                    } else {
                        updateStatus('No road data found. Using fallback data.');
                        createFallbackRoadData();
                    }
                }
                
                function generateCurbsForStreet(streetNodes, streetId) {
                    const curbsData = [];
                    
                    // Skip if not enough nodes
                    if (streetNodes.length < 2) return curbsData;
                    
                    // Generate left and right curbs
                    const leftCurbNodes = [];
                    const rightCurbNodes = [];
                    
                    // Loop through street nodes to generate parallel curb lines
                    for (let i = 0; i < streetNodes.length - 1; i++) {
                        const point1 = L.latLng(streetNodes[i]);
                        const point2 = L.latLng(streetNodes[i + 1]);
                        
                        // Calculate perpendicular vector
                        const dx = point2.lng - point1.lng;
                        const dy = point2.lat - point1.lat;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        
                        // Normalize and scale for curb offset (5 meters)
                        // We need to convert meters to degrees which varies by latitude
                        const latRadians = point1.lat * Math.PI / 180;
                        // Constants for converting meters to degrees at given latitude
                        const metersPerDegreeLat = 111132.92;
                        const metersPerDegreeLng = 111132.92 * Math.cos(latRadians);
                        
                        // Calculate offset in degrees (5 meters)
                        const curbOffsetLat = (5 / metersPerDegreeLat) * (dy / length);
                        const curbOffsetLng = (5 / metersPerDegreeLng) * (dx / length);
                        
                        // Calculate left and right curb points
                        // Left is 90 degrees counter-clockwise from the street direction
                        const leftCurbLat = point1.lat - curbOffsetLng;
                        const leftCurbLng = point1.lng + curbOffsetLat;
                        
                        // Right is 90 degrees clockwise from the street direction
                        const rightCurbLat = point1.lat + curbOffsetLng;
                        const rightCurbLng = point1.lng - curbOffsetLat;
                        
                        leftCurbNodes.push([leftCurbLat, leftCurbLng]);
                        rightCurbNodes.push([rightCurbLat, rightCurbLng]);
                        
                        // Add final points for the last street node
                        if (i === streetNodes.length - 2) {
                            const leftFinalLat = point2.lat - curbOffsetLng;
                            const leftFinalLng = point2.lng + curbOffsetLat;
                            
                            const rightFinalLat = point2.lat + curbOffsetLng;
                            const rightFinalLng = point2.lng - curbOffsetLat;
                            
                            leftCurbNodes.push([leftFinalLat, leftFinalLng]);
                            rightCurbNodes.push([rightFinalLat, rightFinalLng]);
                        }
                    }
                    
                    // Create curb overlay for left side
                    const leftCurbId = `curb-left-${streetId}`;
                    L.polyline(leftCurbNodes, {
                        color: 'rgba(0, 0, 0, 0)',
                        weight: 6,
                        className: 'highlight-curb-left',
                        id: leftCurbId
                    }).addTo(curbsLeftOverlay);
                    
                    // Create curb overlay for right side
                    const rightCurbId = `curb-right-${streetId}`;
                    L.polyline(rightCurbNodes, {
                        color: 'rgba(0, 0, 0, 0)',
                        weight: 6,
                        className: 'highlight-curb-right',
                        id: rightCurbId
                    }).addTo(curbsRightOverlay);
                    
                    // Store curb data
                    curbsData.push({
                        id: leftCurbId,
                        nodes: leftCurbNodes,
                        streetId: streetId,
                        side: 'left'
                    });
                    
                    curbsData.push({
                        id: rightCurbId,
                        nodes: rightCurbNodes,
                        streetId: streetId,
                        side: 'right'
                    });
                    
                    return curbsData;
                }
                
                function createFallbackRoadData() {
                    // Create fallback road data when API fails or no roads found
                    // This creates a simple grid pattern around the current view
                    
                    // Clear existing data
                    streetsOverlay.clearLayers();
                    curbsLeftOverlay.clearLayers();
                    curbsRightOverlay.clearLayers();
                    roadData.streets = [];
                    roadData.curbs = [];
                    
                    const center = map.getCenter();
                    const bounds = map.getBounds();
                    const latDiff = bounds.getNorth() - bounds.getSouth();
                    const lngDiff = bounds.getEast() - bounds.getWest();
                    
                    // Create a horizontal street
                    const horizontalStreetNodes = [
                        [center.lat, center.lng - lngDiff * 0.4],
                        [center.lat, center.lng + lngDiff * 0.4]
                    ];
                    
                    const horizontalStreetId = 'street-fallback-h';
                    roadData.streets.push({
                        id: horizontalStreetId,
                        nodes: horizontalStreetNodes,
                        osmId: 'fallback-h',
                        tags: { highway: 'residential' }
                    });
                    
                    // Create horizontal street overlay
                    L.polyline(horizontalStreetNodes, {
                        color: 'rgba(0, 0, 0, 0)',
                        weight: 12,
                        className: 'highlight-street',
                        id: horizontalStreetId
                    }).addTo(streetsOverlay);
                    
                    // Create a vertical street
                    const verticalStreetNodes = [
                        [center.lat - latDiff * 0.4, center.lng],
                        [center.lat + latDiff * 0.4, center.lng]
                    ];
                    
                    const verticalStreetId = 'street-fallback-v';
                    roadData.streets.push({
                        id: verticalStreetId,
                        nodes: verticalStreetNodes,
                        osmId: 'fallback-v',
                        tags: { highway: 'residential' }
                    });
                    
                    // Create vertical street overlay
                    L.polyline(verticalStreetNodes, {
                        color: 'rgba(0, 0, 0, 0)',
                        weight: 12,
                        className: 'highlight-street',
                        id: verticalStreetId
                    }).addTo(streetsOverlay);
                    
                    // Generate curbs for both streets
                    const horizontalCurbs = generateCurbsForStreet(horizontalStreetNodes, horizontalStreetId);
                    const verticalCurbs = generateCurbsForStreet(verticalStreetNodes, verticalStreetId);
                    
                    roadData.curbs.push(...horizontalCurbs, ...verticalCurbs);
                    
                    updateStatus('Using fallback road network. Select a tool to begin.');
                }
                
                function isPointNearStreet(point, tolerance = 6) {
                    // Convert Leaflet latLng to an array
                    const testPoint = [point.lat, point.lng];
                    
                    // Check each street
                    for (const street of roadData.streets) {
                        const nodes = street.nodes;
                        
                        // Check each segment of the street
                        for (let i = 0; i < nodes.length - 1; i++) {
                            const pointA = L.latLng(nodes[i]);
                            const pointB = L.latLng(nodes[i + 1]);
                            
                            // Calculate distance from point to line segment
                            const distance = distanceToLineSegment(pointA, pointB, point);
                            
                            if (distance <= tolerance) {
                                return {
                                    isNear: true,
                                    street: street,
                                    segmentStart: i,
                                    segmentEnd: i + 1
                                };
                            }
                        }
                    }
                    
                    return { isNear: false };
                }
                
                function isPointNearCurb(point, tolerance = 6) {
                    // Convert Leaflet latLng to an array
                    const testPoint = [point.lat, point.lng];
                    
                    // Check each curb
                    for (const curb of roadData.curbs) {
                        const nodes = curb.nodes;
                        
                        // Check each segment of the curb
                        for (let i = 0; i < nodes.length - 1; i++) {
                            const pointA = L.latLng(nodes[i]);
                            const pointB = L.latLng(nodes[i + 1]);
                            
                            // Calculate distance from point to line segment
                            const distance = distanceToLineSegment(pointA, pointB, point);
                            
                            if (distance <= tolerance) {
                                return {
                                    isNear: true,
                                    curb: curb,
                                    segmentStart: i,
                                    segmentEnd: i + 1
                                };
                            }
                        }
                    }
                    
                    return { isNear: false };
                }
                
                function distanceToLineSegment(lineStart, lineEnd, point) {
                    // Calculate distance from point to line segment in meters
                    const x = point.lng;
                    const y = point.lat;
                    const x1 = lineStart.lng;
                    const y1 = lineStart.lat;
                    const x2 = lineEnd.lng;
                    const y2 = lineEnd.lat;
                    
                    // Line segment length squared
                    const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                    
                    // If line segment is just a point
                    if (l2 === 0) return distance(point, lineStart);
                    
                    // Consider the line extending the segment, parameterized as lineStart + t (lineEnd - lineStart)
                    // Project the point onto that line
                    const t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;
                    
                    if (t < 0) {
                        // Beyond the lineStart end of the segment
                        return distance(point, lineStart);
                    } else if (t > 1) {
                        // Beyond the lineEnd end of the segment
                        return distance(point, lineEnd);
                    } else {
                        // Projection falls on the segment
                        const projectionX = x1 + t * (x2 - x1);
                        const projectionY = y1 + t * (y2 - y1);
                        return distance(point, L.latLng(projectionY, projectionX));
                    }
                }
                
                function distance(point1, point2) {
                    // Calculate distance between two points in meters
                    return map.distance(point1, point2);
                }
                
                function snapToStreet(point) {
                    // Find the nearest street and snap the point to it
                    const result = isPointNearStreet(point);
                    
                    if (result.isNear) {
                        const street = result.street;
                        const segmentStart = result.segmentStart;
                        const segmentEnd = result.segmentEnd;
                        
                        const pointA = L.latLng(street.nodes[segmentStart]);
                        const pointB = L.latLng(street.nodes[segmentEnd]);
                        
                        // Project point onto line segment
                        return projectPointOnLine(point, pointA, pointB);
                    }
                    
                    return point; // Return original point if no street is nearby
                }
                
                function snapToCurb(point) {
                    // Find the nearest curb and snap the point to it
                    const result = isPointNearCurb(point);
                    
                    if (result.isNear) {
                        const curb = result.curb;
                        const segmentStart = result.segmentStart;
                        const segmentEnd = result.segmentEnd;
                        
                        const pointA = L.latLng(curb.nodes[segmentStart]);
                        const pointB = L.latLng(curb.nodes[segmentEnd]);
                        
                        // Project point onto line segment
                        return projectPointOnLine(point, pointA, pointB);
                    }
                    
                    return point; // Return original point if no curb is nearby
                }
                
                function projectPointOnLine(point, lineStart, lineEnd) {
                    // Project point onto line segment and return the projected point
                    const x = point.lng;
                    const y = point.lat;
                    const x1 = lineStart.lng;
                    const y1 = lineStart.lat;
                    const x2 = lineEnd.lng;
                    const y2 = lineEnd.lat;
                    
                    // Line segment length squared
                    const l2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
                    
                    // If line segment is just a point
                    if (l2 === 0) return lineStart;
                    
                    // Consider the line extending the segment, parameterized as lineStart + t (lineEnd - lineStart)
                    // Project the point onto that line
                    const t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;
                    
                    if (t < 0) {
                        // Beyond the lineStart end of the segment
                        return lineStart;
                    } else if (t > 1) {
                        // Beyond the lineEnd end of the segment
                        return lineEnd;
                    } else {
                        // Projection falls on the segment
                        const projectionX = x1 + t * (x2 - x1);
                        const projectionY = y1 + t * (y2 - y1);
                        return L.latLng(projectionY, projectionX);
                    }
                }
                
                function handleMapClick(e) {
                    // Hide context menu if open
                    hideContextMenu();
                    
                    // Handle click based on active drawing mode
                    if (activeDrawingMode === 'street-tool') {
                        // Check if click is near a street
                        const streetResult = isPointNearStreet(e.latlng);
                        
                        if (!streetResult.isNear) {
                            showNotification('Can only draw street pitches on streets');
                            return;
                        }
                        
                        // Snap point to the street
                        const snappedPoint = snapToStreet(e.latlng);
                        
                        // Handle street line drawing
                        handleLineDrawing(snappedPoint, 'street');
                        
                    } else if (activeDrawingMode === 'curb-tool') {
                        // Check if click is near a curb
                        const curbResult = isPointNearCurb(e.latlng);
                        
                        if (!curbResult.isNear) {
                            showNotification('Can only draw curb pitches on curbs');
                            return;
                        }
                        
                        // Snap point to the curb
                        const snappedPoint = snapToCurb(e.latlng);
                        
                        // Handle curb line drawing
                        handleLineDrawing(snappedPoint, 'curb');
                        
                    } else if (activeDrawingMode === 'high-point-tool') {
                        addHighPoint(e.latlng);
                    } else if (activeDrawingMode === 'catch-basin-tool') {
                        addCatchBasin(e.latlng);
                    }
                }
                
                function handleLineDrawing(point, type) {
                    if (!isDrawing) {
                        // Start new line
                        isDrawing = true;
                        drawingPoints = [point];
                        currentDrawingType = type;
                        
                        // Create temporary line
                        tempLine = L.polyline([point, point], {
                            color: type === 'street' ? '#0075ff' : '#ffcc00',
                            weight: 5,
                            opacity: 0.7,
                            dashArray: '5,5'
                        }).addTo(map);
                        
                        updateStatus('Click to add points, double-click to complete the line');
                    } else if (isDrawing && (
                        (currentDrawingType === 'street' && type === 'street') || 
                        (currentDrawingType === 'curb' && type === 'curb')
                    )) {
                        // Add point to existing line
                        drawingPoints.push(point);
                        
                        // Update temporary line
                        tempLine.setLatLngs(drawingPoints);
                        
                        // Check if double-clicked (points are very close together)
                        if (drawingPoints.length > 1 && 
                            distance(drawingPoints[drawingPoints.length - 1], 
                                     drawingPoints[drawingPoints.length - 2]) < 2) {
                            // Remove the duplicate point
                            drawingPoints.pop();
                            completeLine();
                        }
                    }
                }
                
                function handleMouseMove(e) {
                    // Update temporary line during drawing
                    if (isDrawing && tempLine) {
                        const lastPoint = drawingPoints[drawingPoints.length - 1];
                        
                        // Snap the mouse position based on the drawing type
                        let snappedPoint;
                        if (currentDrawingType === 'street') {
                            // Check if mouse is near a street
                            const streetResult = isPointNearStreet(e.latlng);
                            if (streetResult.isNear) {
                                snappedPoint = snapToStreet(e.latlng);
                            } else {
                                snappedPoint = lastPoint;
                            }
                        } else if (currentDrawingType === 'curb') {
                            // Check if mouse is near a curb
                            const curbResult = isPointNearCurb(e.latlng);
                            if (curbResult.isNear) {
                                snappedPoint = snapToCurb(e.latlng);
                            } else {
                                snappedPoint = lastPoint;
                            }
                        } else {
                            snappedPoint = e.latlng;
                        }
                        
                        const points = [...drawingPoints];
                        if (points.length > 0) {
                            points.push(snappedPoint);
                            tempLine.setLatLngs(points);
                        }
                    }
                }
                
                function completeLine() {
                    // Remove temporary drawing line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Reset drawing state
                    isDrawing = false;
                    
                    // Need at least 2 points for a valid line
                    if (drawingPoints.length < 2) {
                        drawingPoints = [];
                        return;
                    }
                    
                    // Show pitch input modal
                    showPitchModal();
                }
                
                function finalizeLineWithPitch(percent) {
                    // Create final polyline
                    const lineType = currentDrawingType === 'street' ? 'street' : 'curb';
                    const line = L.polyline(drawingPoints, {
                        color: lineType === 'street' ? '#0075ff' : '#ffcc00',
                        weight: 5,
                        opacity: 1,
                        className: `${lineType}-line`,
                        pitchPercent: percent,
                        lineType: lineType
                    });
                    
                    // Save to appropriate layer
                    if (lineType === 'street') {
                        line.addTo(streetPitchesLayer);
                    } else {
                        line.addTo(curbPitchesLayer);
                    }
                    
                    // Add direction arrow
                    addDirectionArrow(line);
                    
                    // Add pitch label
                    addPitchLabel(line);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'line',
                        lineType: lineType,
                        layer: lineType === 'street' ? streetPitchesLayer : curbPitchesLayer,
                        element: line
                    });
                    
                    // Reset drawing points
                    drawingPoints = [];
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update status
                    updateStatus(`${lineType.charAt(0).toUpperCase() + lineType.slice(1)} pitch added at ${percent}%`);
                }
                
                function addDirectionArrow(line) {
                    // Get line midpoint
                    const latlngs = line.getLatLngs();
                    const midIndex = Math.floor(latlngs.length / 2);
                    const point1 = latlngs[midIndex - 1];
                    const point2 = latlngs[midIndex];
                    
                    // Calculate angle
                    const p1 = map.latLngToLayerPoint(point1);
                    const p2 = map.latLngToLayerPoint(point2);
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Create SVG arrow icon
                    const arrowSvg = `
                        <div class="pitch-arrow">
                            <svg viewBox="0 0 24 24" class="${line.options.lineType}-arrow">
                                <path d="M12,2L4,12h5v8h6v-8h5L12,2z" style="transform: rotate(${angle}deg); transform-origin: center;"/>
                            </svg>
                        </div>
                    `;
                    
                    const arrowIcon = L.divIcon({
                        html: arrowSvg,
                        className: '',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    // Create marker and associate with line
                    const arrowMarker = L.marker(point2, {
                        icon: arrowIcon,
                        interactive: false
                    });
                    
                    // Add to appropriate layer
                    if (line.options.lineType === 'street') {
                        arrowMarker.addTo(streetPitchesLayer);
                    } else {
                        arrowMarker.addTo(curbPitchesLayer);
                    }
                    
                    // Store reference
                    line.arrowMarker = arrowMarker;
                }
                
                function addPitchLabel(line) {
                    // Get first point of line
                    const latlngs = line.getLatLngs();
                    const point = latlngs[0];
                    
                    // Create label icon
                    const labelHtml = `
                        <div class="pitch-label" style="border-left: 4px solid ${line.options.lineType === 'street' ? '#0075ff' : '#ffcc00'};">
                            ${line.options.pitchPercent}%
                        </div>
                    `;
                    
                    const labelIcon = L.divIcon({
                        html: labelHtml,
                        className: '',
                        iconSize: [40, 24],
                        iconAnchor: [0, 12]
                    });
                    
                    // Create marker and associate with line
                    const labelMarker = L.marker(point, {
                        icon: labelIcon,
                        interactive: false
                    });
                    
                    // Add to appropriate layer
                    if (line.options.lineType === 'street') {
                        labelMarker.addTo(streetPitchesLayer);
                    } else {
                        labelMarker.addTo(curbPitchesLayer);
                    }
                    
                    // Store reference
                    line.labelMarker = labelMarker;
                }
                
                function addHighPoint(latlng) {
                    // Create high point icon
                    const highPointIcon = L.divIcon({
                        html: '<div class="high-point-icon"><i class="fas fa-chevron-up"></i></div>',
                        className: '',
                        iconSize: [36, 36],
                        iconAnchor: [18, 18]
                    });
                    
                    // Create marker
                    const marker = L.marker(latlng, {
                        icon: highPointIcon,
                        draggable: true
                    }).addTo(highPointsLayer);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'marker',
                        markerType: 'highPoint',
                        layer: highPointsLayer,
                        element: marker
                    });
                    
                    // Setup context menu for marker
                    marker.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, marker, 'highPoint');
                    });
                    
                    // Handle long press for mobile
                    let pressTimer;
                    marker.on('mousedown', function(e) {
                        pressTimer = setTimeout(function() {
                            L.DomEvent.stopPropagation(e);
                            showContextMenu(e, marker, 'highPoint');
                        }, 500);
                    });
                    
                    marker.on('mouseup', function() {
                        clearTimeout(pressTimer);
                    });
                    
                    // Update status
                    updateStatus('High point added');
                    
                    // Check for trapped water after adding high point
                    detectTrappedWater();
                }
                
                function addCatchBasin(latlng) {
                    // Create catch basin icon
                    const catchBasinIcon = L.divIcon({
                        html: '<div class="catch-basin-icon"><i class="fas fa-drain"></i></div>',
                        className: '',
                        iconSize: [36, 36],
                        iconAnchor: [18, 18]
                    });
                    
                    // Create marker
                    const marker = L.marker(latlng, {
                        icon: catchBasinIcon,
                        draggable: true
                    }).addTo(catchBasinsLayer);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'marker',
                        markerType: 'catchBasin',
                        layer: catchBasinsLayer,
                        element: marker
                    });
                    
                    // Setup context menu for marker
                    marker.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, marker, 'catchBasin');
                    });
                    
                    // Handle long press for mobile
                    let pressTimer;
                    marker.on('mousedown', function(e) {
                        pressTimer = setTimeout(function() {
                            L.DomEvent.stopPropagation(e);
                            showContextMenu(e, marker, 'catchBasin');
                        }, 500);
                    });
                    
                    marker.on('mouseup', function() {
                        clearTimeout(pressTimer);
                    });
                    
                    // Update status
                    updateStatus('Catch basin added');
                    
                    // Check for trapped water after adding catch basin
                    detectTrappedWater();
                }
                
                function handleContextMenu(e) {
                    // Get clicked element if any
                    let clickedElement = null;
                    let elementType = null;
                    
                    // Check all layers for clicked elements
                    streetPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                            if (isPointOnLine(e.latlng, layer.getLatLngs())) {
                                clickedElement = layer;
                                elementType = 'street';
                            }
                        }
                    });
                    
                    if (!clickedElement) {
                        curbPitchesLayer.eachLayer(function(layer) {
                            if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                                if (isPointOnLine(e.latlng, layer.getLatLngs())) {
                                    clickedElement = layer;
                                    elementType = 'curb';
                                }
                            }
                        });
                    }
                    
                    // If no element was clicked, return
                    if (!clickedElement) return;
                    
                    // Show context menu
                    showContextMenu(e, clickedElement, elementType);
                }
                
                function isPointOnLine(point, linePoints, tolerance = 10) {
                    // Check if point is on line within tolerance
                    for (let i = 0; i < linePoints.length - 1; i++) {
                        const pointA = linePoints[i];
                        const pointB = linePoints[i + 1];
                        
                        const dist = distanceToLineSegment(pointA, pointB, point);
                        if (dist <= tolerance) {
                            return true;
                        }
                    }
                    return false;
                }
                
                function showContextMenu(e, element, elementType) {
                    // Set selected element
                    selectedElement = {
                        element: element,
                        type: elementType
                    };
                    
                    // Position the context menu
                    const contextMenu = document.getElementById('context-menu');
                    const containerPoint = map.latLngToContainerPoint(e.latlng);
                    
                    contextMenu.style.left = `${containerPoint.x}px`;
                    contextMenu.style.top = `${containerPoint.y}px`;
                    contextMenu.style.display = 'block';
                    
                    // Adjust visibility of context menu items based on element type
                    const reverseItem = document.getElementById('reverse-direction');
                    if (elementType === 'street' || elementType === 'curb') {
                        reverseItem.style.display = 'flex';
                    } else {
                        reverseItem.style.display = 'none';
                    }
                }
                
                function hideContextMenu() {
                    document.getElementById('context-menu').style.display = 'none';
                    selectedElement = null;
                }
                
                function reversePitchDirection() {
                    if (!selectedElement || (selectedElement.type !== 'street' && selectedElement.type !== 'curb')) {
                        return;
                    }
                    
                    // Get the line
                    const line = selectedElement.element;
                    
                    // Reverse points
                    const latlngs = line.getLatLngs();
                    line.setLatLngs(latlngs.reverse());
                    
                    // Remove old markers
                    if (line.arrowMarker) {
                        if (selectedElement.type === 'street') {
                            streetPitchesLayer.removeLayer(line.arrowMarker);
                        } else {
                            curbPitchesLayer.removeLayer(line.arrowMarker);
                        }
                    }
                    
                    if (line.labelMarker) {
                        if (selectedElement.type === 'street') {
                            streetPitchesLayer.removeLayer(line.labelMarker);
                        } else {
                            curbPitchesLayer.removeLayer(line.labelMarker);
                        }
                    }
                    
                    // Add new arrow and label
                    addDirectionArrow(line);
                    addPitchLabel(line);
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update status
                    updateStatus('Pitch direction reversed');
                }
                
                function deleteElement() {
                    if (!selectedElement) return;
                    
                    // Delete based on element type
                    if (selectedElement.type === 'street') {
                        // Remove arrow and label markers
                        if (selectedElement.element.arrowMarker) {
                            streetPitchesLayer.removeLayer(selectedElement.element.arrowMarker);
                        }
                        if (selectedElement.element.labelMarker) {
                            streetPitchesLayer.removeLayer(selectedElement.element.labelMarker);
                        }
                        
                        // Remove line
                        streetPitchesLayer.removeLayer(selectedElement.element);
                        
                    } else if (selectedElement.type === 'curb') {
                        // Remove arrow and label markers
                        if (selectedElement.element.arrowMarker) {
                            curbPitchesLayer.removeLayer(selectedElement.element.arrowMarker);
                        }
                        if (selectedElement.element.labelMarker) {
                            curbPitchesLayer.removeLayer(selectedElement.element.labelMarker);
                        }
                        
                        // Remove line
                        curbPitchesLayer.removeLayer(selectedElement.element);
                        
                    } else if (selectedElement.type === 'highPoint') {
                        highPointsLayer.removeLayer(selectedElement.element);
                        
                    } else if (selectedElement.type === 'catchBasin') {
                        catchBasinsLayer.removeLayer(selectedElement.element);
                    }
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update status
                    updateStatus('Element deleted');
                }
                
                function detectTrappedWater() {
                    // Clear existing trapped water areas
                    trappedWaterLayer.clearLayers();
                    
                    // Get all pitch lines
                    const streetLines = [];
                    const curbLines = [];
                    
                    streetPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                            streetLines.push(layer);
                        }
                    });
                    
                    curbPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                            curbLines.push(layer);
                        }
                    });
                    
                    // Check street line intersections
                    checkLinesForTraps(streetLines);
                    
                    // Check curb line intersections
                    checkLinesForTraps(curbLines);
                    
                    // Check street/curb intersections
                    checkStreetCurbIntersections(streetLines, curbLines);
                }
                
                function checkLinesForTraps(lines) {
                    for (let i = 0; i < lines.length; i++) {
                        for (let j = i + 1; j < lines.length; j++) {
                            // Find intersection point
                            const intersection = findIntersection(lines[i], lines[j]);
                            
                            if (intersection) {
                                // Check flow directions
                                const flowsToIntersection1 = flowsTowardsPoint(lines[i], intersection);
                                const flowsToIntersection2 = flowsTowardsPoint(lines[j], intersection);
                                
                                // If both lines flow towards the intersection, it's a potential trap
                                if (flowsToIntersection1 && flowsToIntersection2) {
                                    // Check for catch basins near the intersection
                                    const hasCatchBasin = checkForCatchBasinNear(intersection, 30);
                                    
                                    if (!hasCatchBasin) {
                                        // Create water trap indicator
                                        addTrappedWaterIndicator(intersection);
                                    }
                                }
                            }
                        }
                    }
                }
                
                function checkStreetCurbIntersections(streetLines, curbLines) {
                    for (let i = 0; i < streetLines.length; i++) {
                        for (let j = 0; j < curbLines.length; j++) {
                            // Find intersection point
                            const intersection = findIntersection(streetLines[i], curbLines[j]);
                            
                            if (intersection) {
                                // Check flow directions
                                const flowsToIntersection1 = flowsTowardsPoint(streetLines[i], intersection);
                                const flowsToIntersection2 = flowsTowardsPoint(curbLines[j], intersection);
                                
                                // If both lines flow towards the intersection, it's a potential trap
                                if (flowsToIntersection1 && flowsToIntersection2) {
                                    // Check for catch basins near the intersection
                                    const hasCatchBasin = checkForCatchBasinNear(intersection, 30);
                                    
                                    if (!hasCatchBasin) {
                                        // Create water trap indicator
                                        addTrappedWaterIndicator(intersection);
                                    }
                                }
                            }
                        }
                    }
                }
                
                function findIntersection(line1, line2) {
                    // Get line points
                    const line1Points = line1.getLatLngs();
                    const line2Points = line2.getLatLngs();
                    
                    // Check each segment
                    for (let i = 0; i < line1Points.length - 1; i++) {
                        for (let j = 0; j < line2Points.length - 1; j++) {
                            // Convert to pixel coordinates for easier calculation
                            const a = map.latLngToLayerPoint(line1Points[i]);
                            const b = map.latLngToLayerPoint(line1Points[i + 1]);
                            const c = map.latLngToLayerPoint(line2Points[j]);
                            const d = map.latLngToLayerPoint(line2Points[j + 1]);
                            
                            // Basic line segment intersection check
                            const denominator = ((b.y - a.y) * (d.x - c.x) - (b.x - a.x) * (d.y - c.y));
                            
                            if (denominator === 0) continue; // Lines are parallel
                            
                            const ua = ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) / denominator;
                            const ub = ((d.x - c.x) * (c.y - a.y) - (d.y - c.y) * (c.x - a.x)) / denominator;
                            
                            if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
                                // Lines intersect
                                const intersectionX = a.x + ub * (b.x - a.x);
                                const intersectionY = a.y + ub * (b.y - a.y);
                                
                                // Convert back to LatLng
                                return map.layerPointToLatLng(L.point(intersectionX, intersectionY));
                            }
                        }
                    }
                    
                    return null; // No intersection
                }
                
                function flowsTowardsPoint(line, point) {
                    // Check if the last point of the line is closer to the point than the first
                    const latlngs = line.getLatLngs();
                    const first = latlngs[0];
                    const last = latlngs[latlngs.length - 1];
                    
                    const distFirst = map.distance(first, point);
                    const distLast = map.distance(last, point);
                    
                    return distLast < distFirst;
                }
                
                function checkForCatchBasinNear(point, radius) {
                    let found = false;
                    
                    catchBasinsLayer.eachLayer(function(layer) {
                        if (map.distance(layer.getLatLng(), point) <= radius) {
                            found = true;
                        }
                    });
                    
                    return found;
                }
                
                function addTrappedWaterIndicator(center) {
                    // Create a circle to represent trapped water
                    const circle = L.circle(center, {
                        radius: 5,
                        fillColor: 'red',
                        fillOpacity: 0.6,
                        color: 'red',
                        weight: 2,
                        className: 'trapped-water-area'
                    }).addTo(trappedWaterLayer);
                }
                
                function showPitchModal() {
                    document.getElementById('pitch-modal').style.display = 'flex';
                    document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    document.getElementById('pitch-modal-title').textContent = 
                        `Set ${currentDrawingType === 'street' ? 'Street' : 'Curb'} Pitch Percentage`;
                }
                
                function showNotification(message) {
                    const notification = document.getElementById('notification');
                    document.getElementById('notification-text').textContent = message;
                    notification.classList.add('visible');
                    
                    setTimeout(() => {
                        notification.classList.remove('visible');
                    }, 3000);
                }
                
                function updateStatus(message) {
                    document.getElementById('status-text').textContent = message;
                }
                
                function addToUndoStack(action) {
                    undoStack.push(action);
                    updateUndoButtonState();
                }
                
                function undoLastAction() {
                    if (undoStack.length === 0) return;
                    
                    const action = undoStack.pop();
                    
                    if (action.type === 'line') {
                        // Remove arrow and label markers
                        if (action.element.arrowMarker) {
                            action.layer.removeLayer(action.element.arrowMarker);
                        }
                        if (action.element.labelMarker) {
                            action.layer.removeLayer(action.element.labelMarker);
                        }
                        
                        // Remove line
                        action.layer.removeLayer(action.element);
                        
                    } else if (action.type === 'marker') {
                        action.layer.removeLayer(action.element);
                    }
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update button state
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('Last action undone');
                }
                
                function updateUndoButtonState() {
                    const undoButton = document.getElementById('undo-btn');
                    
                    if (undoStack.length > 0) {
                        undoButton.style.opacity = '1';
                        undoButton.disabled = false;
                    } else {
                        undoButton.style.opacity = '0.5';
                        undoButton.disabled = true;
                    }
                }
                
                function clearAll() {
                    // Clear all layers
                    streetPitchesLayer.clearLayers();
                    curbPitchesLayer.clearLayers();
                    highPointsLayer.clearLayers();
                    catchBasinsLayer.clearLayers();
                    trappedWaterLayer.clearLayers();
                    
                    // Clear undo stack
                    undoStack = [];
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('All elements cleared');
                    showNotification('All elements cleared');
                }
                
                function toggleLayerVisibility(layerName, visible) {
                    if (layerName === 'street') {
                        if (visible) {
                            if (!map.hasLayer(streetPitchesLayer)) {
                                map.addLayer(streetPitchesLayer);
                            }
                        } else {
                            if (map.hasLayer(streetPitchesLayer)) {
                                map.removeLayer(streetPitchesLayer);
                            }
                        }
                    } else if (layerName === 'curb') {
                        if (visible) {
                            if (!map.hasLayer(curbPitchesLayer)) {
                                map.addLayer(curbPitchesLayer);
                            }
                        } else {
                            if (map.hasLayer(curbPitchesLayer)) {
                                map.removeLayer(curbPitchesLayer);
                            }
                        }
                    } else if (layerName === 'highpoint') {
                        if (visible) {
                            if (!map.hasLayer(highPointsLayer)) {
                                map.addLayer(highPointsLayer);
                            }
                        } else {
                            if (map.hasLayer(highPointsLayer)) {
                                map.removeLayer(highPointsLayer);
                            }
                        }
                    } else if (layerName === 'basin') {
                        if (visible) {
                            if (!map.hasLayer(catchBasinsLayer)) {
                                map.addLayer(catchBasinsLayer);
                            }
                        } else {
                            if (map.hasLayer(catchBasinsLayer)) {
                                map.removeLayer(catchBasinsLayer);
                            }
                        }
                    } else if (layerName === 'trapped') {
                        if (visible) {
                            if (!map.hasLayer(trappedWaterLayer)) {
                                map.addLayer(trappedWaterLayer);
                            }
                        } else {
                            if (map.hasLayer(trappedWaterLayer)) {
                                map.removeLayer(trappedWaterLayer);
                            }
                        }
                    }
                }
                
                function setActiveDrawingMode(mode) {
                    // Reset drawing state
                    if (isDrawing && tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    isDrawing = false;
                    drawingPoints = [];
                    
                    // Remove active class from all tools
                    document.querySelectorAll('.tool-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Set new active mode
                    if (mode) {
                        document.getElementById(mode).classList.add('active');
                        activeDrawingMode = mode;
                        
                        // Update status based on tool
                        if (mode === 'street-tool') {
                            updateStatus('Click on a street to start drawing a pitch line');
                        } else if (mode === 'curb-tool') {
                            updateStatus('Click on a curb to start drawing a pitch line');
                        } else if (mode === 'high-point-tool') {
                            updateStatus('Click to place a high point');
                        } else if (mode === 'catch-basin-tool') {
                            updateStatus('Click to place a catch basin');
                        }
                    } else {
                        activeDrawingMode = null;
                        updateStatus('Select a tool to begin');
                    }
                }
                
                function initUIHandlers() {
                    // Tool button clicks
                    document.getElementById('street-tool').addEventListener('click', function() {
                        setActiveDrawingMode('street-tool');
                    });
                    
                    document.getElementById('curb-tool').addEventListener('click', function() {
                        setActiveDrawingMode('curb-tool');
                    });
                    
                    document.getElementById('high-point-tool').addEventListener('click', function() {
                        setActiveDrawingMode('high-point-tool');
                    });
                    
                    document.getElementById('catch-basin-tool').addEventListener('click', function() {
                        setActiveDrawingMode('catch-basin-tool');
                    });
                    
                    document.getElementById('clear-tool').addEventListener('click', function() {
                        if (confirm('Are you sure you want to clear all elements?')) {
                            clearAll();
                        }
                    });
                    
                    // Action buttons
                    document.getElementById('locate-btn').addEventListener('click', function() {
                        if (currentPosition) {
                            map.setView(currentPosition, 19);
                        } else {
                            getUserLocation();
                        }
                    });
                    
                    document.getElementById('undo-btn').addEventListener('click', undoLastAction);
                    
                    document.getElementById('layers-btn').addEventListener('click', function() {
                        document.getElementById('layer-panel').classList.toggle('visible');
                    });
                    
                    document.getElementById('help-btn').addEventListener('click', function() {
                        document.getElementById('help-modal').style.display = 'flex';
                    });
                    
                    // Layer toggle handlers
                    document.getElementById('street-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('street', this.checked);
                    });
                    
                    document.getElementById('curb-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('curb', this.checked);
                    });
                    
                    document.getElementById('highpoint-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('highpoint', this.checked);
                    });
                    
                    document.getElementById('basin-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('basin', this.checked);
                    });
                    
                    document.getElementById('trapped-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('trapped', this.checked);
                    });
                    
                    // Layer panel close
                    document.querySelector('.layer-panel-close').addEventListener('click', function() {
                        document.getElementById('layer-panel').classList.remove('visible');
                    });
                    
                    // Pitch modal handlers
                    document.getElementById('increase-pitch').addEventListener('click', function() {
                        pitchPercent = Math.min(10, pitchPercent + 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('decrease-pitch').addEventListener('click', function() { 
                        pitchPercent = Math.max(0.1, pitchPercent - 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('cancel-pitch').addEventListener('click', function() {
                        document.getElementById('pitch-modal').style.display = 'none';
                        drawingPoints = [];
                    });
                    
                    document.getElementById('confirm-pitch').addEventListener('click', function() {
                        document.getElementById('pitch-modal').style.display = 'none';
                        finalizeLineWithPitch(pitchPercent);
                    });
                    
                    // Context menu item handlers
                    document.getElementById('reverse-direction').addEventListener('click', reversePitchDirection);
                    document.getElementById('delete-item').addEventListener('click', deleteElement);
                    
                    // Help modal close
                    document.querySelector('.help-close').addEventListener('click', function() {
                        document.getElementById('help-modal').style.display = 'none';
                    });
                    
                    // Hide context menu on document click
                    document.addEventListener('click', hideContextMenu);
                    
                    // Initialize undo button state
                    updateUndoButtonState();
                }
            }
        });
    </script>
</body>
</html>
