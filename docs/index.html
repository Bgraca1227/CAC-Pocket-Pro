<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC UtilityPro - Field Utility Mapping System</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Animate.css for additional animations -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    
    <!-- ==================== CSS STYLES ==================== -->
    <style>
        /* ===== VARIABLES AND ROOT STYLES ===== */
        :root {
            /* Brand Colors */
            --primary-color: #1976d2;
            --primary-dark: #135ca0;
            --primary-light: #4791db;
            --accent-color: #ff6d00;
            --accent-dark: #c43c00;
            --accent-light: #ff9e40;
            
            /* Utility Type Colors */
            --water-color: #03a9f4;
            --gas-color: #ff9800;
            --electric-color: #ffeb3b;
            --sewer-color: #795548;
            --telecom-color: #9c27b0;
            
            /* UI Colors */
            --background-color: #f5f5f5;
            --surface-color: #ffffff;
            --error-color: #f44336;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --info-color: #2196f3;
            
            /* Text Colors */
            --text-primary: #212121;
            --text-secondary: #757575;
            --text-disabled: #9e9e9e;
            --text-light: #ffffff;
            
            /* Elevations and Effects */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
            --shadow-inner: inset 0 2px 4px rgba(0,0,0,0.1);
            
            /* Spacing and Sizing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-round: 50%;
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-medium: 0.3s ease;
            --transition-slow: 0.5s ease;
            
            /* Z-index Layers */
            --z-base: 1;
            --z-above: 10;
            --z-modal: 100;
            --z-popup: 200;
            --z-overlay: 300;
            --z-maximum: 999;
            
            /* Typography */
            --font-heading: 'Segoe UI', 'Roboto', sans-serif;
            --font-body: 'Segoe UI', 'Roboto', sans-serif;
        }

        /* ===== GLOBAL RESET AND BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            font-family: var(--font-body);
            color: var(--text-primary);
            background-color: var(--background-color);
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        /* ===== APP CONTAINER AND MAIN LAYOUT ===== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            position: relative;
            overflow: hidden;
        }

        /* Header and Main Navigation */
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-sm) var(--spacing-md);
            background-color: var(--primary-color);
            color: var(--text-light);
            box-shadow: var(--shadow-md);
            z-index: var(--z-above);
            height: 60px;
            transition: height var(--transition-medium);
        }

        .app-title {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            font-size: 1.2rem;
            font-weight: 600;
        }

        .app-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background-color: var(--text-light);
            color: var(--primary-color);
            border-radius: var(--radius-round);
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: var(--shadow-sm);
            transition: transform var(--transition-medium);
        }

        .app-logo:hover {
            transform: rotate(10deg);
        }

        .header-actions {
            display: flex;
            gap: var(--spacing-sm);
        }

        /* Main Content Area */
        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: var(--z-base);
            background-color: #f2f2f2;
        }

        /* ===== INTERACTIVE CONTROLS ===== */
        /* Buttons and Interactive Elements */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-sm) var(--spacing-md);
            border: none;
            border-radius: var(--radius-md);
            font-family: var(--font-body);
            font-size: 0.9rem;
            font-weight: 500;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-fast);
            user-select: none;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        .btn:active {
            transform: scale(0.96);
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }

        .btn:active::after {
            opacity: 0.5;
            transform: scale(20, 20) translate(-50%);
            transition: all 0.6s, opacity 0.3s;
        }

        .btn-icon {
            width: 48px;
            height: 48px;
            padding: 0;
            border-radius: var(--radius-round);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--text-light);
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .btn-accent {
            background-color: var(--accent-color);
            color: var(--text-light);
        }

        .btn-accent:hover {
            background-color: var(--accent-dark);
        }

        .btn-light {
            background-color: var(--surface-color);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        .btn-light:hover {
            background-color: #f5f5f5;
        }

        .btn-action {
            background-color: var(--surface-color);
            color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

        .btn-action:hover {
            background-color: #f5f5f5;
            box-shadow: var(--shadow-lg);
        }

        .btn-control {
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            background-color: var(--surface-color);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
            padding: 0;
            border-radius: var(--radius-round);
            opacity: 0.9;
        }

        .btn-control:hover {
            opacity: 1;
            box-shadow: var(--shadow-md);
        }

        .btn i {
            font-size: 1.2em;
        }

        .btn-group {
            display: flex;
            gap: var(--spacing-xs);
        }

        .btn-group .btn {
            border-radius: 0;
        }

        .btn-group .btn:first-child {
            border-top-left-radius: var(--radius-md);
            border-bottom-left-radius: var(--radius-md);
        }

        .btn-group .btn:last-child {
            border-top-right-radius: var(--radius-md);
            border-bottom-right-radius: var(--radius-md);
        }

        /* Floating Action Button */
        .fab {
            position: absolute;
            bottom: var(--spacing-xl);
            right: var(--spacing-xl);
            width: 56px;
            height: 56px;
            border-radius: var(--radius-round);
            background-color: var(--accent-color);
            color: var(--text-light);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
            cursor: pointer;
            transition: all var(--transition-medium);
            z-index: var(--z-above);
        }

        .fab:hover {
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        .fab:active {
            transform: scale(0.95);
        }

        .fab i {
            transition: transform var(--transition-medium);
        }

        .fab.active i {
            transform: rotate(45deg);
        }

        /* Fab Menu */
        .fab-menu {
            position: absolute;
            bottom: 70px;
            right: var(--spacing-xl);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-md);
            z-index: var(--z-above);
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all var(--transition-medium);
        }

        .fab-menu.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .fab-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transition: all var(--transition-medium);
            animation-delay: calc(var(--i) * 0.05s);
        }

        .fab-item .label {
            background-color: var(--surface-color);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius-md);
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            color: var(--text-primary);
            white-space: nowrap;
        }

        .fab-item .btn-icon {
            width: 48px;
            height: 48px;
            background-color: var(--surface-color);
            color: var(--text-primary);
            box-shadow: var(--shadow-md);
        }

        .fab-item.item-discover .btn-icon {
            background-color: var(--info-color);
            color: var(--text-light);
        }

        .fab-item.item-map .btn-icon {
            background-color: var(--success-color);
            color: var(--text-light);
        }

        /* Mode Toggle Switch */
        .mode-toggle {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--surface-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xs);
            display: flex;
            box-shadow: var(--shadow-md);
            z-index: var(--z-above);
            overflow: hidden;
        }

        .mode-option {
            padding: var(--spacing-sm) var(--spacing-md);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            position: relative;
            z-index: 1;
            transition: color var(--transition-fast);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
        }

        .mode-option.active {
            color: var(--text-light);
        }

        .mode-slider {
            position: absolute;
            top: var(--spacing-xs);
            left: var(--spacing-xs);
            height: calc(100% - var(--spacing-xs) * 2);
            background-color: var(--primary-color);
            border-radius: calc(var(--radius-lg) - var(--spacing-xs));
            transition: transform var(--transition-medium), width var(--transition-medium);
            z-index: 0;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            bottom: var(--spacing-xl);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--surface-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xs);
            display: flex;
            gap: var(--spacing-xs);
            box-shadow: var(--shadow-md);
            z-index: var(--z-above);
            transition: all var(--transition-medium);
        }

        .toolbar.expanded {
            width: 80%;
            max-width: 500px;
            overflow-x: auto;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }

        .toolbar.expanded::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Opera */
        }

        .toolbar-btn {
            width: 48px;
            height: 48px;
            border-radius: var(--radius-round);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            flex-shrink: 0;
            position: relative;
            background-color: transparent;
            border: none;
            outline: none;
            color: var(--text-secondary);
            font-size: 0.7rem;
        }

        .toolbar-btn i {
            font-size: 1.4rem;
            margin-bottom: 2px;
        }

        .toolbar-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .toolbar-btn.active {
            color: var(--primary-color);
        }

        .toolbar-btn.active::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            border-radius: var(--radius-round);
            background-color: var(--primary-color);
        }

        /* Utility Type Buttons */
        .utility-btn {
            position: relative;
            overflow: hidden;
        }

        .utility-btn.water {
            color: var(--water-color);
        }

        .utility-btn.gas {
            color: var(--gas-color);
        }

        .utility-btn.electric {
            color: var(--electric-color);
        }

        .utility-btn.sewer {
            color: var(--sewer-color);
        }

        .utility-btn.telecom {
            color: var(--telecom-color);
        }

        .utility-btn.active.water::before {
            background-color: var(--water-color);
        }

        .utility-btn.active.gas::before {
            background-color: var(--gas-color);
        }

        .utility-btn.active.electric::before {
            background-color: var(--electric-color);
        }

        .utility-btn.active.sewer::before {
            background-color: var(--sewer-color);
        }

        .utility-btn.active.telecom::before {
            background-color: var(--telecom-color);
        }

        .utility-btn.active {
            color: var(--text-light);
        }

        .utility-btn.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: var(--radius-round);
            z-index: -1;
            opacity: 0.2;
            transition: opacity var(--transition-fast);
        }

        .utility-btn.active::before {
            opacity: 1;
        }

        /* Side Controls */
        .side-controls {
            position: absolute;
            right: var(--spacing-md);
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            z-index: var(--z-above);
        }

        /* ===== MODALS AND OVERLAYS ===== */
        /* Modal Base */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: var(--z-modal);
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-container {
            width: 90%;
            max-width: 450px;
            background-color: var(--surface-color);
            border-radius: var(--radius-lg);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            transform: translateY(20px);
            transition: transform var(--transition-medium);
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .modal.active .modal-container {
            transform: translateY(0);
        }

        .modal-header {
            padding: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-round);
            cursor: pointer;
            transition: background-color var(--transition-fast);
            color: var(--text-secondary);
            font-size: 1.2rem;
        }

        .modal-close:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .modal-body {
            padding: var(--spacing-md);
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: var(--spacing-md);
            display: flex;
            justify-content: flex-end;
            gap: var(--spacing-md);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Bottom Sheet */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--surface-color);
            border-top-left-radius: var(--radius-lg);
            border-top-right-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            transform: translateY(100%);
            transition: transform var(--transition-medium);
            z-index: var(--z-modal);
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }

        .bottom-sheet.active {
            transform: translateY(0);
        }

        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            border-radius: 2px;
            background-color: var(--text-disabled);
            margin: var(--spacing-sm) auto;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background-color: var(--surface-color);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            padding: var(--spacing-xs);
            z-index: var(--z-popup);
            min-width: 180px;
            display: none;
        }

        .context-menu.active {
            display: block;
            animation: fadeIn 0.2s ease;
        }

        .context-menu-item {
            padding: var(--spacing-sm) var(--spacing-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            cursor: pointer;
            border-radius: var(--radius-sm);
            transition: background-color var(--transition-fast);
            color: var(--text-primary);
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item.delete {
            color: var(--error-color);
        }

        .context-menu-divider {
            margin: var(--spacing-xs) 0;
            height: 1px;
            background-color: rgba(0, 0, 0, 0.1);
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-popup);
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            pointer-events: none;
        }

        .toast {
            background-color: var(--surface-color);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm) var(--spacing-md);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            transform: translateY(-20px);
            opacity: 0;
            transition: all var(--transition-medium);
            max-width: 350px;
            word-break: break-word;
        }

        .toast.active {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid var(--success-color);
        }

        .toast.info {
            border-left: 4px solid var(--info-color);
        }

        .toast.warning {
            border-left: 4px solid var(--warning-color);
        }

        .toast.error {
            border-left: 4px solid var(--error-color);
        }

        .toast i {
            font-size: 1.2rem;
        }

        .toast.success i {
            color: var(--success-color);
        }

        .toast.info i {
            color: var(--info-color);
        }

        .toast.warning i {
            color: var(--warning-color);
        }

        .toast.error i {
            color: var(--error-color);
        }

        /* ===== FORM ELEMENTS ===== */
        .form-group {
            margin-bottom: var(--spacing-md);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: 500;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .form-control {
            width: 100%;
            padding: var(--spacing-sm) var(--spacing-md);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-md);
            font-family: var(--font-body);
            font-size: 1rem;
            transition: all var(--transition-fast);
            background-color: var(--surface-color);
            color: var(--text-primary);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        select.form-control {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .radio-group {
            display: flex;
            gap: var(--spacing-md);
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: var(--spacing-xs);
            cursor: pointer;
        }

        .radio-item input[type="radio"] {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            border-radius: var(--radius-round);
            outline: none;
            transition: all var(--transition-fast);
            position: relative;
        }

        .radio-item input[type="radio"]:checked {
            border-color: var(--primary-color);
        }

        .radio-item input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border-radius: var(--radius-round);
            background-color: var(--primary-color);
            transition: all var(--transition-fast);
        }

        .radio-item label {
            font-size: 0.9rem;
            user-select: none;
        }

        /* File Upload */
        .file-upload {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--spacing-md);
            border: 2px dashed rgba(0, 0, 0, 0.1);
            border-radius: var(--radius-md);
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .file-upload:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .file-upload i {
            font-size: 2rem;
            margin-bottom: var(--spacing-sm);
        }

        .file-upload input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .file-preview {
            margin-top: var(--spacing-md);
            width: 100%;
            border-radius: var(--radius-md);
            overflow: hidden;
            position: relative;
        }

        .file-preview img {
            width: 100%;
            height: auto;
            display: block;
        }

        .file-preview .remove {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border-radius: var(--radius-round);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Direction Selector */
        .direction-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--spacing-md) 0;
        }

        .direction-dial {
            width: 100px;
            height: 100px;
            border-radius: var(--radius-round);
            background-color: #f0f0f0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: var(--spacing-md);
            box-shadow: var(--shadow-inner);
        }

        .direction-arrow {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color);
            font-size: 2rem;
            transform-origin: center;
            transition: transform var(--transition-medium);
        }

        .direction-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-md);
        }

        .direction-btn {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-round);
            background-color: #f0f0f0;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            border: none;
            outline: none;
        }

        .direction-btn:hover {
            background-color: #e0e0e0;
        }

        .direction-value {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            font-size: 1rem;
        }

        /* Segmented Control */
        .segmented-control {
            display: flex;
            background-color: #f0f0f0;
            border-radius: var(--radius-md);
            padding: var(--spacing-xs);
            position: relative;
            overflow: hidden;
        }

        .segmented-option {
            flex: 1;
            padding: var(--spacing-sm) var(--spacing-md);
            text-align: center;
            font-size: 0.9rem;
            cursor: pointer;
            position: relative;
            z-index: 1;
            transition: color var(--transition-fast);
            color: var(--text-secondary);
        }

        .segmented-option.active {
            color: var(--text-light);
        }

        .segmented-slider {
            position: absolute;
            height: calc(100% - var(--spacing-xs) * 2);
            top: var(--spacing-xs);
            background-color: var(--primary-color);
            border-radius: calc(var(--radius-md) - var(--spacing-xs));
            transition: transform var(--transition-medium), width var(--transition-medium);
            z-index: 0;
        }

        /* Range Slider */
        .range-slider {
            width: 100%;
            margin: var(--spacing-sm) 0;
        }

        .range-slider input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #f0f0f0;
            outline: none;
            transition: all var(--transition-fast);
        }

        .range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: var(--radius-round);
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .range-slider input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: var(--radius-round);
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: var(--shadow-sm);
        }

        .range-slider input[type="range"]:focus {
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .range-slider .value-display {
            margin-top: var(--spacing-xs);
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* ===== MAP STYLES ===== */
        /* Map Control Overrides */
        .leaflet-touch .leaflet-bar a {
            width: 36px;
            height: 36px;
            line-height: 36px;
        }

        .leaflet-control-zoom {
            display: none; /* We'll use our own controls */
        }

        /* Utility Map Markers */
        .utility-marker {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            border-radius: var(--radius-round);
            box-shadow: var(--shadow-sm);
            border: 2px solid white;
            font-size: 1.1rem;
            position: relative;
        }

        .water-marker {
            background-color: var(--water-color);
        }

        .gas-marker {
            background-color: var(--gas-color);
        }

        .electric-marker {
            background-color: var(--electric-color);
            color: var(--text-primary);
        }

        .sewer-marker {
            background-color: var(--sewer-color);
        }

        .telecom-marker {
            background-color: var(--telecom-color);
        }

        .structure-marker {
            width: 36px;
            height: 36px;
            background-color: white;
            border: 3px solid;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
            font-size: 1rem;
            transform: rotate(45deg);
            position: relative;
        }

        .structure-marker i {
            transform: rotate(-45deg);
        }

        .structure-marker.water {
            border-color: var(--water-color);
            color: var(--water-color);
        }

        .structure-marker.gas {
            border-color: var(--gas-color);
            color: var(--gas-color);
        }

        .structure-marker.electric {
            border-color: var(--electric-color);
            color: var(--electric-color);
        }

        .structure-marker.sewer {
            border-color: var(--sewer-color);
            color: var(--sewer-color);
        }

        .structure-marker.telecom {
            border-color: var(--telecom-color);
            color: var(--telecom-color);
        }

        /* Highlighted Elements */
        .utility-line.selected {
            stroke-dasharray: 5, 5;
            animation: dash 30s linear infinite;
        }

        .utility-marker.selected {
            animation: pulse 1.5s infinite;
        }

        /* Drawing Preview */
        .drawing-preview {
            stroke-dasharray: 5, 5;
            animation: dash 30s linear infinite;
            stroke-width: 3;
            fill: none;
        }

        .snapping-point {
            fill: var(--success-color);
            stroke: white;
            stroke-width: 2;
            r: 6;
            animation: pulse 1.5s infinite;
        }

        /* Utility Info Panel */
        .utility-info-panel {
            position: absolute;
            right: var(--spacing-md);
            bottom: var(--spacing-xl);
            width: 280px;
            background-color: var(--surface-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            z-index: var(--z-above);
            overflow: hidden;
            transform: translateY(20px);
            opacity: 0;
            pointer-events: none;
            transition: all var(--transition-medium);
        }

        .utility-info-panel.active {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .utility-info-header {
            padding: var(--spacing-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .utility-info-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .utility-info-title i {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-round);
            color: white;
            font-size: 0.9rem;
        }

        .utility-info-title i.water {
            background-color: var(--water-color);
        }

        .utility-info-title i.gas {
            background-color: var(--gas-color);
        }

        .utility-info-title i.electric {
            background-color: var(--electric-color);
        }

        .utility-info-title i.sewer {
            background-color: var(--sewer-color);
        }

        .utility-info-title i.telecom {
            background-color: var(--telecom-color);
        }

        .utility-info-content {
            padding: var(--spacing-md);
        }

        .utility-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing-sm);
        }

        .utility-info-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .utility-info-value {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .utility-info-image {
            margin-top: var(--spacing-sm);
            width: 100%;
            height: 120px;
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
        }

        .utility-info-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .utility-info-actions {
            display: flex;
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }

        /* ===== ANIMATION KEYFRAMES ===== */
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* ===== UTILITY CLASSES ===== */
        .hidden {
            display: none !important;
        }

        .shadow-sm {
            box-shadow: var(--shadow-sm);
        }

        .shadow-md {
            box-shadow: var(--shadow-md);
        }

        .shadow-lg {
            box-shadow: var(--shadow-lg);
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .items-center {
            align-items: center;
        }

        .justify-center {
            justify-content: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-sm {
            gap: var(--spacing-sm);
        }

        .gap-md {
            gap: var(--spacing-md);
        }

        .mt-sm {
            margin-top: var(--spacing-sm);
        }

        .mt-md {
            margin-top: var(--spacing-md);
        }

        .mb-sm {
            margin-bottom: var(--spacing-sm);
        }

        .mb-md {
            margin-bottom: var(--spacing-md);
        }

        .text-primary {
            color: var(--text-primary);
        }

        .text-secondary {
            color: var(--text-secondary);
        }

        .text-light {
            color: var(--text-light);
        }

        .text-center {
            text-align: center;
        }

        .text-right {
            text-align: right;
        }

        .text-sm {
            font-size: 0.9rem;
        }

        .text-lg {
            font-size: 1.2rem;
        }

        .font-bold {
            font-weight: 600;
        }

        .w-full {
            width: 100%;
        }

        .rounded {
            border-radius: var(--radius-md);
        }

        .rounded-lg {
            border-radius: var(--radius-lg);
        }

        .rounded-full {
            border-radius: var(--radius-round);
        }

        .bg-primary {
            background-color: var(--primary-color);
        }

        .bg-surface {
            background-color: var(--surface-color);
        }

        .animate-fade-in {
            animation: fadeIn 0.3s ease;
        }

        .animate-slide-in {
            animation: slideIn 0.3s ease;
        }

        .animate-pulse {
            animation: pulse 1.5s infinite;
        }

        /* ===== RESPONSIVE STYLES ===== */
        @media (max-width: 768px) {
            .app-title span {
                display: none;
            }

            .toolbar {
                width: 85%;
            }

            .utility-info-panel {
                width: 85%;
                left: 50%;
                transform: translateX(-50%) translateY(20px);
            }

            .utility-info-panel.active {
                transform: translateX(-50%) translateY(0);
            }

            .modal-container {
                width: 95%;
            }

            .form-control {
                font-size: 16px; /* Prevent iOS zoom on focus */
            }

            .side-controls {
                right: var(--spacing-sm);
            }

            .fab {
                bottom: calc(var(--spacing-xl) + 60px);
                right: var(--spacing-md);
            }

            .fab-menu {
                bottom: calc(var(--spacing-xl) + 130px);
                right: var(--spacing-md);
            }
        }

        @media (max-width: 480px) {
            .toolbar-btn {
                width: 42px;
                height: 42px;
            }

            .toolbar-btn i {
                font-size: 1.2rem;
            }

            .toolbar-btn span {
                font-size: 0.65rem;
            }

            .mode-option {
                padding: var(--spacing-sm) var(--spacing-sm);
                font-size: 0.8rem;
            }

            .btn-control {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            .direction-dial {
                width: 80px;
                height: 80px;
            }

            .direction-arrow {
                width: 50px;
                height: 50px;
                font-size: 1.6rem;
            }
        }

        /* ===== iOS SAFE AREA SUPPORT ===== */
        @supports(padding: env(safe-area-inset-bottom)) {
            .app-container {
                padding-bottom: env(safe-area-inset-bottom);
            }

            .toolbar {
                bottom: calc(var(--spacing-xl) + env(safe-area-inset-bottom));
            }

            .fab {
                bottom: calc(var(--spacing-xl) + env(safe-area-inset-bottom));
            }

            .fab-menu {
                bottom: calc(70px + env(safe-area-inset-bottom));
            }

            .bottom-sheet {
                padding-bottom: env(safe-area-inset-bottom);
            }
        }
    </style>
    
    <!-- ==================== APP CONTAINER ==================== -->
    <div class="app-container">
        <!-- App Header -->
        <header class="app-header">
            <div class="app-title">
                <div class="app-logo">
                    <i class="fas fa-layer-group"></i>
                </div>
                <span>CAC UtilityPro</span>
            </div>
            <div class="header-actions">
                <button id="menu-btn" class="btn-control">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </header>
        
        <!-- Main Content Area with Map -->
        <main class="main-content">
            <div id="map"></div>
            
            <!-- Mode Toggle -->
            <div class="mode-toggle">
                <div class="mode-slider"></div>
                <div class="mode-option active" data-mode="discover">
                    <i class="fas fa-search"></i> Discover
                </div>
                <div class="mode-option" data-mode="map">
                    <i class="fas fa-draw-polygon"></i> Map
                </div>
            </div>
            
            <!-- Toolbar -->
            <div class="toolbar">
                <!-- Discover Mode Toolbar -->
                <div id="discover-toolbar" class="toolbar-group">
                    <button class="toolbar-btn utility-btn water" data-utility="water">
                        <i class="fas fa-tint"></i>
                        <span>Water</span>
                    </button>
                    <button class="toolbar-btn utility-btn gas" data-utility="gas">
                        <i class="fas fa-fire"></i>
                        <span>Gas</span>
                    </button>
                    <button class="toolbar-btn utility-btn electric" data-utility="electric">
                        <i class="fas fa-bolt"></i>
                        <span>Electric</span>
                    </button>
                    <button class="toolbar-btn utility-btn sewer" data-utility="sewer">
                        <i class="fas fa-toilet"></i>
                        <span>Sewer</span>
                    </button>
                    <button class="toolbar-btn utility-btn telecom" data-utility="telecom">
                        <i class="fas fa-phone"></i>
                        <span>Telecom</span>
                    </button>
                </div>
                
                <!-- Map Mode Toolbar -->
                <div id="map-toolbar" class="toolbar-group hidden">
                    <button class="toolbar-btn" id="draw-main-btn">
                        <i class="fas fa-route"></i>
                        <span>Main</span>
                    </button>
                    <button class="toolbar-btn" id="draw-service-btn">
                        <i class="fas fa-home"></i>
                        <span>Service</span>
                    </button>
                    <button class="toolbar-btn" id="add-structure-btn">
                        <i class="fas fa-cube"></i>
                        <span>Structure</span>
                    </button>
                    <button class="toolbar-btn" id="connect-utilities-btn">
                        <i class="fas fa-plug"></i>
                        <span>Connect</span>
                    </button>
                    <button class="toolbar-btn" id="measure-btn">
                        <i class="fas fa-ruler"></i>
                        <span>Measure</span>
                    </button>
                </div>
            </div>
            
            <!-- Side Controls -->
            <div class="side-controls">
                <button id="locate-btn" class="btn-control" title="My Location">
                    <i class="fas fa-crosshairs"></i>
                </button>
                <button id="zoom-in-btn" class="btn-control" title="Zoom In">
                    <i class="fas fa-plus"></i>
                </button>
                <button id="zoom-out-btn" class="btn-control" title="Zoom Out">
                    <i class="fas fa-minus"></i>
                </button>
                <button id="layers-btn" class="btn-control" title="Layers">
                    <i class="fas fa-layer-group"></i>
                </button>
                <button id="undo-btn" class="btn-control" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            </div>
            
            <!-- Drawing Controls - Only visible during active drawing -->
            <div class="side-controls" style="right: var(--spacing-md); bottom: var(--spacing-xl); top: auto; transform: none; display: none;" id="drawing-controls">
                <button id="cancel-drawing-btn" class="btn-control" title="Cancel">
                    <i class="fas fa-times"></i>
                </button>
                <button id="finish-drawing-btn" class="btn-control" title="Finish">
                    <i class="fas fa-check"></i>
                </button>
            </div>
            
            <!-- Utility Info Panel -->
            <div class="utility-info-panel" id="utility-info-panel">
                <div class="utility-info-header">
                    <div class="utility-info-title">
                        <i class="fas fa-tint water"></i>
                        <span>Water Line</span>
                    </div>
                    <button class="modal-close" id="utility-info-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="utility-info-content">
                    <div class="utility-info-row">
                        <div class="utility-info-label">Type</div>
                        <div class="utility-info-value" id="info-type">Service Line</div>
                    </div>
                    <div class="utility-info-row">
                        <div class="utility-info-label">Size</div>
                        <div class="utility-info-value" id="info-size">6 inches</div>
                    </div>
                    <div class="utility-info-row">
                        <div class="utility-info-label">Depth</div>
                        <div class="utility-info-value" id="info-depth">4 feet</div>
                    </div>
                    <div class="utility-info-row">
                        <div class="utility-info-label">Material</div>
                        <div class="utility-info-value" id="info-material">PVC</div>
                    </div>
                    <div class="utility-info-row">
                        <div class="utility-info-label">Condition</div>
                        <div class="utility-info-value" id="info-condition">Good</div>
                    </div>
                    <div class="utility-info-row">
                        <div class="utility-info-label">Direction</div>
                        <div class="utility-info-value" id="info-direction">North</div>
                    </div>
                    <div class="utility-info-image" id="info-image">
                        <i class="fas fa-camera"></i> No image
                    </div>
                    <div class="utility-info-actions">
                        <button class="btn btn-light w-full" id="edit-utility-btn">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-light w-full" id="delete-utility-btn">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Floating Action Button -->
            <div class="fab" id="main-fab">
                <i class="fas fa-plus"></i>
            </div>
            
            <!-- FAB Menu -->
            <div class="fab-menu" id="fab-menu">
                <div class="fab-item item-discover" style="--i: 1;">
                    <div class="label">Add Utility (Discover)</div>
                    <button class="btn-icon">
                        <i class="fas fa-search"></i>
                    </button>
                </div>
                <div class="fab-item item-map" style="--i: 2;">
                    <div class="label">Map Utility</div>
                    <button class="btn-icon">
                        <i class="fas fa-draw-polygon"></i>
                    </button>
                </div>
                <div class="fab-item" style="--i: 3;">
                    <div class="label">Add Structure</div>
                    <button class="btn-icon">
                        <i class="fas fa-cube"></i>
                    </button>
                </div>
            </div>
            
            <!-- Context Menu -->
            <div class="context-menu" id="context-menu">
                <div class="context-menu-item" id="edit-item">
                    <i class="fas fa-edit"></i>
                    <span>Edit Properties</span>
                </div>
                <div class="context-menu-item" id="edit-geometry-item">
                    <i class="fas fa-draw-polygon"></i>
                    <span>Edit Geometry</span>
                </div>
                <div class="context-menu-item" id="connect-item">
                    <i class="fas fa-plug"></i>
                    <span>Connect to...</span>
                </div>
                <div class="context-menu-divider"></div>
                <div class="context-menu-item delete" id="delete-item">
                    <i class="fas fa-trash"></i>
                    <span>Delete</span>
                </div>
            </div>
        </main>
        
        <!-- Toast Notifications Container -->
        <div class="toast-container" id="toast-container"></div>
        
        <!-- ========== MODALS ========== -->
        <!-- Utility Discovery Modal -->
        <div class="modal" id="utility-discovery-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Add Discovered Utility</div>
                    <div class="modal-close" id="discovery-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Utility Type</label>
                        <select id="utility-type" class="form-control">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="sewer">Sewer</option>
                            <option value="telecom">Telecom</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Line Type</label>
                        <div class="radio-group">
                            <div class="radio-item">
                                <input type="radio" id="line-type-main" name="line-type" value="main">
                                <label for="line-type-main">Main</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="line-type-service" name="line-type" value="service" checked>
                                <label for="line-type-service">Service</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Size (inches)</label>
                        <input type="number" id="utility-size" class="form-control" min="0.5" step="0.5" value="4">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Depth (feet)</label>
                        <input type="number" id="utility-depth" class="form-control" min="0.5" step="0.5" value="3">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Material</label>
                        <select id="utility-material" class="form-control">
                            <option value="PVC">PVC</option>
                            <option value="PE">PE (Polyethylene)</option>
                            <option value="Copper">Copper</option>
                            <option value="Steel">Steel</option>
                            <option value="Cast Iron">Cast Iron</option>
                            <option value="Concrete">Concrete</option>
                            <option value="Clay">Clay</option>
                            <option value="Other">Other</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Condition</label>
                        <select id="utility-condition" class="form-control">
                            <option value="Excellent">Excellent</option>
                            <option value="Good" selected>Good</option>
                            <option value="Fair">Fair</option>
                            <option value="Poor">Poor</option>
                            <option value="Critical">Critical</option>
                            <option value="Unknown">Unknown</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Direction</label>
                        <div class="direction-selector">
                            <div class="direction-dial">
                                <div class="direction-arrow" id="direction-arrow">
                                    <i class="fas fa-arrow-up"></i>
                                </div>
                            </div>
                            <div class="direction-controls">
                                <button class="direction-btn" id="rotate-left-btn">
                                    <i class="fas fa-undo"></i>
                                </button>
                                <div class="direction-value" id="direction-value">0</div>
                                <button class="direction-btn" id="rotate-right-btn">
                                    <i class="fas fa-redo"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Photo</label>
                        <div class="file-upload" id="photo-upload">
                            <i class="fas fa-camera"></i>
                            <div>Click or tap to add a photo</div>
                            <input type="file" accept="image/*" id="utility-photo" capture="environment">
                        </div>
                        <div class="file-preview" id="photo-preview" style="display: none;">
                            <img id="preview-image" src="" alt="Preview">
                            <div class="remove" id="remove-photo">
                                <i class="fas fa-times"></i>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Notes</label>
                        <textarea id="utility-notes" class="form-control" rows="3" placeholder="Add any additional details or observations..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-light" id="cancel-discovery-btn">Cancel</button>
                    <button class="btn btn-primary" id="save-discovery-btn">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Structure Modal -->
        <div class="modal" id="structure-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Add Structure</div>
                    <div class="modal-close" id="structure-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Structure Type</label>
                        <select id="structure-type" class="form-control">
                            <option value="valve">Valve</option>
                            <option value="meter">Meter</option>
                            <option value="hydrant">Fire Hydrant</option>
                            <option value="manhole">Manhole</option>
                            <option value="catchbasin">Catch Basin</option>
                            <option value="cleanout">Cleanout</option>
                            <option value="junction">Junction Box</option>
                            <option value="transformer">Transformer</option>
                            <option value="regulator">Regulator</option>
                            <option value="handhole">Handhole</option>
                            <option value="pole">Utility Pole</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Associated Utility</label>
                        <select id="structure-utility" class="form-control">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="sewer">Sewer</option>
                            <option value="telecom">Telecom</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Size (inches)</label>
                        <input type="number" id="structure-size" class="form-control" min="1" step="1" value="12">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Depth to Cover (inches)</label>
                        <input type="number" id="structure-depth" class="form-control" min="0" step="1" value="6">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Condition</label>
                        <select id="structure-condition" class="form-control">
                            <option value="Excellent">Excellent</option>
                            <option value="Good" selected>Good</option>
                            <option value="Fair">Fair</option>
                            <option value="Poor">Poor</option>
                            <option value="Critical">Critical</option>
                            <option value="Unknown">Unknown</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Photo</label>
                        <div class="file-upload" id="structure-photo-upload">
                            <i class="fas fa-camera"></i>
                            <div>Click or tap to add a photo</div>
                            <input type="file" accept="image/*" id="structure-photo" capture="environment">
                        </div>
                        <div class="file-preview" id="structure-photo-preview" style="display: none;">
                            <img id="structure-preview-image" src="" alt="Preview">
                            <div class="remove" id="remove-structure-photo">
                                <i class="fas fa-times"></i>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Notes</label>
                        <textarea id="structure-notes" class="form-control" rows="3" placeholder="Add any additional details or observations..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-light" id="cancel-structure-btn">Cancel</button>
                    <button class="btn btn-primary" id="save-structure-btn">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Connect Utility Modal -->
        <div class="modal" id="connect-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Connect Utilities</div>
                    <div class="modal-close" id="connect-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Connection Type</label>
                        <div class="segmented-control" id="connection-type-control">
                            <div class="segmented-slider"></div>
                            <div class="segmented-option active" data-value="tap">Tap</div>
                            <div class="segmented-option" data-value="join">Join</div>
                            <div class="segmented-option" data-value="cross">Cross</div>
                        </div>
                    </div>
                    <div class="form-group" id="connection-offset-group">
                        <label class="form-label">Connection Offset</label>
                        <div class="range-slider">
                            <input type="range" id="connection-offset" min="0" max="5" step="0.1" value="0">
                            <div class="value-display">
                                <span>0 ft</span>
                                <span>5 ft</span>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Select Connection Point</label>
                        <div class="text-center mb-sm text-secondary text-sm">
                            Tap on the map to select the connection point
                        </div>
                        <div class="connection-preview" id="connection-preview" style="height: 150px; background-color: #f0f0f0; border-radius: var(--radius-md); display: flex; align-items: center; justify-content: center; color: var(--text-secondary);">
                            <span>Connection preview will appear here</span>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-light" id="cancel-connect-btn">Cancel</button>
                    <button class="btn btn-primary" id="save-connect-btn">Connect</button>
                </div>
            </div>
        </div>
        
        <!-- Menu Modal -->
        <div class="modal" id="menu-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Menu</div>
                    <div class="modal-close" id="menu-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <button class="btn btn-light w-full mb-md" id="search-location-btn">
                        <i class="fas fa-search-location"></i> Search Location
                    </button>
                    <button class="btn btn-light w-full mb-md" id="export-btn">
                        <i class="fas fa-file-export"></i> Export Data
                    </button>
                    <button class="btn btn-light w-full mb-md" id="import-btn">
                        <i class="fas fa-file-import"></i> Import Data
                    </button>
                    <button class="btn btn-light w-full mb-md" id="clear-data-btn">
                        <i class="fas fa-trash-alt"></i> Clear All Data
                    </button>
                    <button class="btn btn-light w-full" id="help-btn">
                        <i class="fas fa-question-circle"></i> Help
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Layers Modal -->
        <div class="modal" id="layers-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Map Layers</div>
                    <div class="modal-close" id="layers-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Base Maps</label>
                        <div class="segmented-control mb-md" id="base-map-control">
                            <div class="segmented-slider"></div>
                            <div class="segmented-option active" data-value="streets">Streets</div>
                            <div class="segmented-option" data-value="satellite">Satellite</div>
                            <div class="segmented-option" data-value="hybrid">Hybrid</div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Utility Layers</label>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <div style="width: 12px; height: 12px; background-color: var(--water-color); border-radius: 2px;"></div>
                                <span>Water</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="water-layer-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <div style="width: 12px; height: 12px; background-color: var(--gas-color); border-radius: 2px;"></div>
                                <span>Gas</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="gas-layer-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <div style="width: 12px; height: 12px; background-color: var(--electric-color); border-radius: 2px;"></div>
                                <span>Electric</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="electric-layer-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <div style="width: 12px; height: 12px; background-color: var(--sewer-color); border-radius: 2px;"></div>
                                <span>Sewer</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="sewer-layer-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <div style="width: 12px; height: 12px; background-color: var(--telecom-color); border-radius: 2px;"></div>
                                <span>Telecom</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="telecom-layer-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">Display Options</label>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <i class="fas fa-route"></i>
                                <span>Show Mains</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="mains-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <i class="fas fa-home"></i>
                                <span>Show Services</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="services-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <i class="fas fa-cube"></i>
                                <span>Show Structures</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="structures-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                        
                        <div class="layer-toggle flex justify-between items-center mb-sm">
                            <div class="flex items-center gap-sm">
                                <i class="fas fa-ruler"></i>
                                <span>Show Measurements</span>
                            </div>
                            <label class="switch">
                                <input type="checkbox" id="measurements-toggle" checked>
                                <span class="slider round"></span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Location Search Modal -->
        <div class="modal" id="location-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Search Location</div>
                    <div class="modal-close" id="location-modal-close">
                        <i class="fas fa-times"></i>
                    </div>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Enter Address</label>
                        <input type="text" id="address-input" class="form-control" placeholder="123 Main St, City, State">
                    </div>
                    <div class="text-center mt-md">- OR -</div>
                    <button class="btn btn-light w-full mt-md" id="use-my-location-btn">
                        <i class="fas fa-crosshairs"></i> Use My Current Location
                    </button>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-light" id="cancel-location-btn">Cancel</button>
                    <button class="btn btn-primary" id="search-location-btn-modal">Search</button>
                </div>
            </div>
        </div>
        
        <!-- Loading Overlay -->
        <div class="modal" id="loading-modal">
            <div style="background-color: white; padding: 20px; border-radius: var(--radius-lg); display: flex; flex-direction: column; align-items: center; gap: 16px;">
                <div style="width: 48px; height: 48px; border: 4px solid var(--primary-color); border-radius: 50%; border-top-color: transparent; animation: spin 1s linear infinite;"></div>
                <div id="loading-text">Loading...</div>
            </div>
        </div>
    </div>

    <!-- ==================== SCRIPTS ==================== -->
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <!-- Main Application Script -->
    <script>
        /**
         * CAC UtilityPro - Field Utility Mapping System
         * A standalone web application for tracking and documenting underground utilities.
         */

        // ===== DATA MODELS =====
        /**
         * Utility Data Model
         * Stores all information about discovered utilities and structures
         */
        class UtilityData {
            constructor() {
                // Initialize empty collections for each utility type
                this.utilities = {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                };
                
                this.structures = [];
                this.measurements = [];
                this.nextId = 1;
            }
            
            /**
             * Generate a unique ID
             * @returns {string} Unique ID
             */
            generateId(prefix = 'util') {
                return `${prefix}-${this.nextId++}-${Date.now().toString(36)}`;
            }
            
            /**
             * Add a utility segment
             * @param {Object} utility - Utility data
             * @returns {string} Generated ID
             */
            addUtility(utility) {
                const id = utility.id || this.generateId('util');
                const utilityObj = {
                    id: id,
                    type: utility.type,
                    lineType: utility.lineType || 'service',
                    size: utility.size || 4,
                    depth: utility.depth || 3,
                    material: utility.material || 'PVC',
                    condition: utility.condition || 'Good',
                    direction: utility.direction || 0,
                    points: utility.points || [],
                    photoData: utility.photoData || null,
                    notes: utility.notes || '',
                    dateAdded: utility.dateAdded || new Date(),
                    connectedTo: utility.connectedTo || null,
                    marker: null,
                    line: null
                };
                
                // Add to appropriate collection
                if (this.utilities[utility.type]) {
                    this.utilities[utility.type].push(utilityObj);
                } else {
                    console.error(`Invalid utility type: ${utility.type}`);
                }
                
                return id;
            }
            
            /**
             * Add a structure
             * @param {Object} structure - Structure data
             * @returns {string} Generated ID
             */
            addStructure(structure) {
                const id = structure.id || this.generateId('struct');
                const structureObj = {
                    id: id,
                    type: structure.type,
                    utilityType: structure.utilityType,
                    size: structure.size || 12,
                    depth: structure.depth || 6,
                    condition: structure.condition || 'Good',
                    location: structure.location,
                    photoData: structure.photoData || null,
                    notes: structure.notes || '',
                    dateAdded: structure.dateAdded || new Date(),
                    connectedTo: structure.connectedTo || null,
                    marker: null
                };
                
                this.structures.push(structureObj);
                return id;
            }
            
            /**
             * Add a measurement
             * @param {Object} measurement - Measurement data
             * @returns {string} Generated ID
             */
            addMeasurement(measurement) {
                const id = measurement.id || this.generateId('meas');
                const measurementObj = {
                    id: id,
                    type: measurement.type || 'distance',
                    points: measurement.points || [],
                    value: measurement.value,
                    unit: measurement.unit || 'ft',
                    label: measurement.label || '',
                    dateAdded: measurement.dateAdded || new Date(),
                    line: null,
                    marker: null
                };
                
                this.measurements.push(measurementObj);
                return id;
            }
            
            /**
             * Update a utility
             * @param {string} id - Utility ID
             * @param {Object} data - Updated data
             * @returns {boolean} Success indicator
             */
            updateUtility(id, data) {
                for (const type in this.utilities) {
                    const index = this.utilities[type].findIndex(u => u.id === id);
                    if (index !== -1) {
                        // Update fields while preserving references to markers/lines
                        const utility = this.utilities[type][index];
                        Object.keys(data).forEach(key => {
                            if (key !== 'marker' && key !== 'line' && key !== 'id') {
                                utility[key] = data[key];
                            }
                        });
                        return true;
                    }
                }
                return false;
            }
            
            /**
             * Update a structure
             * @param {string} id - Structure ID
             * @param {Object} data - Updated data
             * @returns {boolean} Success indicator
             */
            updateStructure(id, data) {
                const index = this.structures.findIndex(s => s.id === id);
                if (index !== -1) {
                    // Update fields while preserving references to markers
                    const structure = this.structures[index];
                    Object.keys(data).forEach(key => {
                        if (key !== 'marker' && key !== 'id') {
                            structure[key] = data[key];
                        }
                    });
                    return true;
                }
                return false;
            }
            
            /**
             * Delete a utility by ID
             * @param {string} id - Utility ID
             * @returns {boolean} Success indicator
             */
            deleteUtility(id) {
                for (const type in this.utilities) {
                    const index = this.utilities[type].findIndex(u => u.id === id);
                    if (index !== -1) {
                        this.utilities[type].splice(index, 1);
                        return true;
                    }
                }
                return false;
            }
            
            /**
             * Delete a structure by ID
             * @param {string} id - Structure ID
             * @returns {boolean} Success indicator
             */
            deleteStructure(id) {
                const index = this.structures.findIndex(s => s.id === id);
                if (index !== -1) {
                    this.structures.splice(index, 1);
                    return true;
                }
                return false;
            }
            
            /**
             * Find a utility by ID
             * @param {string} id - Utility ID
             * @returns {Object|null} Utility object or null if not found
             */
            findUtility(id) {
                for (const type in this.utilities) {
                    const utility = this.utilities[type].find(u => u.id === id);
                    if (utility) return utility;
                }
                return null;
            }
            
            /**
             * Find a structure by ID
             * @param {string} id - Structure ID
             * @returns {Object|null} Structure object or null if not found
             */
            findStructure(id) {
                return this.structures.find(s => s.id === id) || null;
            }
            
            /**
             * Connect two utilities
             * @param {string} sourceId - Source utility ID
             * @param {string} targetId - Target utility ID
             * @param {Object} connectionData - Connection data
             * @returns {boolean} Success indicator
             */
            connectUtilities(sourceId, targetId, connectionData = {}) {
                const source = this.findUtility(sourceId);
                const target = this.findUtility(targetId);
                
                if (!source || !target) {
                    return false;
                }
                
                // Update connection data
                source.connectedTo = {
                    id: targetId,
                    type: connectionData.type || 'tap',
                    point: connectionData.point || null
                };
                
                return true;
            }
            
            /**
             * Connect a structure to a utility
             * @param {string} structureId - Structure ID
             * @param {string} utilityId - Utility ID
             * @returns {boolean} Success indicator
             */
            connectStructureToUtility(structureId, utilityId) {
                const structure = this.findStructure(structureId);
                const utility = this.findUtility(utilityId);
                
                if (!structure || !utility) {
                    return false;
                }
                
                structure.connectedTo = utilityId;
                return true;
            }
            
            /**
             * Export all data to JSON
             * @returns {Object} All utility data
             */
            exportData() {
                // Create a deep copy without circular references
                const exportData = {
                    utilities: {},
                    structures: [],
                    measurements: [],
                    metadata: {
                        version: '1.0',
                        exportDate: new Date().toISOString(),
                        nextId: this.nextId
                    }
                };
                
                // Export utilities without map objects
                for (const type in this.utilities) {
                    exportData.utilities[type] = this.utilities[type].map(utility => {
                        const utilityCopy = { ...utility };
                        delete utilityCopy.marker;
                        delete utilityCopy.line;
                        return utilityCopy;
                    });
                }
                
                // Export structures without map objects
                exportData.structures = this.structures.map(structure => {
                    const structureCopy = { ...structure };
                    delete structureCopy.marker;
                    return structureCopy;
                });
                
                // Export measurements without map objects
                exportData.measurements = this.measurements.map(measurement => {
                    const measurementCopy = { ...measurement };
                    delete measurementCopy.marker;
                    delete measurementCopy.line;
                    return measurementCopy;
                });
                
                return exportData;
            }
            
            /**
             * Import data from JSON
             * @param {Object} data - Data to import
             * @returns {boolean} Success indicator
             */
            importData(data) {
                if (!data || !data.metadata || !data.utilities) {
                    return false;
                }
                
                // Reset current data
                this.utilities = {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                };
                this.structures = [];
                this.measurements = [];
                
                // Import utilities
                for (const type in data.utilities) {
                    if (this.utilities[type]) {
                        this.utilities[type] = data.utilities[type];
                    }
                }
                
                // Import structures
                if (data.structures) {
                    this.structures = data.structures;
                }
                
                // Import measurements
                if (data.measurements) {
                    this.measurements = data.measurements;
                }
                
                // Update nextId
                if (data.metadata.nextId) {
                    this.nextId = data.metadata.nextId;
                }
                
                return true;
            }
            
            /**
             * Clear all data
             */
            clearAll() {
                this.utilities = {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                };
                this.structures = [];
                this.measurements = [];
                this.nextId = 1;
            }
            
            /**
             * Find utilities near a point
             * @param {L.LatLng} point - Point to search near
             * @param {number} radius - Search radius in meters
             * @returns {Array} Array of nearby utilities
             */
            findNearbyUtilities(point, radius = 10) {
                const nearby = [];
                
                for (const type in this.utilities) {
                    for (const utility of this.utilities[type]) {
                        // For line utilities, check each segment
                        if (utility.points && utility.points.length > 1) {
                            for (let i = 0; i < utility.points.length - 1; i++) {
                                const p1 = utility.points[i];
                                const p2 = utility.points[i + 1];
                                
                                // Calculate distance from point to line segment
                                const distance = this.pointToSegmentDistance(point, p1, p2);
                                
                                if (distance <= radius) {
                                    nearby.push({
                                        utility: utility,
                                        distance: distance,
                                        segment: [i, i + 1]
                                    });
                                    break; // Only add each utility once
                                }
                            }
                        }
                    }
                }
                
                // Sort by distance
                nearby.sort((a, b) => a.distance - b.distance);
                
                return nearby;
            }
            
            /**
             * Find structures near a point
             * @param {L.LatLng} point - Point to search near
             * @param {number} radius - Search radius in meters
             * @returns {Array} Array of nearby structures
             */
            findNearbyStructures(point, radius = 10) {
                const nearby = [];
                
                for (const structure of this.structures) {
                    if (structure.location) {
                        const distance = this.calculateDistance(point, structure.location);
                        
                        if (distance <= radius) {
                            nearby.push({
                                structure: structure,
                                distance: distance
                            });
                        }
                    }
                }
                
                // Sort by distance
                nearby.sort((a, b) => a.distance - b.distance);
                
                return nearby;
            }
            
            /**
             * Calculate distance between two points in meters
             * @param {L.LatLng} p1 - First point
             * @param {L.LatLng} p2 - Second point
             * @returns {number} Distance in meters
             */
            calculateDistance(p1, p2) {
                // Use Leaflet's built-in distance calculation
                return p1.distanceTo(p2);
            }
            
            /**
             * Calculate distance from a point to a line segment
             * @param {L.LatLng} p - Point
             * @param {L.LatLng} v - First segment endpoint
             * @param {L.LatLng} w - Second segment endpoint
             * @returns {number} Distance in meters
             */
            pointToSegmentDistance(p, v, w) {
                // Implementation of point-to-segment distance calculation
                const vw = {
                    lat: w.lat - v.lat,
                    lng: w.lng - v.lng
                };
                
                const vp = {
                    lat: p.lat - v.lat,
                    lng: p.lng - v.lng
                };
                
                // Calculate squared length of segment
                const lenSq = vw.lat * vw.lat + vw.lng * vw.lng;
                
                // If segment is a point, just calculate distance to the point
                if (lenSq === 0) return this.calculateDistance(p, v);
                
                // Calculate projection scalar
                let t = (vp.lat * vw.lat + vp.lng * vw.lng) / lenSq;
                
                // Clamp t to segment bounds
                t = Math.max(0, Math.min(1, t));
                
                // Calculate closest point on segment
                const closest = {
                    lat: v.lat + t * vw.lat,
                    lng: v.lng + t * vw.lng
                };
                
                // Convert to Leaflet LatLng and calculate distance
                return this.calculateDistance(p, L.latLng(closest.lat, closest.lng));
            }
        }

        /**
         * UndoManager
         * Manages undo/redo functionality for the application
         */
        class UndoManager {
            constructor(maxActions = 20) {
                this.actions = [];
                this.position = -1;
                this.maxActions = maxActions;
            }
            
            /**
             * Add an action to the undo stack
             * @param {Object} action - Action data
             */
            addAction(action) {
                // If we're not at the end of the stack, remove any actions after current position
                if (this.position < this.actions.length - 1) {
                    this.actions = this.actions.slice(0, this.position + 1);
                }
                
                // Add the new action
                this.actions.push(action);
                
                // Move to the end of the stack
                this.position = this.actions.length - 1;
                
                // If we've exceeded our max actions, remove the oldest one
                if (this.actions.length > this.maxActions) {
                    this.actions.shift();
                    this.position--;
                }
                
                // Update UI state
                this.updateState();
            }
            
            /**
             * Undo the last action
             * @returns {Object|null} Undone action or null if no actions
             */
            undo() {
                if (this.position < 0) {
                    return null;
                }
                
                const action = this.actions[this.position];
                this.position--;
                
                // Update UI state
                this.updateState();
                
                return action;
            }
            
            /**
             * Redo the previously undone action
             * @returns {Object|null} Redone action or null if no actions
             */
            redo() {
                if (this.position >= this.actions.length - 1) {
                    return null;
                }
                
                this.position++;
                const action = this.actions[this.position];
                
                // Update UI state
                this.updateState();
                
                return action;
            }
            
            /**
             * Clear all actions
             */
            clear() {
                this.actions = [];
                this.position = -1;
                this.updateState();
            }
            
            /**
             * Update UI state based on undo stack
             */
            updateState() {
                // Update undo button state
                const undoButton = document.getElementById('undo-btn');
                if (undoButton) {
                    if (this.position >= 0) {
                        undoButton.removeAttribute('disabled');
                        undoButton.style.opacity = '1';
                    } else {
                        undoButton.setAttribute('disabled', 'disabled');
                        undoButton.style.opacity = '0.5';
                    }
                }
            }
            
            /**
             * Check if undo is available
             * @returns {boolean} True if undo is available
             */
            canUndo() {
                return this.position >= 0;
            }
            
            /**
             * Check if redo is available
             * @returns {boolean} True if redo is available
             */
            canRedo() {
                return this.position < this.actions.length - 1;
            }
        }

        /**
         * StorageManager
         * Handles data persistence using localStorage
         */
        class StorageManager {
            constructor(storageKey = 'cac-utility-data') {
                this.storageKey = storageKey;
            }
            
            /**
             * Save data to local storage
             * @param {Object} data - Data to save
             * @returns {boolean} Success indicator
             */
            saveData(data) {
                try {
                    const jsonData = JSON.stringify(data);
                    localStorage.setItem(this.storageKey, jsonData);
                    return true;
                } catch (error) {
                    console.error('Error saving data:', error);
                    return false;
                }
            }
            
            /**
             * Load data from local storage
             * @returns {Object|null} Loaded data or null if not found
             */
            loadData() {
                try {
                    const jsonData = localStorage.getItem(this.storageKey);
                    if (!jsonData) return null;
                    
                    return JSON.parse(jsonData);
                } catch (error) {
                    console.error('Error loading data:', error);
                    return null;
                }
            }
            
            /**
             * Clear data from local storage
             * @returns {boolean} Success indicator
             */
            clearData() {
                try {
                    localStorage.removeItem(this.storageKey);
                    return true;
                } catch (error) {
                    console.error('Error clearing data:', error);
                    return false;
                }
            }
        }

        /**
         * Main Application
         * Manages the overall application state and functionality
         */
        class UtilityTrackerApp {
            constructor() {
                // Initialize components
                this.map = null;
                this.data = new UtilityData();
                this.undoManager = new UndoManager();
                this.storageManager = new StorageManager();
                
                // Application state
                this.activeMode = 'discover';
                this.selectedUtilityType = 'water';
                this.isDrawing = false;
                this.drawingPoints = [];
                this.tempLine = null;
                this.selectedElement = null;
                this.baseMapType = 'streets';
                
                // Drawing state
                this.currentDrawingType = null;     // 'main', 'service', 'structure', 'measurement'
                this.snappingEnabled = true;        // Whether snapping is enabled
                this.snappingRadius = 10;           // Radius in meters for snapping
                this.nearestSnapPoint = null;       // Nearest point for snapping
                
                // Leaflet layers
                this.utilityLayers = {};            // Layers for each utility type
                this.baseMaps = {};                 // Base map layers
                this.measurementLayer = null;       // Layer for measurements
                this.tempLayer = null;              // Layer for temporary drawing
                this.markerLayer = null;            // Layer for markers
                
                // User location
                this.userLocation = null;           // Current user location
                this.userMarker = null;             // User location marker
                this.locationWatchId = null;        // ID for geolocation watch
                
                // Load saved data
                this.loadSavedData();
                
                // Initialize map and UI
                this.initMap();
                this.initEventListeners();
                
                // Show welcome message
                this.showToast('Welcome to CAC UtilityPro', 'info');
            }
            
            /**
             * Initialize the map
             */
            initMap() {
                // Create the map
                this.map = L.map('map', {
                    zoomControl: false,
                    attributionControl: true,
                    maxZoom: 22
                }).setView([40.7128, -74.0060], 16);
                
                // Create base map layers
                this.baseMaps = {
                    streets: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 22,
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    }),
                    satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        maxZoom: 22,
                        attribution: 'Imagery &copy; Esri &copy; i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                    }),
                    hybrid: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        maxZoom: 22,
                        attribution: 'Imagery &copy; Esri &copy; i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                    })
                };
                
                // Add default base map
                this.baseMaps.streets.addTo(this.map);
                
                // Create utility layers
                this.utilityLayers = {
                    water: L.layerGroup().addTo(this.map),
                    gas: L.layerGroup().addTo(this.map),
                    electric: L.layerGroup().addTo(this.map),
                    sewer: L.layerGroup().addTo(this.map),
                    telecom: L.layerGroup().addTo(this.map)
                };
                
                // Create measurement layer
                this.measurementLayer = L.layerGroup().addTo(this.map);
                
                // Create temporary drawing layer
                this.tempLayer = L.layerGroup().addTo(this.map);
                
                // Create marker layer
                this.markerLayer = L.layerGroup().addTo(this.map);
                
                // Map event listeners
                this.map.on('click', this.handleMapClick.bind(this));
                this.map.on('mousemove', this.handleMouseMove.bind(this));
                this.map.on('contextmenu', this.handleContextMenu.bind(this));
                
                // Get user location
                this.getUserLocation();
                
                // Render existing data on the map
                this.renderAllUtilities();
            }
            
            /**
             * Initialize event listeners for UI elements
             */
            initEventListeners() {
                // Mode toggle
                document.querySelectorAll('.mode-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.setActiveMode(option.getAttribute('data-mode'));
                    });
                });
                
                // Utility type buttons
                document.querySelectorAll('.utility-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        this.setSelectedUtilityType(button.getAttribute('data-utility'));
                    });
                });
                
                // Map tool buttons
                document.getElementById('draw-main-btn')?.addEventListener('click', () => {
                    this.startDrawing('main');
                });
                
                document.getElementById('draw-service-btn')?.addEventListener('click', () => {
                    this.startDrawing('service');
                });
                
                document.getElementById('add-structure-btn')?.addEventListener('click', () => {
                    this.startDrawing('structure');
                });
                
                document.getElementById('connect-utilities-btn')?.addEventListener('click', () => {
                    this.startConnecting();
                });
                
                document.getElementById('measure-btn')?.addEventListener('click', () => {
                    this.startDrawing('measurement');
                });
                
                // Floating action button
                document.getElementById('main-fab')?.addEventListener('click', () => {
                    this.toggleFabMenu();
                });
                
                // FAB menu items
                document.querySelector('.fab-item.item-discover button')?.addEventListener('click', () => {
                    this.openDiscoveryModal(this.map.getCenter());
                    this.toggleFabMenu();
                });
                
                document.querySelector('.fab-item.item-map button')?.addEventListener('click', () => {
                    this.setActiveMode('map');
                    this.startDrawing(this.activeMode === 'discover' ? 'utility' : 'main');
                    this.toggleFabMenu();
                });
                
                document.querySelector('.fab-item:nth-child(3) button')?.addEventListener('click', () => {
                    this.openStructureModal(this.map.getCenter());
                    this.toggleFabMenu();
                });
                
                // Side control buttons
                document.getElementById('locate-btn')?.addEventListener('click', () => {
                    this.centerOnUserLocation();
                });
                
                document.getElementById('zoom-in-btn')?.addEventListener('click', () => {
                    this.map.zoomIn();
                });
                
                document.getElementById('zoom-out-btn')?.addEventListener('click', () => {
                    this.map.zoomOut();
                });
                
                document.getElementById('layers-btn')?.addEventListener('click', () => {
                    this.openLayersModal();
                });
                
                document.getElementById('undo-btn')?.addEventListener('click', () => {
                    this.undoLastAction();
                });
                
                // Drawing control buttons
                document.getElementById('cancel-drawing-btn')?.addEventListener('click', () => {
                    this.cancelDrawing();
                });
                
                document.getElementById('finish-drawing-btn')?.addEventListener('click', () => {
                    this.finishDrawing();
                });
                
                // Menu button
                document.getElementById('menu-btn')?.addEventListener('click', () => {
                    this.openMenuModal();
                });
                
                // Utility discovery modal
                document.getElementById('discovery-modal-close')?.addEventListener('click', () => {
                    this.closeModal('utility-discovery-modal');
                });
                
                document.getElementById('cancel-discovery-btn')?.addEventListener('click', () => {
                    this.closeModal('utility-discovery-modal');
                });
                
                document.getElementById('save-discovery-btn')?.addEventListener('click', () => {
                    this.saveDiscoveredUtility();
                });
                
                // Direction controls in discovery modal
                document.getElementById('rotate-left-btn')?.addEventListener('click', () => {
                    this.rotateDirection(-15);
                });
                
                document.getElementById('rotate-right-btn')?.addEventListener('click', () => {
                    this.rotateDirection(15);
                });
                
                // Photo upload handling
                document.getElementById('utility-photo')?.addEventListener('change', (event) => {
                    this.handlePhotoUpload(event, 'preview-image', 'photo-preview');
                });
                
                document.getElementById('remove-photo')?.addEventListener('click', () => {
                    this.removePhoto('utility-photo', 'photo-preview');
                });
                
                // Structure modal
                document.getElementById('structure-modal-close')?.addEventListener('click', () => {
                    this.closeModal('structure-modal');
                });
                
                document.getElementById('cancel-structure-btn')?.addEventListener('click', () => {
                    this.closeModal('structure-modal');
                });
                
                document.getElementById('save-structure-btn')?.addEventListener('click', () => {
                    this.saveStructure();
                });
                
                // Structure photo upload handling
                document.getElementById('structure-photo')?.addEventListener('change', (event) => {
                    this.handlePhotoUpload(event, 'structure-preview-image', 'structure-photo-preview');
                });
                
                document.getElementById('remove-structure-photo')?.addEventListener('click', () => {
                    this.removePhoto('structure-photo', 'structure-photo-preview');
                });
                
                // Context menu
                document.getElementById('edit-item')?.addEventListener('click', () => {
                    this.editSelectedElement();
                });
                
                document.getElementById('edit-geometry-item')?.addEventListener('click', () => {
                    this.editGeometry();
                });
                
                document.getElementById('connect-item')?.addEventListener('click', () => {
                    this.connectSelectedElement();
                });
                
                document.getElementById('delete-item')?.addEventListener('click', () => {
                    this.deleteSelectedElement();
                });
                
                // Utility info panel
                document.getElementById('utility-info-close')?.addEventListener('click', () => {
                    this.closeUtilityInfo();
                });
                
                document.getElementById('edit-utility-btn')?.addEventListener('click', () => {
                    this.editSelectedElement();
                });
                
                document.getElementById('delete-utility-btn')?.addEventListener('click', () => {
                    this.deleteSelectedElement();
                });
                
                // Menu modal
                document.getElementById('menu-modal-close')?.addEventListener('click', () => {
                    this.closeModal('menu-modal');
                });
                
                document.getElementById('search-location-btn')?.addEventListener('click', () => {
                    this.openLocationModal();
                    this.closeModal('menu-modal');
                });
                
                document.getElementById('export-btn')?.addEventListener('click', () => {
                    this.exportData();
                    this.closeModal('menu-modal');
                });
                
                document.getElementById('import-btn')?.addEventListener('click', () => {
                    this.importData();
                    this.closeModal('menu-modal');
                });
                
                document.getElementById('clear-data-btn')?.addEventListener('click', () => {
                    this.confirmClearData();
                    this.closeModal('menu-modal');
                });
                
                // Layers modal
                document.getElementById('layers-modal-close')?.addEventListener('click', () => {
                    this.closeModal('layers-modal');
                });
                
                // Base map control
                document.querySelectorAll('#base-map-control .segmented-option').forEach(option => {
                    option.addEventListener('click', () => {
                        this.setBaseMap(option.getAttribute('data-value'));
                        this.updateSegmentedControl('base-map-control', option.getAttribute('data-value'));
                    });
                });
                
                // Layer toggles
                document.getElementById('water-layer-toggle')?.addEventListener('change', (e) => {
                    this.toggleLayer('water', e.target.checked);
                });
                
                document.getElementById('gas-layer-toggle')?.addEventListener('change', (e) => {
                    this.toggleLayer('gas', e.target.checked);
                });
                
                document.getElementById('electric-layer-toggle')?.addEventListener('change', (e) => {
                    this.toggleLayer('electric', e.target.checked);
                });
                
                document.getElementById('sewer-layer-toggle')?.addEventListener('change', (e) => {
                    this.toggleLayer('sewer', e.target.checked);
                });
                
                document.getElementById('telecom-layer-toggle')?.addEventListener('change', (e) => {
                    this.toggleLayer('telecom', e.target.checked);
                });
                
                document.getElementById('mains-toggle')?.addEventListener('change', (e) => {
                    this.toggleLineType('main', e.target.checked);
                });
                
                document.getElementById('services-toggle')?.addEventListener('change', (e) => {
                    this.toggleLineType('service', e.target.checked);
                });
                
                document.getElementById('structures-toggle')?.addEventListener('change', (e) => {
                    this.toggleStructures(e.target.checked);
                });
                
                document.getElementById('measurements-toggle')?.addEventListener('change', (e) => {
                    this.toggleMeasurements(e.target.checked);
                });
                
                // Location modal
                document.getElementById('location-modal-close')?.addEventListener('click', () => {
                    this.closeModal('location-modal');
                });
                
                document.getElementById('use-my-location-btn')?.addEventListener('click', () => {
                    this.getUserLocation(true);
                    this.closeModal('location-modal');
                });
                
                document.getElementById('search-location-btn-modal')?.addEventListener('click', () => {
                    this.searchLocation();
                });
                
                // Global document events
                document.addEventListener('keydown', (e) => {
                    // Escape key
                    if (e.key === 'Escape') {
                        this.handleEscapeKey();
                    }
                    
                    // Delete key when element selected
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.selectedElement) {
                        this.deleteSelectedElement();
                    }
                });
                
                // Prevent browser back/forward on swipe
                window.addEventListener('touchstart', (e) => {
                    // Check if touch started at the edge of the screen
                    if (e.touches[0].clientX < 20 || e.touches[0].clientX > window.innerWidth - 20) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
            
            /**
             * Load saved data from storage
             */
            loadSavedData() {
                const savedData = this.storageManager.loadData();
                if (savedData) {
                    this.data.importData(savedData);
                    console.log('Loaded saved data');
                }
            }
            
            /**
             * Save data to storage
             */
            saveData() {
                const dataToSave = this.data.exportData();
                const success = this.storageManager.saveData(dataToSave);
                if (success) {
                    console.log('Data saved successfully');
                } else {
                    this.showToast('Failed to save data. Storage may be full.', 'error');
                }
            }
            
            /**
             * Set active mode (discover or map)
             * @param {string} mode - Mode to set
             */
            setActiveMode(mode) {
                if (mode !== 'discover' && mode !== 'map') {
                    console.error('Invalid mode:', mode);
                    return;
                }
                
                // Update active mode
                this.activeMode = mode;
                
                // Update UI
                document.querySelectorAll('.mode-option').forEach(option => {
                    if (option.getAttribute('data-mode') === mode) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                });
                
                // Update mode slider position
                const slider = document.querySelector('.mode-slider');
                const activeOption = document.querySelector(`.mode-option[data-mode="${mode}"]`);
                
                if (slider && activeOption) {
                    slider.style.width = `${activeOption.offsetWidth}px`;
                    slider.style.transform = `translateX(${activeOption.offsetLeft}px)`;
                }
                
                // Show appropriate toolbar
                document.getElementById('discover-toolbar').classList.toggle('hidden', mode !== 'discover');
                document.getElementById('map-toolbar').classList.toggle('hidden', mode !== 'map');
                
                // Cancel any active drawing
                this.cancelDrawing();
                
                // Clear any selected element
                this.clearSelectedElement();
                
                // Update status
                this.showToast(`Switched to ${mode} mode`, 'info');
            }
            
            /**
             * Set selected utility type
             * @param {string} type - Utility type to set
             */
            setSelectedUtilityType(type) {
                if (!this.utilityLayers[type]) {
                    console.error('Invalid utility type:', type);
                    return;
                }
                
                // Update selected type
                this.selectedUtilityType = type;
                
                // Update UI
                document.querySelectorAll('.utility-btn').forEach(btn => {
                    if (btn.getAttribute('data-utility') === type) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                
                // If in discover mode, update utility type dropdown in discovery modal
                const utilityTypeSelect = document.getElementById('utility-type');
                if (utilityTypeSelect) {
                    utilityTypeSelect.value = type;
                }
                
                // If in map mode with draw tool active, restart drawing with new type
                if (this.activeMode === 'map' && this.isDrawing) {
                    this.cancelDrawing();
                    this.startDrawing(this.currentDrawingType);
                }
            }
            
            /**
             * Get user's current location
             * @param {boolean} center - Whether to center map on location
             */
            getUserLocation(center = false) {
                if (navigator.geolocation) {
                    // Show loading
                    this.showModal('loading-modal');
                    document.getElementById('loading-text').textContent = 'Getting your location...';
                    
                    navigator.geolocation.getCurrentPosition(
                        // Success callback
                        (position) => {
                            this.userLocation = L.latLng(position.coords.latitude, position.coords.longitude);
                            
                            // Create or update user marker
                            if (!this.userMarker) {
                                // Create user location marker
                                const userIcon = L.divIcon({
                                    html: `<div style="background-color: #4285f4; width: 16px; height: 16px; border-radius: 50%; box-shadow: 0 0 0 4px rgba(66, 133, 244, 0.3);"></div>`,
                                    className: '',
                                    iconSize: [16, 16],
                                    iconAnchor: [8, 8]
                                });
                                
                                this.userMarker = L.marker(this.userLocation, {
                                    icon: userIcon,
                                    zIndexOffset: 1000
                                }).addTo(this.map);
                            } else {
                                this.userMarker.setLatLng(this.userLocation);
                            }
                            
                            // Center map if requested
                            if (center) {
                                this.map.setView(this.userLocation, 19);
                            }
                            
                            // Hide loading
                            this.closeModal('loading-modal');
                            
                            // Setup continuous location watching
                            if (!this.locationWatchId) {
                                this.locationWatchId = navigator.geolocation.watchPosition(
                                    (watchPosition) => {
                                        this.userLocation = L.latLng(
                                            watchPosition.coords.latitude,
                                            watchPosition.coords.longitude
                                        );
                                        
                                        if (this.userMarker) {
                                            this.userMarker.setLatLng(this.userLocation);
                                        }
                                    },
                                    (error) => {
                                        console.error('Error watching position:', error);
                                    },
                                    {
                                        enableHighAccuracy: true,
                                        maximumAge: 10000,
                                        timeout: 10000
                                    }
                                );
                            }
                        },
                        // Error callback
                        (error) => {
                            console.error('Error getting location:', error);
                            this.closeModal('loading-modal');
                            
                            let errorMessage = 'Error getting your location.';
                            
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMessage = 'Location access denied. Please enable location in your browser settings.';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMessage = 'Location unavailable. Try using an address instead.';
                                    break;
                                case error.TIMEOUT:
                                    errorMessage = 'Location request timed out. Please try again.';
                                    break;
                            }
                            
                            this.showToast(errorMessage, 'error');
                        },
                        // Options
                        {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 10000
                        }
                    );
                } else {
                    this.showToast('Geolocation is not supported by your browser.', 'error');
                }
            }
            
            /**
             * Center map on user location
             */
            centerOnUserLocation() {
                if (this.userLocation) {
                    this.map.setView(this.userLocation, 19);
                } else {
                    this.getUserLocation(true);
                }
            }
            
            /**
             * Set base map
             * @param {string} type - Base map type
             */
            setBaseMap(type) {
                if (!this.baseMaps[type]) {
                    console.error('Invalid base map type:', type);
                    return;
                }
                
                // Remove current base map
                if (this.baseMaps[this.baseMapType]) {
                    this.map.removeLayer(this.baseMaps[this.baseMapType]);
                }
                
                // Add new base map
                this.baseMaps[type].addTo(this.map);
                this.baseMapType = type;
            }
            
            /**
             * Toggle utility layer visibility
             * @param {string} type - Utility type
             * @param {boolean} visible - Visibility state
             */
            toggleLayer(type, visible) {
                if (!this.utilityLayers[type]) {
                    console.error('Invalid utility type:', type);
                    return;
                }
                
                if (visible) {
                    if (!this.map.hasLayer(this.utilityLayers[type])) {
                        this.map.addLayer(this.utilityLayers[type]);
                    }
                } else {
                    if (this.map.hasLayer(this.utilityLayers[type])) {
                        this.map.removeLayer(this.utilityLayers[type]);
                    }
                }
            }
            
            /**
             * Toggle visibility of main/service lines
             * @param {string} lineType - Line type ('main' or 'service')
             * @param {boolean} visible - Visibility state
             */
            toggleLineType(lineType, visible) {
                for (const type in this.utilityLayers) {
                    const layer = this.utilityLayers[type];
                    
                    layer.eachLayer((l) => {
                        // Check if it's a line of the specified type
                        if (l.utilityData && l.utilityData.lineType === lineType) {
                            if (visible) {
                                l.setStyle({ opacity: 1 });
                                if (l.utilityMarker) {
                                    l.utilityMarker.setOpacity(1);
                                }
                            } else {
                                l.setStyle({ opacity: 0 });
                                if (l.utilityMarker) {
                                    l.utilityMarker.setOpacity(0);
                                }
                            }
                        }
                    });
                }
            }
            
            /**
             * Toggle visibility of structures
             * @param {boolean} visible - Visibility state
             */
            toggleStructures(visible) {
                this.markerLayer.eachLayer((marker) => {
                    if (marker.structureData) {
                        if (visible) {
                            marker.setOpacity(1);
                        } else {
                            marker.setOpacity(0);
                        }
                    }
                });
            }
            
            /**
             * Toggle visibility of measurements
             * @param {boolean} visible - Visibility state
             */
            toggleMeasurements(visible) {
                if (visible) {
                    if (!this.map.hasLayer(this.measurementLayer)) {
                        this.map.addLayer(this.measurementLayer);
                    }
                } else {
                    if (this.map.hasLayer(this.measurementLayer)) {
                        this.map.removeLayer(this.measurementLayer);
                    }
                }
            }
            
            /**
             * Handle map click event
             * @param {L.MouseEvent} e - Map click event
             */
            handleMapClick(e) {
                // If context menu is open, close it
                this.closeContextMenu();
                
                // If info panel is open, close it
                this.closeUtilityInfo();
                
                // If drawing is active, handle click for drawing
                if (this.isDrawing) {
                    this.handleDrawingClick(e);
                    return;
                }
                
                // In discover mode, clicking on the map opens the discovery modal
                if (this.activeMode === 'discover') {
                    this.openDiscoveryModal(e.latlng);
                }
            }
            
            /**
             * Handle map click during drawing
             * @param {L.MouseEvent} e - Map click event
             */
            handleDrawingClick(e) {
                // Get click location, apply snapping if available
                let clickPoint = e.latlng;
                if (this.snappingEnabled && this.nearestSnapPoint) {
                    clickPoint = this.nearestSnapPoint;
                }
                
                // Add point to drawing
                this.drawingPoints.push(clickPoint);
                
                // Create or update temporary line
                if (this.drawingPoints.length === 1) {
                    // First point, create marker
                    L.circleMarker(clickPoint, {
                        radius: 5,
                        color: this.getUtilityColor(this.selectedUtilityType),
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(this.tempLayer);
                    
                    // If it's a structure, we only need one point
                    if (this.currentDrawingType === 'structure') {
                        this.finishDrawing();
                        return;
                    }
                    
                    // Show drawing controls
                    document.getElementById('drawing-controls').style.display = 'flex';
                    
                    // Create temporary line
                    const lineStyle = {
                        color: this.getUtilityColor(this.selectedUtilityType),
                        weight: this.currentDrawingType === 'main' ? 5 : 3,
                        opacity: 0.7,
                        dashArray: '5, 5',
                        className: 'drawing-preview'
                    };
                    
                    this.tempLine = L.polyline([clickPoint, clickPoint], lineStyle).addTo(this.tempLayer);
                    
                    // Update status
                    this.showToast('Click to add points, double-click to finish', 'info');
                } 
                else {
                    // Add circle marker at click point
                    L.circleMarker(clickPoint, {
                        radius: 5,
                        color: this.getUtilityColor(this.selectedUtilityType),
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(this.tempLayer);
                    
                    // Update temp line
                    if (this.tempLine) {
                        this.tempLine.setLatLngs(this.drawingPoints);
                    }
                    
                    // Check for double-click (two points close together in time and space)
                    if (this.drawingPoints.length > 2) {
                        const lastPoint = this.drawingPoints[this.drawingPoints.length - 1];
                        const prevPoint = this.drawingPoints[this.drawingPoints.length - 2];
                        
                        // Calculate distance between last two points
                        const distance = lastPoint.distanceTo(prevPoint);
                        
                        // If points are very close, consider it a double-click
                        if (distance < 2) {
                            // Remove the last point (duplicate)
                            this.drawingPoints.pop();
                            this.tempLayer.clearLayers();
                            this.finishDrawing();
                        }
                    }
                }
            }
            
            /**
             * Handle mouse move during drawing
             * @param {L.MouseEvent} e - Mouse move event
             */
            handleMouseMove(e) {
                // If not drawing or no temp line, exit
                if (!this.isDrawing || !this.tempLine || this.drawingPoints.length === 0) {
                    return;
                }
                
                // Check for snapping
                if (this.snappingEnabled) {
                    // Find nearby utilities for snapping
                    const nearbyUtilities = this.data.findNearbyUtilities(e.latlng, this.snappingRadius);
                    
                    if (nearbyUtilities.length > 0) {
                        // Get nearest utility segment
                        const nearest = nearbyUtilities[0];
                        const utility = nearest.utility;
                        const segment = nearest.segment;
                        
                        // Calculate nearest point on segment
                        const p1 = utility.points[segment[0]];
                        const p2 = utility.points[segment[1]];
                        
                        // Project point onto segment
                        const nearestPoint = this.projectPointOnSegment(e.latlng, p1, p2);
                        
                        // Set nearest snap point
                        this.nearestSnapPoint = nearestPoint;
                        
                        // Show snapping indicator
                        this.showSnapIndicator(nearestPoint);
                        
                        // Update temp line with snapped point
                        const points = [...this.drawingPoints, nearestPoint];
                        this.tempLine.setLatLngs(points);
                        
                        return;
                    } else {
                        // Check for nearby structures
                        const nearbyStructures = this.data.findNearbyStructures(e.latlng, this.snappingRadius);
                        
                        if (nearbyStructures.length > 0) {
                            // Get nearest structure
                            const nearest = nearbyStructures[0];
                            const structure = nearest.structure;
                            
                            // Set nearest snap point
                            this.nearestSnapPoint = structure.location;
                            
                            // Show snapping indicator
                            this.showSnapIndicator(structure.location);
                            
                            // Update temp line with snapped point
                            const points = [...this.drawingPoints, structure.location];
                            this.tempLine.setLatLngs(points);
                            
                            return;
                        }
                    }
                }
                
                // No snapping, clear nearest snap point
                this.nearestSnapPoint = null;
                
                // Clear snap indicator
                this.clearSnapIndicator();
                
                // Update temp line with mouse position
                const points = [...this.drawingPoints, e.latlng];
                this.tempLine.setLatLngs(points);
            }
            
            /**
             * Show snap indicator at a point
             * @param {L.LatLng} point - Point to show indicator
             */
            showSnapIndicator(point) {
                // Clear any existing indicator
                this.clearSnapIndicator();
                
                // Create snap indicator
                this.snapIndicator = L.circleMarker(point, {
                    radius: 6,
                    color: '#fff',
                    fillColor: '#4caf50',
                    fillOpacity: 1,
                    weight: 2,
                    className: 'snapping-point'
                }).addTo(this.tempLayer);
            }
            
            /**
             * Clear snap indicator
             */
            clearSnapIndicator() {
                if (this.snapIndicator) {
                    this.tempLayer.removeLayer(this.snapIndicator);
                    this.snapIndicator = null;
                }
            }
            
            /**
             * Start drawing
             * @param {string} type - Drawing type ('main', 'service', 'structure', 'measurement')
             */
            startDrawing(type) {
                // Cancel any active drawing
                this.cancelDrawing();
                
                // Set drawing state
                this.isDrawing = true;
                this.currentDrawingType = type;
                
                // Clear drawing points and temp layer
                this.drawingPoints = [];
                this.tempLayer.clearLayers();
                
                // Clear any selected element
                this.clearSelectedElement();
                
                // Set active toolbar button
                this.setActiveToolbarButton(type);
                
                // Show toast message based on drawing type
                let message = '';
                switch (type) {
                    case 'main':
                        message = 'Click to start drawing a utility main line';
                        break;
                    case 'service':
                        message = 'Click to start drawing a service line';
                        break;
                    case 'structure':
                        message = 'Click to place a utility structure';
                        break;
                    case 'measurement':
                        message = 'Click to start a measurement';
                        break;
                    default:
                        message = 'Click to start drawing';
                }
                
                this.showToast(message, 'info');
            }
            
            /**
             * Cancel current drawing
             */
            cancelDrawing() {
                if (!this.isDrawing) return;
                
                // Reset drawing state
                this.isDrawing = false;
                this.currentDrawingType = null;
                this.drawingPoints = [];
                
                // Clear temp layer
                this.tempLayer.clearLayers();
                this.tempLine = null;
                
                // Clear nearest snap point
                this.nearestSnapPoint = null;
                this.clearSnapIndicator();
                
                // Hide drawing controls
                document.getElementById('drawing-controls').style.display = 'none';
                
                // Clear active toolbar button
                this.clearActiveToolbarButton();
            }
            
            /**
             * Finish current drawing
             */
            finishDrawing() {
                if (!this.isDrawing) return;
                
                // Need at least one point
                if (this.drawingPoints.length === 0) {
                    this.cancelDrawing();
                    return;
                }
                
                // Handle based on drawing type
                switch (this.currentDrawingType) {
                    case 'main':
                    case 'service':
                        this.finishUtilityLine();
                        break;
                    case 'structure':
                        this.openStructureModal(this.drawingPoints[0]);
                        break;
                    case 'measurement':
                        this.finishMeasurement();
                        break;
                }
                
                // Reset drawing state
                this.isDrawing = false;
                this.currentDrawingType = null;
                this.drawingPoints = [];
                this.tempLine = null;
                
                // Clear temp layer
                this.tempLayer.clearLayers();
                
                // Hide drawing controls
                document.getElementById('drawing-controls').style.display = 'none';
            }
            
            /**
             * Finish drawing a utility line
             */
            finishUtilityLine() {
                // Need at least 2 points for a line
                if (this.drawingPoints.length < 2) {
                    this.showToast('Need at least 2 points to create a line', 'warning');
                    this.cancelDrawing();
                    return;
                }
                
                // Create utility object
                const utility = {
                    type: this.selectedUtilityType,
                    lineType: this.currentDrawingType,
                    points: [...this.drawingPoints],
                    size: 4, // Default size
                    depth: 3, // Default depth
                    material: 'PVC', // Default material
                    condition: 'Good', // Default condition
                    direction: 0, // Default direction
                    dateAdded: new Date()
                };
                
                // Add to data model
                const id = this.data.addUtility(utility);
                
                // Get the utility with assigned ID
                const addedUtility = this.data.findUtility(id);
                
                // Add to map
                this.renderUtility(addedUtility);
                
                // Add to undo stack
                this.undoManager.addAction({
                    type: 'add-utility',
                    utilityId: id
                });
                
                // Save data
                this.saveData();
                
                // Show success message
                this.showToast(`Added ${this.selectedUtilityType} ${this.currentDrawingType} line`, 'success');
            }
            
            /**
             * Finish a measurement
             */
            finishMeasurement() {
                // Need at least 2 points for a measurement
                if (this.drawingPoints.length < 2) {
                    this.showToast('Need at least 2 points to create a measurement', 'warning');
                    this.cancelDrawing();
                    return;
                }
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 0; i < this.drawingPoints.length - 1; i++) {
                    totalDistance += this.drawingPoints[i].distanceTo(this.drawingPoints[i + 1]);
                }
                
                // Round to 2 decimal places
                totalDistance = Math.round(totalDistance * 100) / 100;
                
                // Create measurement object
                const measurement = {
                    type: 'distance',
                    points: [...this.drawingPoints],
                    value: totalDistance,
                    unit: 'm', // Default unit is meters
                    label: `${totalDistance} m` // Default label
                };
                
                // Add to data model
                const id = this.data.addMeasurement(measurement);
                
                // Get the measurement with assigned ID
                const addedMeasurement = this.data.measurements.find(m => m.id === id);
                
                // Add to map
                this.renderMeasurement(addedMeasurement);
                
                // Add to undo stack
                this.undoManager.addAction({
                    type: 'add-measurement',
                    measurementId: id
                });
                
                // Save data
                this.saveData();
                
                // Show success message
                this.showToast(`Added measurement: ${totalDistance} m`, 'success');
            }
            
            /**
             * Open discovery modal for adding a utility
             * @param {L.LatLng} location - Location to add utility
             */
            openDiscoveryModal(location) {
                // Store the location
                this.discoveryLocation = location;
                
                // Reset form
                document.getElementById('utility-type').value = this.selectedUtilityType;
                document.getElementById('line-type-service').checked = true;
                document.getElementById('utility-size').value = '4';
                document.getElementById('utility-depth').value = '3';
                document.getElementById('utility-material').value = 'PVC';
                document.getElementById('utility-condition').value = 'Good';
                document.getElementById('utility-notes').value = '';
                
                // Reset direction
                this.directionValue = 0;
                document.getElementById('direction-arrow').style.transform = `rotate(${this.directionValue}deg)`;
                document.getElementById('direction-value').textContent = `${this.directionValue}`;
                
                // Clear photo preview
                this.removePhoto('utility-photo', 'photo-preview');
                
                // Show the modal
                this.showModal('utility-discovery-modal');
            }
            
            /**
             * Open structure modal for adding a structure
             * @param {L.LatLng} location - Location to add structure
             */
            openStructureModal(location) {
                // Store the location
                this.structureLocation = location;
                
                // Reset form
                document.getElementById('structure-type').value = 'valve';
                document.getElementById('structure-utility').value = this.selectedUtilityType;
                document.getElementById('structure-size').value = '12';
                document.getElementById('structure-depth').value = '6';
                document.getElementById('structure-condition').value = 'Good';
                document.getElementById('structure-notes').value = '';
                
                // Clear photo preview
                this.removePhoto('structure-photo', 'structure-photo-preview');
                
                // Show the modal
                this.showModal('structure-modal');
            }
            
            /**
             * Open menu modal
             */
            openMenuModal() {
                this.showModal('menu-modal');
            }
            
            /**
             * Open layers modal
             */
            openLayersModal() {
                this.showModal('layers-modal');
            }
            
            /**
             * Open location modal
             */
            openLocationModal() {
                // Reset form
                document.getElementById('address-input').value = '';
                
                // Show the modal
                this.showModal('location-modal');
            }
            
            /**
             * Show a modal dialog
             * @param {string} modalId - ID of the modal to show
             */
            showModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.add('active');
                }
            }
            
            /**
             * Close a modal dialog
             * @param {string} modalId - ID of the modal to close
             */
            closeModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('active');
                }
            }
            
            /**
             * Rotate the direction arrow
             * @param {number} degrees - Degrees to rotate
             */
            rotateDirection(degrees) {
                // Update direction value
                this.directionValue = (this.directionValue + degrees + 360) % 360;
                
                // Update arrow rotation
                document.getElementById('direction-arrow').style.transform = `rotate(${this.directionValue}deg)`;
                
                // Update text value
                document.getElementById('direction-value').textContent = `${this.directionValue}`;
            }
            
            /**
             * Handle photo upload
             * @param {Event} event - Input change event
             * @param {string} imageId - ID of the image element to update
             * @param {string} previewId - ID of the preview container to show
             */
            handlePhotoUpload(event, imageId, previewId) {
                const file = event.target.files[0];
                if (!file) return;
                
                // Check file type
                if (!file.type.startsWith('image/')) {
                    this.showToast('Please select an image file', 'error');
                    return;
                }
                
                // Check file size (max 5MB)
                if (file.size > 5 * 1024 * 1024) {
                    this.showToast('Image is too large. Maximum size is 5MB', 'error');
                    return;
                }
                
                // Create FileReader
                const reader = new FileReader();
                
                // Set up onload callback
                reader.onload = (e) => {
                    // Update preview image
                    const img = document.getElementById(imageId);
                    img.src = e.target.result;
                    
                    // Show preview container
                    document.getElementById(previewId).style.display = 'block';
                };
                
                // Read file as data URL
                reader.readAsDataURL(file);
            }
            
            /**
             * Remove uploaded photo
             * @param {string} inputId - ID of the file input to clear
             * @param {string} previewId - ID of the preview container to hide
             */
            removePhoto(inputId, previewId) {
                // Clear file input
                document.getElementById(inputId).value = '';
                
                // Hide preview container
                document.getElementById(previewId).style.display = 'none';
            }
            
            /**
             * Save discovered utility
             */
            saveDiscoveredUtility() {
                // Get form values
                const type = document.getElementById('utility-type').value;
                const lineType = document.querySelector('input[name="line-type"]:checked').value;
                const size = parseFloat(document.getElementById('utility-size').value) || 4;
                const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                const material = document.getElementById('utility-material').value;
                const condition = document.getElementById('utility-condition').value;
                const notes = document.getElementById('utility-notes').value;
                
                // Get direction
                const direction = this.directionValue || 0;
                
                // Get photo data
                const photoInput = document.getElementById('utility-photo');
                let photoData = null;
                
                if (photoInput.files && photoInput.files[0]) {
                    // Get photo preview data
                    const img = document.getElementById('preview-image');
                    photoData = img.src;
                }
                
                // Create endpoint based on direction and default length
                const startPoint = this.discoveryLocation;
                const endPoint = this.calculateEndpoint(startPoint, direction, 5); // 5 meter default length
                
                // Create utility object
                const utility = {
                    type: type,
                    lineType: lineType,
                    size: size,
                    depth: depth,
                    material: material,
                    condition: condition,
                    notes: notes,
                    direction: direction,
                    points: [startPoint, endPoint],
                    photoData: photoData,
                    dateAdded: new Date()
                };
                
                // Add to data model
                const id = this.data.addUtility(utility);
                
                // Get the utility with assigned ID
                const addedUtility = this.data.findUtility(id);
                
                // Add to map
                this.renderUtility(addedUtility);
                
                // Add to undo stack
                this.undoManager.addAction({
                    type: 'add-utility',
                    utilityId: id
                });
                
                // Save data
                this.saveData();
                
                // Close the modal
                this.closeModal('utility-discovery-modal');
                
                // Show success message
                this.showToast(`Added ${type} ${lineType} line`, 'success');
            }
            
            /**
             * Save structure
             */
            saveStructure() {
                // Get form values
                const type = document.getElementById('structure-type').value;
                const utilityType = document.getElementById('structure-utility').value;
                const size = parseFloat(document.getElementById('structure-size').value) || 12;
                const depth = parseFloat(document.getElementById('structure-depth').value) || 6;
                const condition = document.getElementById('structure-condition').value;
                const notes = document.getElementById('structure-notes').value;
                
                // Get photo data
                const photoInput = document.getElementById('structure-photo');
                let photoData = null;
                
                if (photoInput.files && photoInput.files[0]) {
                    // Get photo preview data
                    const img = document.getElementById('structure-preview-image');
                    photoData = img.src;
                }
                
                // Create structure object
                const structure = {
                    type: type,
                    utilityType: utilityType,
                    size: size,
                    depth: depth,
                    condition: condition,
                    notes: notes,
                    location: this.structureLocation,
                    photoData: photoData,
                    dateAdded: new Date()
                };
                
                // Add to data model
                const id = this.data.addStructure(structure);
                
                // Get the structure with assigned ID
                const addedStructure = this.data.findStructure(id);
                
                // Add to map
                this.renderStructure(addedStructure);
                
                // Add to undo stack
                this.undoManager.addAction({
                    type: 'add-structure',
                    structureId: id
                });
                
                // Save data
                this.saveData();
                
                // Close the modal
                this.closeModal('structure-modal');
                
                // Show success message
                this.showToast(`Added ${utilityType} ${type}`, 'success');
            }
            
            /**
             * Calculate end point from start point, direction and distance
             * @param {L.LatLng} startPoint - Starting point
             * @param {number} direction - Direction in degrees (0 = north, clockwise)
             * @param {number} distance - Distance in meters
             * @returns {L.LatLng} End point
             */
            calculateEndpoint(startPoint, direction, distance) {
                // Convert direction to radians (0 degrees = north, clockwise)
                const dirRad = (90 - direction) * Math.PI / 180;
                
                // Earth's radius in meters
                const R = 6378137;
                
                // Angular distance
                const angDist = distance / R;
                
                // Convert start point to radians
                const lat1 = startPoint.lat * Math.PI / 180;
                const lng1 = startPoint.lng * Math.PI / 180;
                
                // Calculate end point coordinates
                const lat2 = Math.asin(
                    Math.sin(lat1) * Math.cos(angDist) + 
                    Math.cos(lat1) * Math.sin(angDist) * Math.cos(dirRad)
                );
                
                const lng2 = lng1 + Math.atan2(
                    Math.sin(dirRad) * Math.sin(angDist) * Math.cos(lat1),
                    Math.cos(angDist) - Math.sin(lat1) * Math.sin(lat2)
                );
                
                // Convert back to degrees
                return L.latLng(
                    lat2 * 180 / Math.PI,
                    lng2 * 180 / Math.PI
                );
            }
            
            /**
             * Project a point onto a line segment
             * @param {L.LatLng} p - Point to project
             * @param {L.LatLng} v - First segment endpoint
             * @param {L.LatLng} w - Second segment endpoint
             * @returns {L.LatLng} Projected point
             */
            projectPointOnSegment(p, v, w) {
                // Convert to screen pixels for more accurate projection
                const mapP = this.map.latLngToContainerPoint(p);
                const mapV = this.map.latLngToContainerPoint(v);
                const mapW = this.map.latLngToContainerPoint(w);
                
                // Calculate vectors
                const vw = {
                    x: mapW.x - mapV.x,
                    y: mapW.y - mapV.y
                };
                
                const vp = {
                    x: mapP.x - mapV.x,
                    y: mapP.y - mapV.y
                };
                
                // Calculate squared length of segment
                const lenSq = vw.x * vw.x + vw.y * vw.y;
                
                // If segment is a point, return the point
                if (lenSq === 0) return v;
                
                // Calculate projection scalar
                let t = (vp.x * vw.x + vp.y * vw.y) / lenSq;
                
                // Clamp t to segment bounds
                t = Math.max(0, Math.min(1, t));
                
                // Calculate projected point in screen coordinates
                const projX = mapV.x + t * vw.x;
                const projY = mapV.y + t * vw.y;
                
                // Convert back to geographic coordinates
                return this.map.containerPointToLatLng(L.point(projX, projY));
            }
            
            /**
             * Handle context menu event
             * @param {L.MouseEvent} e - Right-click event
             */
            handleContextMenu(e) {
                // Prevent default browser context menu
                L.DomEvent.preventDefault(e);
                
                // Find element at click location
                const element = this.findElementAtPoint(e.latlng);
                
                if (element) {
                    // Set selected element
                    this.selectedElement = element;
                    
                    // Show context menu
                    this.showContextMenu(e.containerPoint, element);
                }
            }
            
            /**
             * Find map element at a point
             * @param {L.LatLng} latlng - Geographic point
             * @returns {Object|null} Found element or null
             */
            findElementAtPoint(latlng) {
                // Search for utilities first
                for (const type in this.utilityLayers) {
                    const layer = this.utilityLayers[type];
                    
                    let foundElement = null;
                    
                    layer.eachLayer((l) => {
                        if (foundElement) return; // Already found something
                        
                        if (l instanceof L.Polyline && l.utilityData) {
                            // Check if click is near the line
                            const distance = this.distanceToPolyline(latlng, l.getLatLngs());
                            if (distance <= 10) { // 10 meters threshold
                                foundElement = {
                                    type: 'utility',
                                    element: l,
                                    data: l.utilityData
                                };
                            }
                        } else if (l instanceof L.Marker && l.utilityData) {
                            // Check if click is near the marker
                            const distance = latlng.distanceTo(l.getLatLng());
                            if (distance <= 10) { // 10 meters threshold
                                foundElement = {
                                    type: 'utility',
                                    element: l,
                                    data: l.utilityData
                                };
                            }
                        }
                    });
                    
                    if (foundElement) {
                        return foundElement;
                    }
                }
                
                // Then search for structures
                let minDistance = Infinity;
                let closestStructure = null;
                
                this.markerLayer.eachLayer((marker) => {
                    if (marker.structureData) {
                        const distance = latlng.distanceTo(marker.getLatLng());
                        if (distance <= 10 && distance < minDistance) { // 10 meters threshold
                            minDistance = distance;
                            closestStructure = {
                                type: 'structure',
                                element: marker,
                                data: marker.structureData
                            };
                        }
                    }
                });
                
                if (closestStructure) {
                    return closestStructure;
                }
                
                // Finally search for measurements
                this.measurementLayer.eachLayer((l) => {
                    if (l instanceof L.Polyline && l.measurementData) {
                        // Check if click is near the line
                        const distance = this.distanceToPolyline(latlng, l.getLatLngs());
                        if (distance <= 10) { // 10 meters threshold
                            closestStructure = {
                                type: 'measurement',
                                element: l,
                                data: l.measurementData
                            };
                        }
                    }
                });
                
                return closestStructure;
            }
            
            /**
             * Calculate distance from a point to a polyline
             * @param {L.LatLng} point - Point
             * @param {Array} polyline - Array of L.LatLng points
             * @returns {number} Minimum distance in meters
             */
            distanceToPolyline(point, polyline) {
                let minDistance = Infinity;
                
                for (let i = 0; i < polyline.length - 1; i++) {
                    const p1 = polyline[i];
                    const p2 = polyline[i + 1];
                    
                    // Project point onto segment
                    const projected = this.projectPointOnSegment(point, p1, p2);
                    
                    // Calculate distance
                    const distance = point.distanceTo(projected);
                    
                    // Update minimum distance
                    if (distance < minDistance) {
                        minDistance = distance;
                    }
                }
                
                return minDistance;
            }
            
            /**
             * Show context menu at a point
             * @param {L.Point} point - Screen position
             * @param {Object} element - Element data
             */
            showContextMenu(point, element) {
                const menu = document.getElementById('context-menu');
                
                // Position the menu
                menu.style.left = `${point.x}px`;
                menu.style.top = `${point.y}px`;
                
                // Show/hide menu items based on element type
                const editItem = document.getElementById('edit-item');
                const editGeometryItem = document.getElementById('edit-geometry-item');
                const connectItem = document.getElementById('connect-item');
                
                if (element.type === 'utility') {
                    editItem.style.display = 'flex';
                    editGeometryItem.style.display = 'flex';
                    connectItem.style.display = 'flex';
                } else if (element.type === 'structure') {
                    editItem.style.display = 'flex';
                    editGeometryItem.style.display = 'none';
                    connectItem.style.display = 'flex';
                } else if (element.type === 'measurement') {
                    editItem.style.display = 'flex';
                    editGeometryItem.style.display = 'none';
                    connectItem.style.display = 'none';
                }
                
                // Show the menu with animation
                menu.classList.add('active');
            }
            
            /**
             * Close context menu
             */
            closeContextMenu() {
                const menu = document.getElementById('context-menu');
                menu.classList.remove('active');
            }
            
            /**
             * Show utility information panel
             * @param {Object} utility - Utility data
             */
            showUtilityInfo(utility) {
                const panel = document.getElementById('utility-info-panel');
                
                // Update panel title and icon
                const titleElement = panel.querySelector('.utility-info-title');
                const titleIcon = titleElement.querySelector('i');
                
                titleIcon.className = `fas ${this.getUtilityIcon(utility.type)} ${utility.type}`;
                titleElement.querySelector('span').textContent = `${utility.type.charAt(0).toUpperCase() + utility.type.slice(1)} ${utility.lineType.charAt(0).toUpperCase() + utility.lineType.slice(1)}`;
                
                // Update info fields
                document.getElementById('info-type').textContent = utility.lineType.charAt(0).toUpperCase() + utility.lineType.slice(1);
                document.getElementById('info-size').textContent = `${utility.size} inches`;
                document.getElementById('info-depth').textContent = `${utility.depth} feet`;
                document.getElementById('info-material').textContent = utility.material || 'Unknown';
                document.getElementById('info-condition').textContent = utility.condition || 'Unknown';
                
                // Calculate and display direction
                const directionName = this.getDirectionName(utility.direction);
                document.getElementById('info-direction').textContent = directionName;
                
                // Update image
                const imageContainer = document.getElementById('info-image');
                if (utility.photoData) {
                    imageContainer.innerHTML = `<img src="${utility.photoData}" alt="Utility photo">`;
                } else {
                    imageContainer.innerHTML = `<i class="fas fa-camera"></i> No image`;
                }
                
                // Show the panel
                panel.classList.add('active');
            }
            
            /**
             * Close utility info panel
             */
            closeUtilityInfo() {
                const panel = document.getElementById('utility-info-panel');
                panel.classList.remove('active');
            }
            
            /**
             * Get direction name from angle
             * @param {number} angle - Angle in degrees
             * @returns {string} Direction name
             */
            getDirectionName(angle) {
                const directions = ['North', 'Northeast', 'East', 'Southeast', 
                                   'South', 'Southwest', 'West', 'Northwest'];
                const index = Math.round(angle / 45) % 8;
                return directions[index];
            }
            
            /**
             * Toggle floating action button menu
             */
            toggleFabMenu() {
                const fab = document.getElementById('main-fab');
                const menu = document.getElementById('fab-menu');
                
                fab.classList.toggle('active');
                menu.classList.toggle('active');
            }
            
            /**
             * Hide floating action button menu
             */
            hideFabMenu() {
                const fab = document.getElementById('main-fab');
                const menu = document.getElementById('fab-menu');
                
                fab.classList.remove('active');
                menu.classList.remove('active');
            }
            
            /**
             * Handle escape key press
             */
            handleEscapeKey() {
                // Close any open modals
                document.querySelectorAll('.modal.active').forEach(modal => {
                    modal.classList.remove('active');
                });
                
                // Close context menu
                this.closeContextMenu();
                
                // Close utility info panel
                this.closeUtilityInfo();
                
                // Hide FAB menu
                this.hideFabMenu();
                
                // Cancel drawing if active
                if (this.isDrawing) {
                    this.cancelDrawing();
                }
            }
            
            /**
             * Edit selected element
             */
            editSelectedElement() {
                if (!this.selectedElement) return;
                
                // Close context menu
                this.closeContextMenu();
                
                if (this.selectedElement.type === 'utility') {
                    // Open discovery modal with utility data
                    this.editUtility(this.selectedElement.data);
                } else if (this.selectedElement.type === 'structure') {
                    // Open structure modal with structure data
                    this.editStructure(this.selectedElement.data);
                }
            }
            
            /**
             * Edit utility geometry
             */
            editGeometry() {
                // Not implemented yet
                this.showToast('Geometry editing coming soon', 'info');
                this.closeContextMenu();
            }
            
            /**
             * Connect selected element to another utility
             */
            connectSelectedElement() {
                // Not implemented yet
                this.showToast('Connection feature coming soon', 'info');
                this.closeContextMenu();
            }
            
            /**
             * Delete selected element
             */
            deleteSelectedElement() {
                if (!this.selectedElement) return;
                
                // Close context menu
                this.closeContextMenu();
                
                // Close utility info panel
                this.closeUtilityInfo();
                
                // Based on element type
                if (this.selectedElement.type === 'utility') {
                    const utility = this.selectedElement.data;
                    const utilityId = utility.id;
                    
                    // Remove from map
                    if (utility.line) {
                        this.utilityLayers[utility.type].removeLayer(utility.line);
                    }
                    
                    if (utility.marker) {
                        this.utilityLayers[utility.type].removeLayer(utility.marker);
                    }
                    
                    // Remove from data model
                    this.data.deleteUtility(utilityId);
                    
                    // Add to undo stack
                    this.undoManager.addAction({
                        type: 'delete-utility',
                        utilityId: utilityId,
                        utilityData: utility
                    });
                    
                    // Save data
                    this.saveData();
                    
                    // Show success message
                    this.showToast(`Deleted ${utility.type} ${utility.lineType}`, 'success');
                    
                } else if (this.selectedElement.type === 'structure') {
                    const structure = this.selectedElement.data;
                    const structureId = structure.id;
                    
                    // Remove from map
                    if (structure.marker) {
                        this.markerLayer.removeLayer(structure.marker);
                    }
                    
                    // Remove from data model
                    this.data.deleteStructure(structureId);
                    
                    // Add to undo stack
                    this.undoManager.addAction({
                        type: 'delete-structure',
                        structureId: structureId,
                        structureData: structure
                    });
                    
                    // Save data
                    this.saveData();
                    
                    // Show success message
                    this.showToast(`Deleted ${structure.utilityType} ${structure.type}`, 'success');
                    
                } else if (this.selectedElement.type === 'measurement') {
                    const measurement = this.selectedElement.data;
                    const measurementId = measurement.id;
                    
                    // Remove from map
                    if (measurement.line) {
                        this.measurementLayer.removeLayer(measurement.line);
                    }
                    
                    if (measurement.marker) {
                        this.measurementLayer.removeLayer(measurement.marker);
                    }
                    
                    // Remove from data model
                    const index = this.data.measurements.findIndex(m => m.id === measurementId);
                    if (index !== -1) {
                        this.data.measurements.splice(index, 1);
                    }
                    
                    // Add to undo stack
                    this.undoManager.addAction({
                        type: 'delete-measurement',
                        measurementId: measurementId,
                        measurementData: measurement
                    });
                    
                    // Save data
                    this.saveData();
                    
                    // Show success message
                    this.showToast('Deleted measurement', 'success');
                }
                
                // Clear selected element
                this.clearSelectedElement();
            }
            
            /**
             * Edit a utility
             * @param {Object} utility - Utility to edit
             */
            editUtility(utility) {
                // Not implemented yet - would open discovery modal with pre-filled data
                this.showToast('Utility editing coming soon', 'info');
            }
            
            /**
             * Edit a structure
             * @param {Object} structure - Structure to edit
             */
            editStructure(structure) {
                // Not implemented yet - would open structure modal with pre-filled data
                this.showToast('Structure editing coming soon', 'info');
            }
            
            /**
             * Clear selected element
             */
            clearSelectedElement() {
                // Remove highlight from previously selected element
                if (this.selectedElement) {
                    if (this.selectedElement.type === 'utility') {
                        const line = this.selectedElement.element;
                        if (line instanceof L.Polyline) {
                            line.getElement()?.classList.remove('selected');
                        } else if (line instanceof L.Marker) {
                            line.getElement()?.classList.remove('selected');
                        }
                    } else if (this.selectedElement.type === 'structure') {
                        const marker = this.selectedElement.element;
                        marker.getElement()?.classList.remove('selected');
                    } else if (this.selectedElement.type === 'measurement') {
                        const line = this.selectedElement.element;
                        line.getElement()?.classList.remove('selected');
                    }
                }
                
                this.selectedElement = null;
            }
            
            /**
             * Undo last action
             */
            undoLastAction() {
                const action = this.undoManager.undo();
                
                if (!action) {
                    this.showToast('Nothing to undo', 'info');
                    return;
                }
                
                // Handle different action types
                if (action.type === 'add-utility') {
                    const utility = this.data.findUtility(action.utilityId);
                    
                    if (utility) {
                        // Remove from map
                        if (utility.line) {
                            this.utilityLayers[utility.type].removeLayer(utility.line);
                        }
                        
                        if (utility.marker) {
                            this.utilityLayers[utility.type].removeLayer(utility.marker);
                        }
                        
                        // Remove from data model
                        this.data.deleteUtility(action.utilityId);
                        
                        // Show message
                        this.showToast('Undid add utility', 'info');
                    }
                } else if (action.type === 'add-structure') {
                    const structure = this.data.findStructure(action.structureId);
                    
                    if (structure) {
                        // Remove from map
                        if (structure.marker) {
                            this.markerLayer.removeLayer(structure.marker);
                        }
                        
                        // Remove from data model
                        this.data.deleteStructure(action.structureId);
                        
                        // Show message
                        this.showToast('Undid add structure', 'info');
                    }
                } else if (action.type === 'add-measurement') {
                    const measurement = this.data.measurements.find(m => m.id === action.measurementId);
                    
                    if (measurement) {
                        // Remove from map
                        if (measurement.line) {
                            this.measurementLayer.removeLayer(measurement.line);
                        }
                        
                        if (measurement.marker) {
                            this.measurementLayer.removeLayer(measurement.marker);
                        }
                        
                        // Remove from data model
                        const index = this.data.measurements.findIndex(m => m.id === action.measurementId);
                        if (index !== -1) {
                            this.data.measurements.splice(index, 1);
                        }
                        
                        // Show message
                        this.showToast('Undid add measurement', 'info');
                    }
                } else if (action.type === 'delete-utility') {
                    // Re-add the utility
                    const id = this.data.addUtility(action.utilityData);
                    const utility = this.data.findUtility(id);
                    
                    // Render on map
                    this.renderUtility(utility);
                    
                    // Show message
                    this.showToast('Undid delete utility', 'info');
                } else if (action.type === 'delete-structure') {
                    // Re-add the structure
                    const id = this.data.addStructure(action.structureData);
                    const structure = this.data.findStructure(id);
                    
                    // Render on map
                    this.renderStructure(structure);
                    
                    // Show message
                    this.showToast('Undid delete structure', 'info');
                } else if (action.type === 'delete-measurement') {
                    // Re-add the measurement
                    this.data.measurements.push(action.measurementData);
                    
                    // Render on map
                    this.renderMeasurement(action.measurementData);
                    
                    // Show message
                    this.showToast('Undid delete measurement', 'info');
                }
                
                // Save data
                this.saveData();
            }
            
            /**
             * Export all data as JSON file
             */
            exportData() {
                try {
                    // Get data to export
                    const data = this.data.exportData();
                    
                    // Convert to JSON string
                    const jsonData = JSON.stringify(data, null, 2);
                    
                    // Create download link
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    
                    // Set filename with date
                    const date = new Date().toISOString().slice(0, 10);
                    a.download = `cac-utility-data-${date}.json`;
                    a.href = url;
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    
                    // Clean up
                    URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    // Show success message
                    this.showToast('Data exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting data:', error);
                    this.showToast('Error exporting data', 'error');
                }
            }
            
            /**
             * Import data from JSON file
             */
            importData() {
                // Create file input
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';
                
                // Handle file selection
                input.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    // Show loading
                    this.showModal('loading-modal');
                    document.getElementById('loading-text').textContent = 'Importing data...';
                    
                    // Read file
                    const reader = new FileReader();
                    
                    reader.onload = (e) => {
                        try {
                            // Parse JSON
                            const data = JSON.parse(e.target.result);
                            
                            // Validate data
                            if (!data || !data.metadata || !data.utilities) {
                                throw new Error('Invalid data format');
                            }
                            
                            // Clear existing data
                            this.clearAllData(false);
                            
                            // Import data
                            this.data.importData(data);
                            
                            // Render on map
                            this.renderAllUtilities();
                            
                            // Save data
                            this.saveData();
                            
                            // Hide loading
                            this.closeModal('loading-modal');
                            
                            // Show success message
                            this.showToast('Data imported successfully', 'success');
                        } catch (error) {
                            console.error('Error importing data:', error);
                            this.closeModal('loading-modal');
                            this.showToast('Error importing data: ' + error.message, 'error');
                        }
                    };
                    
                    reader.onerror = () => {
                        this.closeModal('loading-modal');
                        this.showToast('Error reading file', 'error');
                    };
                    
                    reader.readAsText(file);
                });
                
                // Trigger file dialog
                input.click();
            }
            
            /**
             * Confirm before clearing all data
             */
            confirmClearData() {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    this.clearAllData();
                }
            }
            
            /**
             * Clear all data
             * @param {boolean} showMessage - Whether to show a confirmation message
             */
            clearAllData(showMessage = true) {
                // Clear data model
                this.data.clearAll();
                
                // Clear map layers
                for (const type in this.utilityLayers) {
                    this.utilityLayers[type].clearLayers();
                }
                
                this.markerLayer.clearLayers();
                this.measurementLayer.clearLayers();
                
                // Clear undo stack
                this.undoManager.clear();
                
                // Save empty data
                this.saveData();
                
                // Show message
                if (showMessage) {
                    this.showToast('All data cleared', 'success');
                }
            }
            
            /**
             * Render all utilities from data model to map
             */
            renderAllUtilities() {
                // Clear map layers
                for (const type in this.utilityLayers) {
                    this.utilityLayers[type].clearLayers();
                }
                
                this.markerLayer.clearLayers();
                this.measurementLayer.clearLayers();
                
                // Render utilities
                for (const type in this.data.utilities) {
                    this.data.utilities[type].forEach(utility => {
                        this.renderUtility(utility);
                    });
                }
                
                // Render structures
                this.data.structures.forEach(structure => {
                    this.renderStructure(structure);
                });
                
                // Render measurements
                this.data.measurements.forEach(measurement => {
                    this.renderMeasurement(measurement);
                });
            }
            
            /**
             * Render a utility on the map
             * @param {Object} utility - Utility data
             */
            renderUtility(utility) {
                if (!utility || !utility.points || utility.points.length < 2) {
                    console.error('Invalid utility data:', utility);
                    return;
                }
                
                // Get target layer
                const layer = this.utilityLayers[utility.type];
                if (!layer) {
                    console.error('Invalid utility type:', utility.type);
                    return;
                }
                
                // Get utility color
                const color = this.getUtilityColor(utility.type);
                
                // Create line
                const line = L.polyline(utility.points, {
                    color: color,
                    weight: utility.lineType === 'main' ? 5 : 3,
                    opacity: 1,
                    lineJoin: 'round',
                    lineCap: 'round'
                }).addTo(layer);
                
                // Store reference to utility data
                line.utilityData = utility;
                utility.line = line;
                
                // Create start marker
                const startPoint = utility.points[0];
                const markerIcon = this.createUtilityMarker(utility.type, utility.lineType);
                
                const marker = L.marker(startPoint, {
                    icon: markerIcon,
                    zIndexOffset: 100
                }).addTo(layer);
                
                // Store references
                marker.utilityData = utility;
                utility.marker = marker;
                marker.utilityLine = line;
                
                // Add events
                line.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    this.selectUtility(utility);
                });
                
                marker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    this.selectUtility(utility);
                });
            }
            
            /**
             * Render a structure on the map
             * @param {Object} structure - Structure data
             */
            renderStructure(structure) {
                if (!structure || !structure.location) {
                    console.error('Invalid structure data:', structure);
                    return;
                }
                
                // Create structure marker icon
                const markerIcon = this.createStructureMarker(structure.type, structure.utilityType);
                
                // Create marker
                const marker = L.marker(structure.location, {
                    icon: markerIcon,
                    zIndexOffset: 100
                }).addTo(this.markerLayer);
                
                // Store references
                marker.structureData = structure;
                structure.marker = marker;
                
                // Add events
                marker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    this.selectStructure(structure);
                });
            }
            
            /**
             * Render a measurement on the map
             * @param {Object} measurement - Measurement data
             */
            renderMeasurement(measurement) {
                if (!measurement || !measurement.points || measurement.points.length < 2) {
                    console.error('Invalid measurement data:', measurement);
                    return;
                }
                
                // Create line
                const line = L.polyline(measurement.points, {
                    color: '#673ab7', // Purple for measurements
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '5, 5'
                }).addTo(this.measurementLayer);
                
                // Store references
                line.measurementData = measurement;
                measurement.line = line;
                
                // Calculate midpoint for label
                const midIndex = Math.floor(measurement.points.length / 2);
                const midPoint = measurement.points[midIndex];
                
                // Create label icon
                const labelIcon = L.divIcon({
                    html: `<div class="measurement-label">${measurement.value} ${measurement.unit}</div>`,
                    className: '',
                    iconSize: [80, 30],
                    iconAnchor: [40, 15]
                });
                
                // Create label marker
                const labelMarker = L.marker(midPoint, {
                    icon: labelIcon,
                    zIndexOffset: 90,
                    interactive: false
                }).addTo(this.measurementLayer);
                
                // Store reference
                measurement.marker = labelMarker;
                
                // Add events
                line.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    this.selectMeasurement(measurement);
                });
            }
            
            /**
             * Select a utility
             * @param {Object} utility - Utility data
             */
            selectUtility(utility) {
                // Clear previous selection
                this.clearSelectedElement();
                
                // Set as selected element
                this.selectedElement = {
                    type: 'utility',
                    element: utility.line,
                    data: utility
                };
                
                // Add selected class
                if (utility.line) {
                    utility.line.getElement()?.classList.add('selected');
                }
                
                // Show utility info panel
                this.showUtilityInfo(utility);
            }
            
            /**
             * Select a structure
             * @param {Object} structure - Structure data
             */
            selectStructure(structure) {
                // Clear previous selection
                this.clearSelectedElement();
                
                // Set as selected element
                this.selectedElement = {
                    type: 'structure',
                    element: structure.marker,
                    data: structure
                };
                
                // Add selected class
                structure.marker.getElement()?.classList.add('selected');
                
                // Show structure info
                // Not implemented yet - would show structure info panel
                this.showToast('Structure info panel coming soon', 'info');
            }
            
            /**
             * Select a measurement
             * @param {Object} measurement - Measurement data
             */
            selectMeasurement(measurement) {
                // Clear previous selection
                this.clearSelectedElement();
                
                // Set as selected element
                this.selectedElement = {
                    type: 'measurement',
                    element: measurement.line,
                    data: measurement
                };
                
                // Add selected class
                measurement.line.getElement()?.classList.add('selected');
                
                // Show measurement info
                // Not implemented yet - would show measurement info
                this.showToast(`Measurement: ${measurement.value} ${measurement.unit}`, 'info');
            }
            
            /**
             * Search for a location
             */
            searchLocation() {
                const address = document.getElementById('address-input').value.trim();
                
                if (!address) {
                    this.showToast('Please enter an address', 'warning');
                    return;
                }
                
                // Show loading
                this.showModal('loading-modal');
                document.getElementById('loading-text').textContent = 'Searching...';
                
                // Use Nominatim for geocoding
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
                
                fetch(url)
                    .then(response => response.json())
                    .then(data => {
                        if (data && data.length > 0) {
                            const result = data[0];
                            const lat = parseFloat(result.lat);
                            const lon = parseFloat(result.lon);
                            
                            // Center map on result
                            this.map.setView([lat, lon], 19);
                            
                            // Close modal
                            this.closeModal('loading-modal');
                            this.closeModal('location-modal');
                            
                            // Show success message
                            this.showToast(`Found: ${result.display_name}`, 'success');
                        } else {
                            this.closeModal('loading-modal');
                            this.showToast('No results found', 'warning');
                        }
                    })
                    .catch(error => {
                        console.error('Error searching location:', error);
                        this.closeModal('loading-modal');
                        this.showToast('Error searching location', 'error');
                    });
            }
            
            /**
             * Show a toast notification
             * @param {string} message - Message to show
             * @param {string} type - Toast type ('info', 'success', 'warning', 'error')
             */
            showToast(message, type = 'info') {
                const container = document.getElementById('toast-container');
                
                // Create toast element
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                
                // Set icon based on type
                let icon = 'info-circle';
                if (type === 'success') icon = 'check-circle';
                if (type === 'warning') icon = 'exclamation-triangle';
                if (type === 'error') icon = 'exclamation-circle';
                
                // Set toast content
                toast.innerHTML = `
                    <i class="fas fa-${icon}"></i>
                    <span>${message}</span>
                `;
                
                // Add to container
                container.appendChild(toast);
                
                // Show toast after a small delay
                setTimeout(() => {
                    toast.classList.add('active');
                }, 10);
                
                // Hide and remove toast after 3 seconds
                setTimeout(() => {
                    toast.classList.remove('active');
                    
                    // Remove from DOM after animation
                    setTimeout(() => {
                        container.removeChild(toast);
                    }, 300);
                }, 3000);
            }
            
            /**
             * Update a segmented control
             * @param {string} controlId - Control ID
             * @param {string} value - Selected value
             */
            updateSegmentedControl(controlId, value) {
                const control = document.getElementById(controlId);
                if (!control) return;
                
                // Find all options
                const options = control.querySelectorAll('.segmented-option');
                const slider = control.querySelector('.segmented-slider');
                
                // Update active class
                options.forEach(option => {
                    if (option.getAttribute('data-value') === value) {
                        option.classList.add('active');
                        
                        // Update slider position and width
                        if (slider) {
                            slider.style.width = `${option.offsetWidth}px`;
                            slider.style.transform = `translateX(${option.offsetLeft}px)`;
                        }
                    } else {
                        option.classList.remove('active');
                    }
                });
            }
            
            /**
             * Set active toolbar button
             * @param {string} type - Button type
             */
            setActiveToolbarButton(type) {
                // Clear current active button
                this.clearActiveToolbarButton();
                
                // Set active class based on type
                if (type === 'main') {
                    document.getElementById('draw-main-btn')?.classList.add('active');
                } else if (type === 'service') {
                    document.getElementById('draw-service-btn')?.classList.add('active');
                } else if (type === 'structure') {
                    document.getElementById('add-structure-btn')?.classList.add('active');
                } else if (type === 'measurement') {
                    document.getElementById('measure-btn')?.classList.add('active');
                }
            }
            
            /**
             * Clear active toolbar button
             */
            clearActiveToolbarButton() {
                document.querySelectorAll('.toolbar-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
            }
            
            /**
             * Create utility marker icon
             * @param {string} type - Utility type
             * @param {string} lineType - Line type
             * @returns {L.DivIcon} Marker icon
             */
            createUtilityMarker(type, lineType) {
                // Get utility icon
                const icon = this.getUtilityIcon(type);
                
                // Create HTML for marker
                const html = `
                    <div class="utility-marker ${type}-marker">
                        <i class="fas ${icon}"></i>
                        ${lineType === 'main' ? '<span class="main-indicator">M</span>' : ''}
                    </div>
                `;
                
                // Create div icon
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
            }
            
            /**
             * Create structure marker icon
             * @param {string} structureType - Structure type
             * @param {string} utilityType - Utility type
             * @returns {L.DivIcon} Marker icon
             */
            createStructureMarker(structureType, utilityType) {
                // Get structure icon
                const icon = this.getStructureIcon(structureType);
                
                // Create HTML for marker
                const html = `
                    <div class="structure-marker ${utilityType}">
                        <i class="fas ${icon}"></i>
                    </div>
                `;
                
                // Create div icon
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
            }
            
            /**
             * Get utility icon class
             * @param {string} type - Utility type
             * @returns {string} Icon class
             */
            getUtilityIcon(type) {
                switch (type) {
                    case 'water': return 'fa-tint';
                    case 'gas': return 'fa-fire';
                    case 'electric': return 'fa-bolt';
                    case 'sewer': return 'fa-toilet';
                    case 'telecom': return 'fa-phone';
                    default: return 'fa-question';
                }
            }
            
            /**
             * Get structure icon class
             * @param {string} type - Structure type
             * @returns {string} Icon class
             */
            getStructureIcon(type) {
                switch (type) {
                    case 'valve': return 'fa-circle-notch';
                    case 'meter': return 'fa-tachometer-alt';
                    case 'hydrant': return 'fa-fire-extinguisher';
                    case 'manhole': return 'fa-circle';
                    case 'catchbasin': return 'fa-water';
                    case 'cleanout': return 'fa-trash-restore';
                    case 'junction': return 'fa-code-branch';
                    case 'transformer': return 'fa-box';
                    case 'regulator': return 'fa-sliders-h';
                    case 'handhole': return 'fa-hand-paper';
                    case 'pole': return 'fa-map-pin';
                    default: return 'fa-question';
                }
            }
            
            /**
             * Get utility color
             * @param {string} type - Utility type
             * @returns {string} Color hex code
             */
            getUtilityColor(type) {
                switch (type) {
                    case 'water': return '#03a9f4';
                    case 'gas': return '#ff9800';
                    case 'electric': return '#ffeb3b';
                    case 'sewer': return '#795548';
                    case 'telecom': return '#9c27b0';
                    default: return '#9e9e9e';
                }
            }
        }

        // ===== APPLICATION INITIALIZATION =====
        // Initialize application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Create a global variable for the app
            window.utilityApp = new UtilityTrackerApp();
            
            // Add measurement style to stylesheet
            const style = document.createElement('style');
            style.textContent = `
                .measurement-label {
                    background-color: #673ab7;
                    color: white;
                    padding: 3px 8px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 500;
                    text-align: center;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                    white-space: nowrap;
                }
                
                .switch {
                    position: relative;
                    display: inline-block;
                    width: 46px;
                    height: 24px;
                }
                
                .switch input {
                    opacity: 0;
                    width: 0;
                    height: 0;
                }
                
                .slider {
                    position: absolute;
                    cursor: pointer;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background-color: #ccc;
                    transition: .3s;
                    border-radius: 34px;
                }
                
                .slider:before {
                    position: absolute;
                    content: "";
                    height: 18px;
                    width: 18px;
                    left: 3px;
                    bottom: 3px;
                    background-color: white;
                    transition: .3s;
                    border-radius: 50%;
                }
                
                input:checked + .slider {
                    background-color: var(--primary-color);
                }
                
                input:checked + .slider:before {
                    transform: translateX(22px);
                }
                
                .main-indicator {
                    position: absolute;
                    bottom: -2px;
                    right: -2px;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background-color: white;
                    color: var(--primary-color);
                    font-size: 10px;
                    font-weight: bold;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
                }
            `;
            document.head.appendChild(style);
            
            // Detect features and update UI accordingly
            if ('vibrate' in navigator) {
                // Enable haptic feedback for touch devices
                const buttons = document.querySelectorAll('.btn, .toolbar-btn, .fab, .mode-option');
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        navigator.vibrate(10); // Short vibration
                    });
                });
            }
        });

        // Handle page visibility changes to conserve resources
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, save data
                if (window.utilityApp) {
                    window.utilityApp.saveData();
                }
            }
        });

        // Handle service worker registration for PWA support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(
                    (registration) => {
                        console.log('ServiceWorker registration successful');
                    },
                    (error) => {
                        console.log('ServiceWorker registration failed: ', error);
                    }
                );
            });
        }
    </script>
</body>
</html>
