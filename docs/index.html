<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC Pocket - Drainage & Utility Tracker</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <style>
        :root {
            --primary-color: #2196f3;
            --secondary-color: #ff9800;
            --accent-color: #f44336;
            --success-color: #4caf50;
            --dark-color: #212121;
            --light-color: #f5f5f5;
            --text-color: #212121;
            --gray-color: #9e9e9e;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            --rounded: 16px;
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            
            /* Updated Drainage Colors */
            --drainage-color: #2196f3;
            --drainage-highlight: #64b5f6;
            --pitch-color: #FFC107;
            --pitch-accent: #FFD54F;
            --drainage-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);
            
            /* Utility type colors */
            --water-color: #03a9f4;
            --gas-color: #ff9800;
            --electric-color: #ffeb3b;
            --sewer-color: #795548;
            --telecom-color: #9c27b0;
            
            /* Mode colors */
            --drainage-color: #2196f3;
            --utility-color: #673ab7;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            color: var(--text-color);
            background-color: var(--light-color);
            overflow-x: hidden;
            overflow-y: auto;
        }

        .app-container {
            position: relative;
            height: 100dvh;
            width: 100vw;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* Mode Toggle */
        .mode-toggle {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background-color: var(--panel-bg);
            border-radius: 24px;
            box-shadow: var(--shadow);
            display: flex;
            overflow: hidden;
        }

        .mode-btn {
            padding: 12px 20px;
            border: none;
            background: none;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            color: var(--dark-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mode-btn.active {
            color: white;
        }

        .mode-btn.drainage.active {
            background-color: var(--drainage-color);
        }

        .mode-btn.utility.active {
            background-color: var(--utility-color);
        }

        /* Top Action Bar */
        .action-bar {
            position: absolute;
            top: 12px;
            left: 10px;
            right: 10px;
            z-index: 999;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        .action-group {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .action-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            color: var(--dark-color);
        }

        .action-button i {
            font-size: 20px;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Main Toolbar */
        .toolbar {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 12px;
            background-color: var(--panel-bg);
            border-radius: 30px;
            padding: 8px;
            box-shadow: var(--shadow);
            max-width: 95%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .toolbar-button {
            min-width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: var(--transition);
            color: var(--dark-color);
            font-size: 11px;
            gap: 4px;
            flex-shrink: 0;
            padding: 0 8px;
        }

        .toolbar-button i {
            font-size: 20px;
        }

        .toolbar-button:active {
            transform: scale(0.95);
        }

        .toolbar-button.active {
            border-color: var(--primary-color);
            background-color: rgba(33, 150, 243, 0.12);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.25);
            transform: translateY(-2px);
        }

        /* Utility type specific buttons */
        .toolbar-button.water-btn.active {
            background-color: rgba(3, 169, 244, 0.1);
            border-color: var(--water-color);
        }
        
        .toolbar-button.gas-btn.active {
            background-color: rgba(255, 152, 0, 0.1);
            border-color: var(--gas-color);
        }
        
        .toolbar-button.electric-btn.active {
            background-color: rgba(255, 235, 59, 0.1);
            border-color: var(--electric-color);
        }
        
        .toolbar-button.sewer-btn.active {
            background-color: rgba(121, 85, 72, 0.1);
            border-color: var(--sewer-color);
        }
        
        .toolbar-button.telecom-btn.active {
            background-color: rgba(156, 39, 176, 0.1);
            border-color: var(--telecom-color);
        }

        /* Side Controls */
        .side-controls {
            position: fixed;
            right: 16px;
            bottom: 100px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: var(--transition);
            color: var(--dark-color);
        }

        .control-button:active {
            transform: scale(0.95);
        }

        /* Panels */
        .panel {
            position: absolute;
            z-index: 1500;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            overflow: hidden;
            transition: var(--transition);
            max-height: 80vh;
            width: 90%;
            max-width: 360px;
            display: none;
        }

        .panel-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .panel-title {
            font-weight: 600;
            font-size: 18px;
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--dark-color);
        }

        .panel-content {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(80vh - 60px);
        }

        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 15px;
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--dark-color);
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.1);
            font-size: 16px;
            transition: var(--transition);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        select.form-control {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23212121' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .radio-group {
            display: flex;
            gap: 16px;
            margin-top: 8px;
        }

        .radio-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 24px;
        }

        .btn {
            padding: 12px 20px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            font-size: 15px;
        }

        .btn-cancel {
            background-color: var(--light-color);
            color: var(--dark-color);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            flex: 1;
        }

        .btn:active {
            transform: scale(0.98);
        }

        /* Map Styling */
        .catch-basin-icon {
            width: 44px;
            height: 44px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            background-color: var(--drainage-color);
            border-radius: 50%;
            box-shadow: var(--drainage-shadow);
            border: 3px solid white;
            font-size: 22px;
            transform: translateZ(0);
            transition: transform 0.2s ease;
        }

        .catch-basin-icon:hover {
            transform: scale(1.05) translateZ(0);
        }

        .utility-marker {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
            font-size: 16px;
            position: relative;
        }

        .utility-marker .main-indicator {
            position: absolute;
            bottom: -2px;
            right: -2px;
            background-color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            color: var(--dark-color);
        }

        .utility-line {
            stroke-width: 4;
        }

        .utility-line.main {
            stroke-width: 6;
        }

        .curb-pitch-line {
            stroke: var(--pitch-color);
            stroke-width: 5;
            stroke-linecap: round;
            filter: drop-shadow(0 2px 4px rgba(255, 193, 7, 0.3));
        }

        .curb-pitch-arrow {
            filter: drop-shadow(0 1px 3px rgba(0,0,0,0.2));
        }

        .curb-pitch-label {
            font-weight: bold;
            text-shadow: 0px 1px 2px rgba(255,255,255,0.8);
            background-color: white;
            border-radius: 50%;
            box-shadow: var(--shadow);
            padding: 3px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .curb-available {
            stroke: rgba(3, 169, 244, 0.6);
            stroke-width: 10;
            stroke-dasharray: 12, 6;
            filter: drop-shadow(0 0 4px rgba(3, 169, 244, 0.4));
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            display: none;
        }

        .modal-container {
            background: rgba(255, 255, 255, 0.97);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.7);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .modal-title {
            font-weight: 600;
            font-size: 18px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--dark-color);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid rgba(0,0,0,0.05);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Direction Selector */
        .direction-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .direction-indicator {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background-color: #f5f5f5;
            position: relative;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .direction-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            margin-top: -25px;
            margin-left: -25px;
            font-size: 50px;
            color: var(--drainage-color);
            transform-origin: center;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
        }

        .direction-controls {
            display: flex;
            gap: 16px;
            align-items: center;
            justify-content: center;
        }

        .direction-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: #f0f0f0;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            cursor: pointer;
            color: var(--dark-color);
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .direction-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .direction-value {
            font-weight: 600;
            font-size: 18px;
            min-width: 80px;
            text-align: center;
            background-color: white;
            padding: 8px 12px;
            border-radius: 20px;
            box-shadow: var(--shadow);
        }

        /* Utilities Info Card */
        .utility-info-card {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 1500;
            width: 280px;
            max-width: 90vw;
            display: none;
        }

        .utility-info-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding-bottom: 8px;
        }

        .utility-info-title {
            font-weight: 600;
            font-size: 16px;
        }

        .utility-info-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }

        .utility-info-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .utility-info-row {
            display: flex;
            justify-content: space-between;
        }

        .utility-info-label {
            font-weight: 500;
            color: var(--gray-color);
        }

        .utility-info-value {
            font-weight: 500;
        }

        .utility-info-image {
            width: 100%;
            margin-top: 10px;
            border-radius: 8px;
            overflow: hidden;
        }

        .utility-info-image img {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }

        /* Connection Options */
        .connection-options {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        .connection-option {
            flex: 1;
            min-width: 100px;
            background-color: #f5f5f5;
            border-radius: 12px;
            padding: 18px 12px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .connection-option:hover {
            background-color: #e0e0e0;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .connection-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(33, 150, 243, 0.1);
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.25);
        }

        .connection-icon {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .connection-label {
            font-weight: 500;
            font-size: 15px;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--dark-color);
            color: white;
            border-radius: var(--rounded);
            padding: 12px 20px;
            z-index: 2000;
            box-shadow: var(--shadow);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            padding: 10px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 999;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--light-color);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            padding: 8px 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .context-menu-item {
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: var(--dark-color);
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item.danger {
            color: var(--accent-color);
        }

        .context-menu-item i {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .splash-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        /* iOS safe area support */
        @supports(padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: env(safe-area-inset-bottom);
            }
            .toolbar {
                bottom: calc(24px + env(safe-area-inset-bottom));
            }
        }

        /* Media queries for responsiveness */
        @media (max-width: 480px) {
            .mode-btn {
                padding: 10px 16px;
                font-size: 13px;
            }
            
            .toolbar-button {
                min-width: 50px;
                height: 50px;
                font-size: 10px;
            }
            
            .toolbar-button i {
                font-size: 18px;
            }
            
            .action-button {
                width: 42px;
                height: 42px;
            }
            
            .action-button i {
                font-size: 18px;
            }
        }
        
        /* Pitch Editor Styling */
        .pitch-input-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
        }
        
        .pitch-slider {
            flex: 1;
            margin-right: 10px;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
        }
        
        .pitch-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .pitch-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border: none;
        }
        
        .pitch-value-container {
            display: flex;
            align-items: center;
            min-width: 140px;
        }
        
        .pitch-adjust-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: #f0f0f0;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
            color: var(--dark-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: var(--transition);
        }
        
        .pitch-adjust-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .pitch-value {
            flex: 1;
            text-align: center;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-water"></i>
        </div>
        <div class="splash-title">CAC Pocket</div>
        <div class="splash-subtitle">Drainage & Utility Tracker</div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Map Element -->
        <div id="map"></div>
        
        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button class="mode-btn drainage active" id="drainage-mode">
                <i class="fas fa-water"></i> Drainage
            </button>
            <button class="mode-btn utility" id="utility-mode">
                <i class="fas fa-tools"></i> Utilities
            </button>
        </div>
        
        <!-- Top Action Bar -->
        <div class="action-bar">
            <div class="action-group">
                <button class="action-button" id="locate-btn" title="My Location">
                    <i class="fas fa-crosshairs"></i>
                </button>
                <button class="action-button" id="undo-btn" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            </div>
            <div class="action-group">
                <button class="action-button" id="layers-btn" title="Layers">
                    <i class="fas fa-layer-group"></i>
                </button>
                <button class="action-button" id="menu-btn" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </div>
        
        <!-- Drainage Mode Toolbar - Redesigned -->
        <div class="toolbar" id="drainage-toolbar">
            <button class="toolbar-button" id="add-basin-btn" title="Add Catch Basin">
                <i class="fas fa-drain"></i>
                <span>Basin</span>
            </button>
            <button class="toolbar-button" id="add-pitch-btn" title="Add Curb Pitch">
                <i class="fas fa-water"></i>
                <span>Pitch</span>
            </button>
            <button class="toolbar-button" id="edit-pitch-btn" title="Edit Pitch">
                <i class="fas fa-pencil-alt"></i>
                <span>Edit</span>
            </button>
            <button class="toolbar-button" id="analyze-drainage-btn" title="Analyze Drainage Patterns">
                <i class="fas fa-chart-area"></i>
                <span>Analyze</span>
            </button>
            <button class="toolbar-button" id="clear-drainage-btn" title="Clear All Drainage Items">
                <i class="fas fa-trash-alt"></i>
                <span>Clear</span>
            </button>
        </div>
        
        <!-- Utility Mode Toolbar -->
        <div class="toolbar" id="utility-toolbar" style="display: none;">
            <button class="toolbar-button" id="utility-found-btn">
                <i class="fas fa-search"></i>
                <span>Found</span>
            </button>
            <button class="toolbar-button" id="mapping-btn">
                <i class="fas fa-draw-polygon"></i>
                <span>Map</span>
            </button>
            <div class="toolbar-divider"></div>
            <button class="toolbar-button water-btn" id="water-btn">
                <i class="fas fa-tint"></i>
                <span>Water</span>
            </button>
            <button class="toolbar-button gas-btn" id="gas-btn">
                <i class="fas fa-fire"></i>
                <span>Gas</span>
            </button>
            <button class="toolbar-button electric-btn" id="electric-btn">
                <i class="fas fa-bolt"></i>
                <span>Electric</span>
            </button>
            <button class="toolbar-button sewer-btn" id="sewer-btn">
                <i class="fas fa-toilet"></i>
                <span>Sewer</span>
            </button>
            <button class="toolbar-button telecom-btn" id="telecom-btn">
                <i class="fas fa-phone"></i>
                <span>Telecom</span>
            </button>
            <button class="toolbar-button" id="clear-utilities-btn">
                <i class="fas fa-trash"></i>
                <span>Clear</span>
            </button>
        </div>
        
        <!-- Side Controls -->
        <div class="side-controls">
            <button class="control-button" id="zoom-in-btn" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="control-button" id="zoom-out-btn" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="control-button" id="cancel-drawing-btn" title="Cancel Drawing" style="display: none;">
                <i class="fas fa-times"></i>
            </button>
            <button class="control-button" id="finish-mapping-btn" title="Finish Mapping" style="display: none;">
                <i class="fas fa-check"></i>
            </button>
        </div>
        
        <!-- Status Bar -->
        <div class="status-bar">
            <i class="fas fa-info-circle"></i>
            <span id="status-text">Select a tool to begin</span>
        </div>
        
        <!-- Layers Panel -->
        <div class="panel" id="layers-panel" style="top: 70px; right: 10px;">
            <div class="panel-header">
                <div class="panel-title">Layers</div>
                <button class="panel-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-content">
                <!-- Drainage Mode Layers -->
                <div id="drainage-layers">
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--drainage-color);"></div>
                            <span>Catch Basins</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="basins-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--drainage-color);"></div>
                            <span>Curb Pitches</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="pitches-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: rgba(3, 169, 244, 0.4);"></div>
                            <span>Available Curbs</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="available-curbs-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: rgba(244, 67, 54, 0.3);"></div>
                            <span>Drainage Heatmap</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="heatmap-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Utility Mode Layers -->
                <div id="utility-layers" style="display: none;">
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--water-color);"></div>
                            <span>Water</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="water-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--gas-color);"></div>
                            <span>Gas</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="gas-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--electric-color);"></div>
                            <span>Electric</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="electric-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--sewer-color);"></div>
                            <span>Sewer</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="sewer-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <div class="color-indicator" style="background-color: var(--telecom-color);"></div>
                            <span>Telecom</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="telecom-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle" style="margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(0,0,0,0.1);">
                        <div class="toggle-label">
                            <i class="fas fa-water"></i>
                            <span>Show Mains</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="mains-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="layer-toggle">
                        <div class="toggle-label">
                            <i class="fas fa-home"></i>
                            <span>Show Services</span>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="services-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Menu Panel -->
        <div class="panel" id="menu-panel" style="top: 70px; right: 10px;">
            <div class="panel-header">
                <div class="panel-title">Menu</div>
                <button class="panel-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-content">
                <button class="btn btn-primary" style="margin-bottom: 12px;" id="search-location-btn">
                    <i class="fas fa-search"></i> Search Location
                </button>
                <button class="btn btn-primary" style="margin-bottom: 12px;" id="help-btn">
                    <i class="fas fa-question-circle"></i> Help
                </button>
                <button class="btn btn-primary" style="margin-bottom: 12px;" id="export-btn">
                    <i class="fas fa-file-export"></i> Export Data
                </button>
                <button class="btn btn-primary" id="import-btn">
                    <i class="fas fa-file-import"></i> Import Data
                </button>
            </div>
        </div>
        
        <!-- Add Pitch Modal - Redesigned -->
        <div class="modal" id="add-pitch-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Add Curb Pitch</div>
                    <button class="modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Flow Direction</label>
                        <div class="direction-selector">
                            <div class="direction-indicator">
                                <i class="fas fa-arrow-up direction-arrow" id="pitch-direction-arrow"></i>
                            </div>
                            <div class="direction-controls">
                                <button class="direction-button" id="rotate-left-btn">
                                    <i class="fas fa-undo"></i>
                                </button>
                                <div class="direction-value" id="direction-angle">0°</div>
                                <button class="direction-button" id="rotate-right-btn">
                                    <i class="fas fa-redo"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="pitch-percentage">Pitch Percentage</label>
                        <div class="direction-controls">
                            <button class="direction-button" id="decrease-pitch">
                                <i class="fas fa-minus"></i>
                            </button>
                            <div class="direction-value" id="pitch-value">2.0%</div>
                            <button class="direction-button" id="increase-pitch">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" id="cancel-pitch-btn">Cancel</button>
                    <button class="btn btn-primary" id="confirm-pitch-btn">Confirm</button>
                </div>
            </div>
        </div>
        
        <!-- Gap Pitch Modal - Redesigned -->
        <div class="modal" id="gap-pitch-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Fill Curb Gap</div>
                    <button class="modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Select Option</label>
                        <div class="connection-options">
                            <div class="connection-option" data-option="add-pitch">
                                <div class="connection-icon">
                                    <i class="fas fa-arrow-down"></i>
                                </div>
                                <div class="connection-label">Add Pitch</div>
                            </div>
                            <div class="connection-option" data-option="transition">
                                <div class="connection-icon">
                                    <i class="fas fa-exchange-alt"></i>
                                </div>
                                <div class="connection-label">Transition</div>
                            </div>
                            <div class="connection-option" data-option="highpoint">
                                <div class="connection-icon">
                                    <i class="fas fa-mountain"></i>
                                </div>
                                <div class="connection-label">Highpoint</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="add-pitch-option" style="display: none;">
                        <div class="form-group">
                            <label>Flow Direction</label>
                            <div class="direction-selector">
                                <div class="direction-indicator">
                                    <i class="fas fa-arrow-up direction-arrow" id="gap-direction-arrow"></i>
                                </div>
                                <div class="direction-controls">
                                    <button class="direction-button" id="gap-rotate-left-btn">
                                        <i class="fas fa-undo"></i>
                                    </button>
                                    <div class="direction-value" id="gap-direction-angle">0°</div>
                                    <button class="direction-button" id="gap-rotate-right-btn">
                                        <i class="fas fa-redo"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="gap-pitch-percentage">Pitch Percentage</label>
                            <div class="direction-controls">
                                <button class="direction-button" id="gap-decrease-pitch">
                                    <i class="fas fa-minus"></i>
                                </button>
                                <div class="direction-value" id="gap-pitch-value">2.0%</div>
                                <button class="direction-button" id="gap-increase-pitch">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" id="cancel-gap-btn">Cancel</button>
                    <button class="btn btn-primary" id="confirm-gap-btn">Confirm</button>
                </div>
            </div>
        </div>
        
                        <!-- Utility Found Modal -->
        <div class="modal" id="utility-found-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Utility Found</div>
                    <button class="modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="utility-type">Utility Type</label>
                        <select class="form-control" id="utility-type">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="sewer">Sewer</option>
                            <option value="telecom">Telecom</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Line Type</label>
                        <div class="radio-group">
                            <div class="radio-item">
                                <input type="radio" id="main-type" name="line-type" value="main">
                                <label for="main-type">Main</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="service-type" name="line-type" value="service" checked>
                                <label for="service-type">Service</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="utility-size">Size (inches)</label>
                        <input type="number" class="form-control" id="utility-size" value="4">
                    </div>
                    <div class="form-group">
                        <label for="utility-depth">Depth (feet)</label>
                        <input type="number" class="form-control" id="utility-depth" value="3">
                    </div>
                    <div class="form-group">
                        <label for="utility-media">Photo/Video (optional)</label>
                        <input type="file" class="form-control" id="utility-media" accept="image/*,video/*">
                    </div>
                    <div class="form-group">
                        <label>Utility Direction</label>
                        <div class="direction-selector">
                            <div class="direction-indicator">
                                <i class="fas fa-arrow-up direction-arrow" id="utility-direction-arrow"></i>
                            </div>
                            <div class="direction-controls">
                                <button class="direction-button" id="utility-rotate-left-btn">
                                    <i class="fas fa-undo"></i>
                                </button>
                                <div class="direction-value" id="utility-direction-angle">0°</div>
                                <button class="direction-button" id="utility-rotate-right-btn">
                                    <i class="fas fa-redo"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" id="cancel-utility-btn">Cancel</button>
                    <button class="btn btn-primary" id="confirm-utility-btn">Confirm</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Connection Modal -->
        <div class="modal" id="utility-connection-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Connect Utilities</div>
                    <button class="modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Connection Type</label>
                        <div class="connection-options">
                            <div class="connection-option" data-option="continuation">
                                <div class="connection-icon">
                                    <i class="fas fa-bezier-curve"></i>
                                </div>
                                <div class="connection-label">Continuation</div>
                            </div>
                            <div class="connection-option" data-option="offset">
                                <div class="connection-icon">
                                    <i class="fas fa-grip-lines"></i>
                                </div>
                                <div class="connection-label">Offset</div>
                            </div>
                            <div class="connection-option" data-option="separate">
                                <div class="connection-icon">
                                    <i class="fas fa-unlink"></i>
                                </div>
                                <div class="connection-label">Separate</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" id="cancel-connection-btn">Cancel</button>
                    <button class="btn btn-primary" id="confirm-connection-btn">Confirm</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Info Card -->
        <div class="utility-info-card" id="utility-info-card">
            <div class="utility-info-header">
                <div class="utility-info-title">Utility Information</div>
                <button class="utility-info-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="utility-info-content">
                <div class="utility-info-row">
                    <div class="utility-info-label">Type:</div>
                    <div class="utility-info-value" id="info-type">Water</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Line Type:</div>
                    <div class="utility-info-value" id="info-line-type">Service</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Size:</div>
                    <div class="utility-info-value" id="info-size">4 inches</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Depth:</div>
                    <div class="utility-info-value" id="info-depth">3 feet</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Direction:</div>
                    <div class="utility-info-value" id="info-direction">North</div>
                </div>
                <div class="utility-info-image" id="info-media-container">
                    <!-- Media will be inserted here if available -->
                </div>
            </div>
        </div>
        
        <!-- Location Search Modal -->
        <div class="modal" id="location-modal">
            <div class="modal-container">
                <div class="modal-header">
                    <div class="modal-title">Search Location</div>
                    <button class="modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="address-input">Enter Address or Intersection</label>
                        <input type="text" class="form-control" id="address-input" placeholder="Example: 123 Main St, Brooklyn, NY">
                    </div>
                    <div class="form-group">
                        <label>Borough</label>
                        <div class="connection-options">
                            <div class="connection-option" data-borough="Brooklyn">
                                <div class="connection-label">Brooklyn</div>
                            </div>
                            <div class="connection-option" data-borough="Queens">
                                <div class="connection-label">Queens</div>
                            </div>
                            <div class="connection-option" data-borough="Manhattan">
                                <div class="connection-label">Manhattan</div>
                            </div>
                            <div class="connection-option" data-borough="Bronx">
                                <div class="connection-label">Bronx</div>
                            </div>
                            <div class="connection-option" data-borough="Staten Island">
                                <div class="connection-label">Staten Island</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" id="use-current-location-btn">Use My Location</button>
                    <button class="btn btn-primary" id="search-address-btn">Search</button>
                </div>
            </div>
        </div>
        
        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="edit-item">
                <i class="fas fa-edit"></i>
                <span>Edit</span>
            </div>
            <div class="context-menu-item" id="reverse-direction">
                <i class="fas fa-exchange-alt"></i>
                <span>Reverse Direction</span>
            </div>
            <div class="context-menu-item danger" id="delete-item">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>
        
        <!-- Notification -->
        <div class="notification" id="notification">
            <i class="fas fa-info-circle"></i>
            <span id="notification-text">Notification message</span>
        </div>
        
        <!-- Loading Overlay -->
        <div class="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
    
    <script>
        // Add the utility workflow overlay function right before the initApp function
        // Function to add the utility workflow overlay to the HTML
        function addUtilityWorkflowOverlay() {
            // Create the utility workflow overlay
            const overlayHTML = `
                <!-- Utility Workflow Modal -->
                <div class="modal" id="utility-workflow-modal">
                    <div class="modal-container">
                        <div class="modal-header">
                            <div class="modal-title">Select Utility Action</div>
                            <button class="modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="connection-options">
                                <div class="connection-option" data-option="map-utility">
                                    <div class="connection-icon">
                                        <i class="fas fa-route"></i>
                                    </div>
                                    <div class="connection-label">Map Utility</div>
                                </div>
                                <div class="connection-option" data-option="found-utility">
                                    <div class="connection-icon">
                                        <i class="fas fa-search"></i>
                                    </div>
                                    <div class="connection-label">Found Utility</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Utility Type Selection Modal -->
                <div class="modal" id="utility-type-modal">
                    <div class="modal-container">
                        <div class="modal-header">
                            <div class="modal-title">Select Utility Type</div>
                            <button class="modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label>Line Type</label>
                                <div class="connection-options">
                                    <div class="connection-option" data-type="main">
                                        <div class="connection-icon">
                                            <i class="fas fa-project-diagram"></i>
                                        </div>
                                        <div class="connection-label">Main</div>
                                    </div>
                                    <div class="connection-option" data-type="service">
                                        <div class="connection-icon">
                                            <i class="fas fa-home"></i>
                                        </div>
                                        <div class="connection-label">Service</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Main Tap Connection Modal -->
                <div class="modal" id="tap-main-modal">
                    <div class="modal-container">
                        <div class="modal-header">
                            <div class="modal-title">Tap Main Line?</div>
                            <button class="modal-close">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="modal-body">
                            <p>Do you want to connect this service to the main line?</p>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-cancel" id="cancel-tap-btn">No, Keep Separate</button>
                            <button class="btn btn-primary" id="confirm-tap-btn">Yes, Tap Main</button>
                        </div>
                    </div>
                </div>
            `;

            // Insert the HTML before the location-modal
            const locationModal = document.getElementById('location-modal');
            locationModal.insertAdjacentHTML('beforebegin', overlayHTML);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Wait for splash screen with a minimum timeout but also check for resources
            let resourcesLoaded = false;
            
            // Add additional initialization for utility components
            window.addEventListener('load', function() {
                // Initialize the utility connection modal
                updateUtilityConnectionModal();
                
                // Existing code for resources loaded
                resourcesLoaded = true;
                trySplashScreenDismiss();
            });
            
            // Set minimum timeout for splash screen
            setTimeout(function() {
                if (resourcesLoaded) {
                    trySplashScreenDismiss();
                } else {
                    // If resources aren't loaded yet, we'll wait for the load event
                    // but set a maximum timeout anyway
                    setTimeout(trySplashScreenDismiss, 1000);
                }
            }, 1000);
            
            function trySplashScreenDismiss() {
                const splashScreen = document.querySelector('.splash-screen');
                if (splashScreen.style.opacity !== '0') {
                    splashScreen.style.opacity = 0;
                    setTimeout(() => {
                        splashScreen.style.display = 'none';
                        initApp();
                    }, 500);
                }
            }

            function initApp() {
                // Initialize variables
                let map, userMarker, currentPosition;
                let activeMode = 'drainage'; // Default mode
                let activeTool = null;
                let selectedUtilityType = 'water';
                let selectedLineType = 'service';
                // Limit undo stack size
                const MAX_UNDO_STACK_SIZE = 100;
                let undoStack = [];
                let isDrawing = false;
                let tempLine = null;
                let drawingPoints = [];
                let directionAngle = 0;
                let pitchPercent = 2.0;
                let selectedElement = null;
                let selectedBorough = null;
                let nearestValidPoint = null;
                let isSnapping = true;
                // Added missing variable declarations
                let drawingCurb = null;
                let drawingStartIndex = 0;
                let tempUtilityLocation = null;
                let currentDrawingType = null;
                
                // Drainage layers
                let catchBasinsLayer = L.layerGroup();
                let curbPitchesLayer = L.layerGroup();
                let curbAvailableLayer = L.layerGroup();
                let drainageHeatmapLayer = null;
                
                // Utility layers
                let utilitiesLayer = L.layerGroup();
                
                // Road network data
                let streets = [];
                let curbs = [];
                let drainagePoints = [];
                let utilities = {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                };
                
                // Clear any previous map instances to prevent memory leaks
                if (map) {
                    map.remove();
                    map = null;
                }
                
                // Initialize map
                initMap();
                
                // Add custom overlays for utilities
                addUtilityWorkflowOverlay();
                
                // Initialize UI interactions
                initUIHandlers();
                
                // Show location modal to start
                showModal('location-modal');
                
                function initMap() {
                    // Create map with default view
                    map = L.map('map', {
                        zoomControl: false,
                        attributionControl: false
                    }).setView([40.7128, -74.0060], 16); // Default to NYC
                    
                    // Add tile layer (OpenStreetMap)
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 22
                    }).addTo(map);
                    
                    // Add feature layers to map
                    catchBasinsLayer.addTo(map);
                    curbPitchesLayer.addTo(map);
                    curbAvailableLayer.addTo(map);
                    utilitiesLayer.addTo(map);
                    
                    // Map event listeners
                    map.on('click', handleMapClick);
                    map.on('mousemove', handleMouseMove);
                    map.on('touchmove', handleTouchMove);
                    map.on('contextmenu', handleContextMenu);
                    
                    // Hide context menu on map move
                    map.on('movestart', hideContextMenu);
                    
                    // Road data load on map movement
                    map.on('moveend', loadRoadData);
                }
                
                function loadRoadData() {
                    // Show loading message
                    updateStatus('Loading street data...');
                    
                    // Get current map bounds
                    const bounds = map.getBounds();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();
                    
                    // Clear existing road guides
                    curbAvailableLayer.clearLayers();
                    streets = [];
                    curbs = [];
                    
                    // Check if we're zoomed in enough to fetch detailed street data
                    if (map.getZoom() < 16) {
                        updateStatus('Zoom in closer to see street details');
                        // Make sure loading overlay is hidden when we bail out early
                        document.querySelector('.loading-overlay').style.display = 'none';
                        return;
                    }
                    
                    // Use Overpass API to get road data
                    const overpassQuery = `
                        [out:json];
                        (
                          way["highway"](${south},${west},${north},${east});
                        );
                        out body geom;
                    `;
                    
                    // Overpass API endpoint
                    const overpassUrl = "https://overpass-api.de/api/interpreter";
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Track retry attempts
                    let retryCount = 0;
                    const maxRetries = 3;
                    const fetchRoadData = () => {
                            fetch(overpassUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
                            },
                            body: 'data=' + encodeURIComponent(overpassQuery.trim())
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network response error: ${response.status} ${response.statusText}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            if (data && data.elements) {
                                processRoadData(data.elements);
                            } else {
                                throw new Error('Invalid data format received from Overpass API');
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching road data:', error);
                            
                            // Implement exponential backoff for retries
                            if (retryCount < maxRetries) {
                                retryCount++;
                                const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff
                                updateStatus(`Network error. Retrying in ${delay/1000} seconds...`);
                                
                                setTimeout(fetchRoadData, delay);
                            } else {
                                // After max retries, give up and inform the user
                                updateStatus('Failed to load street data. Try again later or use the search location option.');
                                showNotification('Error loading streets: ' + error.message);
                                
                                // Hide loading overlay
                                document.querySelector('.loading-overlay').style.display = 'none';
                                
                                // Try to recover by showing past streets if available
                                if (streets.length > 0) {
                                    showAvailableCurbs();
                                } else {
                                    // Suggest alternative
                                    showNotification('Try searching for a specific address instead');
                                }
                            }
                        });
                    };
                    
                    // Start the fetch process
                    fetchRoadData();
                }
                
                function processRoadData(elements) {
                    if (!elements || elements.length === 0) {
                        updateStatus('No street data found.');
                        return;
                    }
                    
                    let counter = 0;
                    let validRoads = 0;
                    
                    // Filter out non-walkable highway types
                    const roadTypes = ['motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'residential', 'service', 'unclassified'];
                    
                    elements.forEach(element => {
                        if (element.type === 'way' && element.tags && element.tags.highway && roadTypes.includes(element.tags.highway)) {
                            if (element.geometry && element.geometry.length > 1) {
                                try {
                                    // Convert geometry to LatLng array
                                    const latlngs = element.geometry.map(node => [node.lat, node.lon]);
                                    
                                    // Add to streets array
                                    streets.push({
                                        id: element.id,
                                        latlngs: latlngs,
                                        type: element.tags.highway
                                    });
                                    
                                    // Generate curb lines on both sides
                                    createCurbLines(latlngs, element.id);
                                    
                                    validRoads++;
                                } catch (err) {
                                    console.error('Error processing road element:', err, element);
                                }
                            }
                        }
                        
                        counter++;
                        if (counter === elements.length) {
                            if (validRoads > 0) {
                                updateStatus(`Loaded ${validRoads} streets. Select a tool to begin.`);
                                
                                // Add available curbs to map if in drainage mode
                                if (activeMode === 'drainage') {
                                    showAvailableCurbs();
                                }
                                
                                // Initialize drainage heatmap if not already created
                                if (!drainageHeatmapLayer) {
                                    initDrainageHeatmap();
                                } else {
                                    updateDrainageHeatmap();
                                }
                            } else {
                                updateStatus('No valid streets found. Try zooming in more.');
                            }
                        }
                    });
                }
                
                function createCurbLines(streetPoints, streetId) {
                    if (streetPoints.length < 2) return;
                    
                    // Calculate curb offsets
                    const curbOffsets = curbOffsetPoints(streetPoints, 5); // 5 meters offset
                    
                    if (curbOffsets && curbOffsets.length > 0) {
                        // Create left and right curb polylines
                        const leftCurbPoints = curbOffsets.map(pair => pair[0]);
                        const rightCurbPoints = curbOffsets.map(pair => pair[1]);
                        
                        // Store curb data
                        curbs.push({
                            id: `${streetId}-left`,
                            latlngs: leftCurbPoints,
                            streetId: streetId,
                            pitches: [] // Will store pitch info
                        });
                        
                        curbs.push({
                            id: `${streetId}-right`,
                            latlngs: rightCurbPoints,
                            streetId: streetId,
                            pitches: [] // Will store pitch info
                        });
                    }
                }
                
                // Calculate curb offset points
                function curbOffsetPoints(streetPts, meters) {
                    try {
                        const validPoints = streetPts.filter(pt => pt && pt.length === 2);
                        if (validPoints.length < 2) return [];
                        
                        return validPoints.map((p, i, arr) => {
                            if (i === arr.length - 1) return null;
                            
                            // Convert points to screen coordinates for better accuracy
                            const a = map.latLngToLayerPoint(L.latLng(arr[i]));
                            const b = map.latLngToLayerPoint(L.latLng(arr[i + 1]));
                            
                            // Calculate normalized direction vector
                            const dx = b.x - a.x;
                            const dy = b.y - a.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist === 0) return null;
                            
                            // Normalize direction vector
                            const nx = dx / dist;
                            const ny = dy / dist;
                            
                            // Calculate perpendicular vector
                            const perpX = -ny;
                            const perpY = nx;
                            
                            // Calculate offset in pixels (approx. 3 pixels per meter at zoom level 19)
                            const pixelsPerMeter = 3;
                            const offsetPixels = meters * pixelsPerMeter;
                            
                            // Apply offset
                            const leftX = a.x + perpX * offsetPixels;
                            const leftY = a.y + perpY * offsetPixels;
                            const rightX = a.x - perpX * offsetPixels;
                            const rightY = a.y - perpY * offsetPixels;
                            
                            // Convert back to lat/lng
                            const leftLatLng = map.layerPointToLatLng(L.point(leftX, leftY));
                            const rightLatLng = map.layerPointToLatLng(L.point(rightX, rightY));
                            
                            return [leftLatLng, rightLatLng];
                        }).filter(Boolean); // Remove null values
                    } catch (err) {
                        console.error('Error calculating curb offsets:', err);
                        return [];
                    }
                }
                
                function showAvailableCurbs() {
                    // Clear existing available curbs
                    curbAvailableLayer.clearLayers();
                    
                    // For each curb, check if it has pitches
                    curbs.forEach(curb => {
                        if (curb.pitches.length === 0) {
                            // No pitches, show entire curb as available
                            L.polyline(curb.latlngs, {
                                className: 'curb-available',
                                curbId: curb.id
                            }).addTo(curbAvailableLayer);
                        } else if (curb.pitches.length > 0) {
                            // Has some pitches, find gaps
                            const gaps = findCurbGaps(curb);
                            
                            // Add each gap as available with blue glow
                            gaps.forEach(gap => {
                                const polyline = L.polyline(gap.points, {
                                    className: 'curb-available',
                                    color: '#4FC3F7', // Light blue for gaps
                                    weight: 8,
                                    opacity: 0.7,
                                    curbId: curb.id,
                                    startIndex: gap.startIndex,
                                    endIndex: gap.endIndex,
                                    prevPitchId: gap.prevPitchId,
                                    nextPitchId: gap.nextPitchId
                                }).addTo(curbAvailableLayer);
                            });
                        }
                    });
                    
                    // If in drainage mode, make available curbs clickable
                    if (activeMode === 'drainage') {
                        curbAvailableLayer.eachLayer(layer => {
                            layer.on('click', handleAvailableCurbClick);
                        });
                    }
                }
                
                function findCurbGaps(curb) {
                    const gaps = [];
                    
                    // If no pitches, entire curb is a gap
                    if (curb.pitches.length === 0) {
                        gaps.push({
                            startIndex: 0,
                            endIndex: curb.latlngs.length - 1,
                            points: curb.latlngs,
                            prevPitchId: null,
                            nextPitchId: null
                        });
                        return gaps;
                    }
                    
                    // Sort pitches by startIndex
                    const sortedPitches = [...curb.pitches].sort((a, b) => a.startIndex - b.startIndex);
                    
                    // Check for gap at the beginning
                    if (sortedPitches[0].startIndex > 0) {
                        gaps.push({
                            startIndex: 0,
                            endIndex: sortedPitches[0].startIndex - 1,
                            points: curb.latlngs.slice(0, sortedPitches[0].startIndex),
                            prevPitchId: null,
                            nextPitchId: sortedPitches[0].id
                        });
                    }
                    
                    // Check for gaps between pitches
                    for (let i = 0; i < sortedPitches.length - 1; i++) {
                        const currentPitch = sortedPitches[i];
                        const nextPitch = sortedPitches[i + 1];
                        const currentEnd = currentPitch.endIndex;
                        const nextStart = nextPitch.startIndex;
                        
                        if (nextStart > currentEnd + 1) {
                            gaps.push({
                                startIndex: currentEnd + 1,
                                endIndex: nextStart - 1,
                                points: curb.latlngs.slice(currentEnd + 1, nextStart),
                                prevPitchId: currentPitch.id,
                                nextPitchId: nextPitch.id
                            });
                        }
                    }
                    
                    // Check for gap at the end
                    const lastPitch = sortedPitches[sortedPitches.length - 1];
                    if (lastPitch.endIndex < curb.latlngs.length - 1) {
                        gaps.push({
                            startIndex: lastPitch.endIndex + 1,
                            endIndex: curb.latlngs.length - 1,
                            points: curb.latlngs.slice(lastPitch.endIndex + 1),
                            prevPitchId: lastPitch.id,
                            nextPitchId: null
                        });
                    }
                    
                    return gaps;
                }
                
                function handleAvailableCurbClick(e) {
                    // Only proceed if in drainage mode with pitch tool active
                    if (activeMode !== 'drainage' || activeTool !== 'add-pitch-btn') {
                        return;
                    }
                    
                    L.DomEvent.stopPropagation(e);
                    
                    const curbId = e.target.options.curbId;
                    const curb = curbs.find(c => c.id === curbId);
                    
                    if (!curb) return;
                    
                    // Handle gap between existing pitches
                    if (e.target.options.prevPitchId || e.target.options.nextPitchId) {
                        showGapPitchOptions(e.target, curb);
                        return;
                    }
                    
                    // First tap - start the pitch drawing
                    if (!isDrawing) {
                        startCurbPitch(e.latlng, curb, e.target.options.startIndex || 0);
                    } 
                    // Second tap - complete the pitch
                    else if (drawingCurb && drawingCurb.id === curbId) {
                        let clickIndex = e.target.options.startIndex || 0;
                        
                        // Find the appropriate index
                        if (e.target.options.endIndex) {
                            const startDist = map.distance(e.latlng, curb.latlngs[e.target.options.startIndex]);
                            const endDist = map.distance(e.latlng, curb.latlngs[e.target.options.endIndex]);
                            clickIndex = startDist < endDist ? e.target.options.startIndex : e.target.options.endIndex;
                        }
                        
                        completeCurbPitch(e.latlng, clickIndex);
                    } 
                    // Clicking on a different curb - cancel and start new
                    else {
                        cancelDrawing();
                        startCurbPitch(e.latlng, curb, e.target.options.startIndex || 0);
                    }
                }
                
                function startCurbPitch(latlng, curb, startIndex) {
                    // Find nearest point on curb
                    const result = nearestPointOnCurb(latlng, curb);
                    
                    if (!result || !result.point) return;
                    
                    // Start drawing from this point
                    isDrawing = true;
                    drawingPoints = [result.point];
                    drawingCurb = curb;
                    drawingStartIndex = startIndex || result.index;
                    currentDrawingType = 'pitch';
                    
                    // Create temporary line
                    tempLine = L.polyline([result.point, result.point], {
                        color: '#FFC107', // Yellow for pitch lines
                        weight: 5,
                        opacity: 0.7,
                        dashArray: '5,5'
                    }).addTo(map);
                    
                    // Show drawing buttons
                    document.getElementById('cancel-drawing-btn').style.display = 'block';
                    document.getElementById('finish-mapping-btn').style.display = 'block';
                    
                    updateStatus('Now tap on another point along the same curb to complete the pitch');
                }
                
                function completeCurbPitch(endPoint, endIndex) {
                    // Remove temporary drawing line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Reset drawing state
                    isDrawing = false;
                    
                    // Need at least 2 points for a valid line
                    if (!drawingPoints || drawingPoints.length < 1) {
                        drawingPoints = [];
                        return;
                    }
                    
                    // Get points along the curb between start and end indices
                    let pitchPoints = [];
                    
                    // Check if the indices are valid
                    if (drawingStartIndex < 0 || endIndex < 0 || 
                        drawingStartIndex >= drawingCurb.latlngs.length || 
                        endIndex >= drawingCurb.latlngs.length) {
                        showNotification('Invalid pitch selection');
                        drawingPoints = [];
                        return;
                    }
                    
                    // Get start and end indices (allowing for drawing in either direction)
                    let startIdx = Math.min(drawingStartIndex, endIndex);
                    let endIdx = Math.max(drawingStartIndex, endIndex);
                    
                    // Create points array along the curb segment
                    for (let i = startIdx; i <= endIdx; i++) {
                        pitchPoints.push(drawingCurb.latlngs[i]);
                    }
                    
                    // Determine direction - always point toward the second tap
                    // This is the key change to match the desired workflow
                    let flowDirection = (endIndex > drawingStartIndex);
                    
                    // If drawing backward, we need to reverse the points
                    if (!flowDirection) {
                        pitchPoints.reverse();
                    }
                    
                    // Calculate angle based on the flow direction
                    let initialAngle = calculateAngle(pitchPoints[0], pitchPoints[pitchPoints.length - 1]);
                    if (!flowDirection) {
                        initialAngle = (initialAngle + 180) % 360; // Reverse angle if needed
                    }
                    
                    // Store pitch data with this direction
                    const pitchData = {
                        curbId: drawingCurb.id,
                        startIndex: startIdx,
                        endIndex: endIdx,
                        points: pitchPoints,
                        angle: initialAngle,
                        percent: 2.0,
                        flowDirection: flowDirection
                    };
                    
                    // Store for modal confirmation
                    selectedElement = {
                        type: 'new-pitch',
                        pitchData: pitchData,
                        originalStartIndex: startIdx,
                        originalEndIndex: endIdx,
                        curb: drawingCurb
                    };
                    
                    // Set the direction angle in the UI
                    directionAngle = initialAngle;
                    document.getElementById('pitch-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                    document.getElementById('direction-angle').textContent = `${directionAngle}°`;
                    
                    // Set default pitch percentage
                    pitchPercent = 2.0;
                    document.getElementById('pitch-value').textContent = `${pitchPercent.toFixed(1)}%`;
                    
                    // Hide drawing buttons
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    document.getElementById('finish-mapping-btn').style.display = 'none';
                    
                    // Show enhanced pitch input modal
                    showPitchEditorModal();
                    
                    // Reset drawing points
                    drawingPoints = [];
                }
                
                function finalizeCurbPitch(pitchData) {
                    // Check if we need to snap to an existing pitch
                    let shouldMerge = false;
                    let mergedWith = null;
                    
                    // Find the curb and check for nearby pitches
                    const curb = curbs.find(c => c.id === pitchData.curbId);
                    if (curb) {
                        // Check if this pitch should be merged with an adjacent one
                        for (let i = 0; i < curb.pitches.length; i++) {
                            const existingPitch = curb.pitches[i];
                            
                            // Check if this pitch abuts our new one (within 1 index)
                            if (Math.abs(existingPitch.endIndex - pitchData.startIndex) <= 1 ||
                                Math.abs(existingPitch.startIndex - pitchData.endIndex) <= 1) {
                                
                                shouldMerge = true;
                                mergedWith = existingPitch;
                                break;
                            }
                        }
                    }
                    
                    if (shouldMerge && mergedWith) {
                        // Merge with the existing pitch
                        mergePitches(pitchData, mergedWith, curb);
                    } else {
                        // Create a new pitch line
                        createNewPitch(pitchData, curb);
                    }
                    
                    // Update available curbs
                    showAvailableCurbs();
                    
                    // Update drainage heatmap
                    updateDrainageHeatmap();
                }
                
                function createNewPitch(pitchData, curb) {
                    // Create final pitch line
                    const line = L.polyline(pitchData.points, {
                        color: '#FFC107', // Yellow color for pitch lines
                        weight: 5,
                        opacity: 1,
                        className: 'curb-pitch-line',
                        pitchPercent: pitchData.percent,
                        pitchAngle: pitchData.angle
                    }).addTo(curbPitchesLayer);
                    
                    // Generate a unique ID for this pitch
                    const pitchId = 'pitch-' + Date.now();
                    
                    // Create the new pitch object
                    const newPitch = {
                        id: pitchId,
                        startIndex: pitchData.startIndex,
                        endIndex: pitchData.endIndex,
                        percent: pitchData.percent,
                        angle: pitchData.angle,
                        line: line,
                        flowDirection: pitchData.flowDirection || !(pitchData.reversed)
                    };
                    
                    // Add the pitch to the curb
                    curb.pitches.push(newPitch);
                    
                    // Add direction arrow - should point in direction of flow
                    addPitchArrow(line, pitchData.angle);
                    
                    // Add pitch label - centered black text showing the pitch percentage
                    addPitchLabel(line, pitchData.percent);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'curb-pitch',
                        line: line,
                        curbId: pitchData.curbId,
                        startIndex: pitchData.startIndex,
                        endIndex: pitchData.endIndex
                    });
                    
                    // Add click handler
                    line.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        selectElement(line, 'pitch');
                    });
                    
                    // Update status
                    updateStatus(`Curb pitch added at ${pitchData.percent}%`);
                }
                
                function mergePitches(newPitchData, existingPitch, curb) {
                    // Determine merged start/end indices
                    let mergedStartIndex = Math.min(existingPitch.startIndex, newPitchData.startIndex);
                    let mergedEndIndex = Math.max(existingPitch.endIndex, newPitchData.endIndex);
                    
                    // Get all points for the merged pitch
                    let mergedPoints = [];
                    
                    // Create a rounded transition between the pitches
                    if (existingPitch.endIndex + 1 >= newPitchData.startIndex - 1 &&
                        existingPitch.endIndex < newPitchData.startIndex) {
                        // Existing pitch is before new pitch - seamless transition
                        mergedPoints = createSmoothTransition(
                            existingPitch.line.getLatLngs(),
                            newPitchData.points
                        );
                    } else if (newPitchData.endIndex + 1 >= existingPitch.startIndex - 1 &&
                               newPitchData.endIndex < existingPitch.startIndex) {
                        // New pitch is before existing pitch - seamless transition
                        mergedPoints = createSmoothTransition(
                            newPitchData.points,
                            existingPitch.line.getLatLngs()
                        );
                    } else {
                        // If indices overlap or have a larger gap, just use all points between start and end
                        for (let i = mergedStartIndex; i <= mergedEndIndex; i++) {
                            if (i < curb.latlngs.length) {
                                mergedPoints.push(curb.latlngs[i]);
                            }
                        }
                    }
                    
                    // Remove the existing pitch
                    if (existingPitch.line) {
                        // Remove markers
                        if (existingPitch.line.arrowMarker) {
                            curbPitchesLayer.removeLayer(existingPitch.line.arrowMarker);
                        }
                        if (existingPitch.line.labelMarker) {
                            curbPitchesLayer.removeLayer(existingPitch.line.labelMarker);
                        }
                        // Remove line
                        curbPitchesLayer.removeLayer(existingPitch.line);
                    }
                    
                    // Create new merged pitch data
                    const mergedPitchData = {
                        curbId: curb.id,
                        startIndex: mergedStartIndex,
                        endIndex: mergedEndIndex,
                        points: mergedPoints,
                        // Keep direction and pitch from the new pitch
                        angle: newPitchData.angle,
                        percent: newPitchData.percent
                    };
                    
                    // Remove the existing pitch from the curb's pitches array
                    curb.pitches = curb.pitches.filter(p => p.id !== existingPitch.id);
                    
                    // Create the merged pitch
                    createNewPitch(mergedPitchData, curb);
                    
                    // Update status
                    updateStatus(`Pitches merged at ${newPitchData.percent}%`);
                }
                
                function showGapPitchOptions(layer, curb) {
                    // Get gap details
                    const startIndex = layer.options.startIndex;
                    const endIndex = layer.options.endIndex;
                    
                    // Find adjacent pitches
                    let prevPitch = null;
                    let nextPitch = null;
                    
                    if (layer.options.prevPitchId) {
                        prevPitch = curb.pitches.find(p => p.id === layer.options.prevPitchId);
                    }
                    
                    if (layer.options.nextPitchId) {
                        nextPitch = curb.pitches.find(p => p.id === layer.options.nextPitchId);
                    }
                    
                    // Store selected gap info
                    selectedElement = {
                        type: 'gap',
                        layer: layer,
                        curb: curb,
                        startIndex: startIndex,
                        endIndex: endIndex,
                        prevPitch: prevPitch,
                        nextPitch: nextPitch
                    };
                    
                    // Reset option selection
                    document.querySelectorAll('#gap-pitch-modal .connection-option').forEach(option => {
                        option.classList.remove('selected');
                    });
                    
                    // Select first option by default
                    document.querySelector('#gap-pitch-modal .connection-option').classList.add('selected');
                    
                    // Hide pitch options initially
                    document.getElementById('add-pitch-option').style.display = 'none';
                    
                    // Reset default values in modal
                    directionAngle = prevPitch && nextPitch ? 
                        calculateTransitionAngle(prevPitch, nextPitch) : 
                        (prevPitch ? prevPitch.angle : (nextPitch ? nextPitch.angle : 0));
                        
                    document.getElementById('gap-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                    document.getElementById('gap-direction-angle').textContent = `${directionAngle}°`;
                    
                    pitchPercent = prevPitch && nextPitch ? 
                        Math.max(prevPitch.percent, nextPitch.percent) : 
                        (prevPitch ? prevPitch.percent : (nextPitch ? nextPitch.percent : 2.0));
                        
                    document.getElementById('gap-pitch-value').textContent = `${pitchPercent.toFixed(1)}%`;
                    
                    // Show gap modal
                    showModal('gap-pitch-modal');
                }
                
                function addCatchBasin(latlng) {
                    // Create catch basin icon with enhanced styling
                    const catchBasinIcon = L.divIcon({
                        html: '<div class="catch-basin-icon"><i class="fas fa-drain"></i></div>',
                        className: '',
                        iconSize: [44, 44],
                        iconAnchor: [22, 22]
                    });
                    
                    // Create marker
                    const marker = L.marker(latlng, {
                        icon: catchBasinIcon,
                        draggable: true
                    }).addTo(catchBasinsLayer);
                    
                    // Add to drainage points
                    drainagePoints.push({
                        type: 'basin',
                        latlng: latlng,
                        marker: marker
                    });
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'catch-basin',
                        marker: marker
                    });
                    
                    // Add click handler
                    marker.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        selectElement(marker, 'basin');
                    });
                    
                    // Add animation effect
                    const icon = marker._icon;
                    if (icon) {
                        icon.style.transform += ' scale(0)';
                        
                        // Trigger animation
                        setTimeout(() => {
                            icon.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                            icon.style.transform = icon.style.transform.replace(' scale(0)', ' scale(1)');
                        }, 10);
                    }
                    
                    // Update drainage heatmap
                    updateDrainageHeatmap();
                    
                    // Update status
                    updateStatus('Catch basin added');
                }
                
                function initDrainageHeatmap() {
                    // Create a points array based on the road network
                    let heatPoints = generateHeatmapPoints();
                    
                    // Create the heatmap layer with enhanced styling
                    drainageHeatmapLayer = L.heatLayer(heatPoints, {
                        radius: 25,
                        blur: 15,
                        maxZoom: 17,
                        gradient: {
                            0.2: 'blue',
                            0.4: '#03a9f4',
                            0.6: '#4caf50',
                            0.8: '#ffc107',
                            1.0: '#f44336'
                        },
                        minOpacity: 0.4
                    }).addTo(map);
                    
                    // Update the heatmap when catch basins or pitches change
                    updateDrainageHeatmap();
                }
                
                function generateHeatmapPoints() {
                    let points = [];
                    
                    // Add points along curbs
                    curbs.forEach(curb => {
                        // Use fewer points for better performance
                        const step = Math.max(1, Math.floor(curb.latlngs.length / 20));
                        for (let i = 0; i < curb.latlngs.length; i += step) {
                            const point = curb.latlngs[i];
                            points.push([point.lat, point.lng, 0.5]); // Initial intensity 0.5
                        }
                    });
                    
                    return points;
                }
                
                function updateDrainageHeatmap() {
                    if (!drainageHeatmapLayer) return;
                    
                    // If already calculating, don't start again
                    if (updateDrainageHeatmap.isUpdating) return;
                    updateDrainageHeatmap.isUpdating = true;
                    
                    // Use requestAnimationFrame to avoid blocking the main thread
                    requestAnimationFrame(() => {
                        try {
                            // Generate new heatpoints with updated intensities
                            let heatPoints = calculateDrainageIntensities();
                            
                            // Only recreate if there's a visible change in the data
                            const visible = document.getElementById('heatmap-toggle').checked;
                            
                            // Remove the old heatmap layer
                            if (map.hasLayer(drainageHeatmapLayer)) {
                                map.removeLayer(drainageHeatmapLayer);
                            }
                            
                            // Create a new heatmap layer
                            drainageHeatmapLayer = L.heatLayer(heatPoints, {
                                radius: 25,
                                blur: 15,
                                maxZoom: 17,
                                gradient: {
                                    0.2: 'blue',
                                    0.4: '#03a9f4',
                                    0.6: '#4caf50',
                                    0.8: '#ffc107',
                                    1.0: '#f44336'
                                },
                                minOpacity: 0.4
                            });
                            
                            // Add the layer if heatmap toggle is on
                            if (visible) {
                                drainageHeatmapLayer.addTo(map);
                            }
                        } catch (err) {
                            console.error('Error updating drainage heatmap:', err);
                        } finally {
                            updateDrainageHeatmap.isUpdating = false;
                        }
                    });
                }
                updateDrainageHeatmap.isUpdating = false;
                
                function calculateDrainageIntensities() {
                    let heatPoints = [];
                    
                    // Create base heatmap grid - more efficiently
                    const bounds = map.getBounds();
                    const southWest = bounds.getSouthWest();
                    const northEast = bounds.getNorthEast();
                    
                    // Use grid based on zoom level for performance
                    const gridSize = 30;
                    const latStep = (northEast.lat - southWest.lat) / gridSize;
                    const lngStep = (northEast.lng - southWest.lng) / gridSize;
                    
                    // Get catch basin positions
                    const basins = drainagePoints.filter(p => p.type === 'basin')
                                                .map(p => p.latlng);
                    
                    // For each curb, get its pitches and their directions
                    const pitchData = [];
                    curbs.forEach(curb => {
                        curb.pitches.forEach(pitch => {
                            const line = pitch.line;
                            if (!line) return;
                            
                            const points = line.getLatLngs();
                            const angle = pitch.angle;
                            
                            pitchData.push({
                                points: points,
                                angle: angle,
                                percent: pitch.percent
                            });
                        });
                    });
                    
                    // Generate grid points with optimized calculations
                    for (let lat = southWest.lat; lat <= northEast.lat; lat += latStep) {
                        for (let lng = southWest.lng; lng <= northEast.lng; lng += lngStep) {
                            // Calculate a drainage intensity based on:
                            // 1. Distance from nearest catch basin (closer = less flooding)
                            // 2. Nearby pitch directions (where water would flow)
                            
                            const point = L.latLng(lat, lng);
                            let intensity = 0.5; // Base intensity
                            
                            // Reduce intensity near catch basins
                            if (basins.length > 0) {
                                let minDist = Infinity;
                                for (const basin of basins) {
                                    const dist = map.distance(point, basin);
                                    if (dist < minDist) {
                                        minDist = dist;
                                    }
                                }
                                
                                // Normalize distance (max effect within 50 meters)
                                const normalizedDist = Math.min(minDist, 50) / 50;
                                intensity = normalizedDist; // Closer basin = lower intensity
                            }
                            
                            // Only check nearby pitches for efficiency
                            let pitchInfluences = 0;
                            for (const pitch of pitchData) {
                                // Quick check if point is in the bounding box of pitch points
                                const nearestPitchPoint = nearestPointOnLine(point, pitch.points);
                                if (nearestPitchPoint.distance < 25) { // Only consider close pitches
                                    // Get direction from nearest point to basin
                                    let flowsToBasin = flowsTowardsBasin(nearestPitchPoint.point, pitch.angle, basins);
                                    
                                    // Adjust intensity based on flow direction and pitch percentage
                                    const pitchEffect = 0.1 * (pitch.percent / 2);
                                    if (flowsToBasin) {
                                        intensity -= pitchEffect; // Reduce flooding if flowing to basin
                                    } else {
                                        intensity += pitchEffect; // Increase flooding if flowing away
                                    }
                                    pitchInfluences++;
                                }
                            }
                            
                            // Only calculate for areas with notable drainage effects
                            if (basins.length > 0 || pitchInfluences > 0) {
                                // Constrain intensity between 0.1 and 1
                                intensity = Math.max(0.1, Math.min(1, intensity));
                                heatPoints.push([lat, lng, intensity]);
                            }
                        }
                    }
                    
                    return heatPoints;
                }
                
                function flowsTowardsBasin(point, angle, basins) {
                    if (!basins || basins.length === 0) return false;
                    
                    // Find the nearest basin
                    let nearestBasin = null;
                    let minDist = Infinity;
                    
                    for (const basin of basins) {
                        const dist = map.distance(point, basin);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestBasin = basin;
                        }
                    }
                    
                    if (!nearestBasin) return false;
                    
                    // Calculate angle to basin (0 is North, clockwise)
                    const dx = nearestBasin.lng - point.lng;
                    const dy = nearestBasin.lat - point.lat;
                    
                    // Prevent division by zero
                    if (Math.abs(dx) < 1e-10 && Math.abs(dy) < 1e-10) return true;
                    
                    const angleToBain = (Math.atan2(dx, dy) * 180 / Math.PI + 360) % 360;
                    
                    // Compare with pitch angle (within 45 degrees is considered flowing towards)
                    const angleDiff = Math.abs(angleToBain - angle);
                    const normalizedDiff = Math.min(angleDiff, 360 - angleDiff);
                    
                    return normalizedDiff < 45;
                }
                
                function nearestPointOnLine(point, linePoints) {
                    if (!linePoints || linePoints.length < 2) {
                        return {
                            point: point,
                            distance: Infinity
                        };
                    }
                    
                    let minDist = Infinity;
                    let nearestPoint = null;
                    
                    for (let i = 0; i < linePoints.length - 1; i++) {
                        const segmentResult = projectOnSegment(point, linePoints[i], linePoints[i+1]);
                        if (segmentResult.distance < minDist) {
                            minDist = segmentResult.distance;
                            nearestPoint = segmentResult.point;
                        }
                    }
                    
                    return {
                        point: nearestPoint || linePoints[0],
                        distance: minDist
                    };
                }
                
                function projectOnSegment(point, start, end) {
                    try {
                        // Convert to layer points (screen pixels) for more accurate calculation
                        const lp = map.latLngToLayerPoint(point);
                        const ls = map.latLngToLayerPoint(start);
                        const le = map.latLngToLayerPoint(end);
                        
                        // Calculate vector from start to end
                        const v = L.point(le.x - ls.x, le.y - ls.y);
                        
                        // Calculate vector from start to point
                        const w = L.point(lp.x - ls.x, lp.y - ls.y);
                        
                        // Calculate projection scalar
                        const c1 = w.x * v.x + w.y * v.y;
                        const c2 = v.x * v.x + v.y * v.y;
                        
                        // Handle zero-length segments
                        if (c2 === 0) {
                            return {
                                point: start,
                                distance: map.distance(point, start)
                            };
                        }
                        
                        // Calculate normalized projection (clamped to [0,1])
                        const t = Math.max(0, Math.min(1, c1 / c2));
                        
                        // Calculate projected point
                        const px = ls.x + t * v.x;
                        const py = ls.y + t * v.y;
                        const projPoint = L.point(px, py);
                        
                        // Convert back to latlng for distance calculation
                        const projLatLng = map.layerPointToLatLng(projPoint);
                        const distance = map.distance(point, projLatLng);
                        
                        // Return result
                        return {
                            point: projLatLng,
                            distance: distance
                        };
                    } catch (err) {
                        console.error('Error in projectOnSegment:', err);
                        return {
                            point: start,
                            distance: map.distance(point, start)
                        };
                    }
                }
                
                function nearestPointOnCurb(point, curb) {
                    if (!curb || !curb.latlngs || curb.latlngs.length < 2) {
                        return null;
                    }
                    
                    let minDist = Infinity;
                    let nearestPoint = null;
                    let nearestIndex = 0;
                    
                    // Check each segment in the curb
                    for (let i = 0; i < curb.latlngs.length - 1; i++) {
                        const segmentResult = projectOnSegment(point, curb.latlngs[i], curb.latlngs[i+1]);
                        if (segmentResult.distance < minDist) {
                            minDist = segmentResult.distance;
                            nearestPoint = segmentResult.point;
                            nearestIndex = i;
                        }
                    }
                    
                    return {
                        point: nearestPoint,
                        index: nearestIndex,
                        distance: minDist
                    };
                }
                
                function addUtilityFound(latlng) {
                    // Store the location for later
                    tempUtilityLocation = latlng;
                    
                    // Reset utility angle
                    directionAngle = 0;
                    document.getElementById('utility-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                    document.getElementById('utility-direction-angle').textContent = `${directionAngle}°`;
                    
                    // Set default utility type to match selected utility type button
                    if (selectedUtilityType) {
                        document.getElementById('utility-type').value = selectedUtilityType;
                    }
                    
                    // Show direction input modal
                    showModal('utility-found-modal');
                }
                
                function finalizeUtilityFound() {
                    // Get form values
                    const utilityType = document.getElementById('utility-type').value;
                    const lineType = document.querySelector('input[name="line-type"]:checked').value;
                    const size = parseFloat(document.getElementById('utility-size').value) || 4;
                    const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                    
                    // Get utility colors
                    const colors = {
                        water: '#03a9f4',
                        gas: '#ff9800',
                        electric: '#ffeb3b',
                        sewer: '#795548',
                        telecom: '#9c27b0'
                    };
                    
                    // Create short line in the direction specified
                    const angle = directionAngle;
                    const startPoint = tempUtilityLocation;
                    const endPoint = calculateEndPoint(startPoint, angle, 10); // 10 meters length
                    
                    // Create the polyline
                    const line = L.polyline([startPoint, endPoint], {
                        color: colors[utilityType],
                        weight: lineType === 'main' ? 6 : 4,
                        opacity: 1,
                        className: `utility-line ${lineType}`,
                        utilityType: utilityType,
                        lineType: lineType,
                        size: size,
                        depth: depth,
                        angle: angle
                    }).addTo(utilitiesLayer);
                    
                    // Create utility marker at start
                    const markerIcon = createUtilityMarkerIcon(utilityType, lineType);
                    const marker = L.marker(startPoint, {
                        icon: markerIcon,
                        draggable: true
                    }).addTo(utilitiesLayer);
                    
                    // Associate marker with line
                    line.utilityMarker = marker;
                    marker.utilityLine = line;
                    
                    // Process media if uploaded
                    const mediaInput = document.getElementById('utility-media');
                    let mediaData = null;
                    
                    if (mediaInput.files && mediaInput.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            mediaData = e.target.result;
                            
                            // Store media with utility
                            marker.mediaData = mediaData;
                            line.mediaData = mediaData;
                            
                            // Also update the utility data in our collection
                            const utility = utilities[utilityType].find(u => u.id === utilityId);
                            if (utility) {
                                utility.mediaData = mediaData;
                            }
                        };
                        reader.readAsDataURL(mediaInput.files[0]);
                    }
                    
                    // Generate a unique ID for the utility
                    const utilityId = 'utility-' + Date.now();
                    
                    // Store utility data
                    const utilityData = {
                        id: utilityId,
                        type: utilityType,
                        lineType: lineType,
                        size: size,
                        depth: depth,
                        points: [startPoint, endPoint],
                        angle: angle,
                        marker: marker,
                        line: line,
                        mediaData: mediaData
                    };
                    
                    // Add to utilities collection
                    utilities[utilityType].push(utilityData);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utility',
                        utilityData: utilityData
                    });
                    
                    // Add click handlers
                    marker.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(marker);
                    });
                    
                    line.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(marker);
                    });
                    
                    // Update marker position when dragged
                    marker.on('drag', function(e) {
                        // Update line start point
                        const newPos = e.target.getLatLng();
                        const points = line.getLatLngs();
                        
                        // Calculate new end point maintaining the same direction and length
                        const newEndPoint = calculateEndPoint(newPos, angle, 10);
                        
                        // Update line
                        line.setLatLngs([newPos, newEndPoint]);
                        
                        // Update utility data
                        const utility = utilities[utilityType].find(u => u.id === utilityId);
                        if (utility) {
                            utility.points = [newPos, newEndPoint];
                        }
                    });
                    
                    // Reset the media input
                    mediaInput.value = '';
                    
                    // Clear tempUtilityLocation
                    tempUtilityLocation = null;
                    
                    // Update status
                    updateStatus(`${utilityType} ${lineType} added`);
                }
                
                function startUtilityMapping() {
                    // Check if a utility type is selected
                    if (!selectedUtilityType) {
                        showNotification('Please select a utility type first');
                        return;
                    }
                    
                    // Start drawing a new utility line
                    isDrawing = true;
                    drawingPoints = [];
                    currentDrawingType = 'utility';
                    
                    // Show cancel drawing and finish mapping buttons
                    document.getElementById('cancel-drawing-btn').style.display = 'block';
                    document.getElementById('finish-mapping-btn').style.display = 'block';
                    
                    updateStatus(`Click to start mapping a ${selectedUtilityType} ${selectedLineType}`);
                }
                
                function handleUtilityMappingClick(latlng) {
                    // Add point to drawing
                    drawingPoints.push(latlng);
                    
                    // If first point, create temporary line
                    if (drawingPoints.length === 1) {
                        // Get utility color
                        const colors = {
                            water: '#03a9f4',
                            gas: '#ff9800',
                            electric: '#ffeb3b',
                            sewer: '#795548',
                            telecom: '#9c27b0'
                        };
                        
                        // Create temp line
                        tempLine = L.polyline([latlng, latlng], {
                            color: colors[selectedUtilityType],
                            weight: selectedLineType === 'main' ? 6 : 4,
                            opacity: 0.7,
                            dashArray: '5,5'
                        }).addTo(map);
                        
                        updateStatus('Click to add points, double-click to finish');
                    }
                    // If double click or more than 10 points, finish drawing
                    else if (
                        (drawingPoints.length > 1 && 
                         map.distance(drawingPoints[drawingPoints.length-2], latlng) < 5) ||
                        drawingPoints.length > 20
                    ) {
                        // If double click, remove last point
                        if (map.distance(drawingPoints[drawingPoints.length-2], latlng) < 5) {
                            drawingPoints.pop();
                        }
                        
                        completeUtilityMapping();
                    }
                    else {
                        // Update temp line with smooth interpolation
                        if (tempLine) {
                            // Apply bezier smoothing to the line
                            const smoothedPoints = applySmoothingToLine(drawingPoints);
                            tempLine.setLatLngs(smoothedPoints);
                        }
                    }
                }
                
                function completeUtilityMapping() {
                    // Remove temporary line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Hide action buttons
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    document.getElementById('finish-mapping-btn').style.display = 'none';
                    
                    // Need at least 2 points
                    if (drawingPoints.length < 2) {
                    isDrawing = false;
                        drawingPoints = [];
                        return;
                    }
                    
                    // Apply final smoothing to the line
                    const smoothedPoints = applySmoothingToLine(drawingPoints);
                    
                    // For service lines, check if it's near any main of the same type
                    if (selectedLineType === 'service') {
                        const nearbyMains = findNearbyMains(smoothedPoints[smoothedPoints.length - 1], selectedUtilityType);
                        
                        if (nearbyMains.length > 0) {
                            // Found nearby main, offer to tap it
                            const nearestMain = nearbyMains[0];
                            
                            // Store for tap main modal
                            selectedElement = {
                                type: 'tap-main',
                                servicePoints: smoothedPoints,
                                mainUtility: nearestMain.utility,
                                tapPoint: nearestMain.connectLatLng
                            };
                            
                            // Show tap main modal
                            showModal('tap-main-modal');
                        return;
                    }
                    }
                    
                    // Check for nearby utilities of same type for connecting
                    if (selectedLineType === 'main') {
                        const nearbyUtilities = findNearbyUtilities(smoothedPoints[0], selectedUtilityType);
                        
                        if (nearbyUtilities.length > 0) {
                            // Store for connection modal
                    selectedElement = {
                                type: 'connecting-utility',
                                points: smoothedPoints,
                                utilityType: selectedUtilityType,
                                lineType: selectedLineType,
                                nearbyUtilities: nearbyUtilities
                            };
                            
                            // Select first option by default
                            document.querySelectorAll('#utility-connection-modal .connection-option').forEach(option => {
                                option.classList.remove('selected');
                            });
                            document.querySelector('#utility-connection-modal .connection-option').classList.add('selected');
                            
                            // Show connection options
                            showModal('utility-connection-modal');
                            return;
                        }
                    }
                    
                    // No nearby utilities, create as standalone
                    createUtilityLine(smoothedPoints, selectedUtilityType, selectedLineType);
                    
                    // Reset drawing state
                    isDrawing = false;
                    drawingPoints = [];
                }

                function findNearbyUtilities(point, utilityType) {
                    const nearbyList = [];
                    const maxDistance = 10; // meters
                    
                    // Check each utility of the same type
                    utilities[utilityType].forEach(utility => {
                        // For each end point of the utility line
                        const utilityPoints = utility.points;
                        if (!utilityPoints || utilityPoints.length < 2) return;
                        
                        const startPoint = utilityPoints[0];
                        const endPoint = utilityPoints[utilityPoints.length - 1];
                        
                        const startDist = map.distance(point, startPoint);
                        const endDist = map.distance(point, endPoint);
                        
                        if (startDist <= maxDistance) {
                            nearbyList.push({
                                utility: utility,
                                connectPoint: 'start',
                                distance: startDist
                            });
                        }
                        
                        if (endDist <= maxDistance) {
                            nearbyList.push({
                                utility: utility,
                                connectPoint: 'end',
                                distance: endDist
                            });
                        }
                        
                        // If service connecting to main, check *entire* main line, not just endpoints
                        if (selectedLineType === 'service' && utility.lineType === 'main') {
                            // Check each segment of the main line
                            for (let i = 0; i < utilityPoints.length - 1; i++) {
                                const segmentStart = utilityPoints[i];
                                const segmentEnd = utilityPoints[i+1];
                                
                                // Calculate distance to segment
                                const segmentResult = projectOnSegment(point, segmentStart, segmentEnd);
                                
                                if (segmentResult.distance <= maxDistance) {
                                    nearbyList.push({
                                        utility: utility,
                                        connectPoint: 'middle',
                                        connectIndex: i,
                                        connectLatLng: segmentResult.point,
                                        distance: segmentResult.distance,
                                        // Store segment points for better connection
                                        segmentStart: segmentStart,
                                        segmentEnd: segmentEnd
                                    });
                                    
                                    // Only need closest point on this main
                                break;
                            }
                        }
                    }
                    });
                    
                    // Sort by distance
                    return nearbyList.sort((a, b) => a.distance - b.distance);
                }
                
                function nearestPointOnPolyline(point, polyline) {
                    if (!polyline || polyline.length < 2) {
                        return {
                            point: point,
                            index: 0,
                            distance: Infinity
                        };
                    }
                    
                    let minDist = Infinity;
                    let nearestPoint = null;
                    let segmentIndex = 0;
                    
                    for (let i = 0; i < polyline.length - 1; i++) {
                        const segmentResult = projectOnSegment(point, polyline[i], polyline[i+1]);
                        if (segmentResult.distance < minDist) {
                            minDist = segmentResult.distance;
                            nearestPoint = segmentResult.point;
                            segmentIndex = i;
                        }
                    }
                    
                    return {
                        point: nearestPoint || polyline[0],
                        index: segmentIndex,
                        distance: minDist
                    };
                }
                
                function createUtilityLine(points, utilityType, lineType, connectedTo = null) {
                    // Get utility colors
                    const colors = {
                        water: '#03a9f4',
                        gas: '#ff9800',
                        electric: '#ffeb3b',
                        sewer: '#795548',
                        telecom: '#9c27b0'
                    };
                    
                    // Create the polyline
                    const line = L.polyline(points, {
                        color: colors[utilityType],
                        weight: lineType === 'main' ? 6 : 4,
                        opacity: 1,
                        className: `utility-line ${lineType}`,
                        utilityType: utilityType,
                        lineType: lineType
                    }).addTo(utilitiesLayer);
                    
                    // Create utility marker at start
                    const markerIcon = createUtilityMarkerIcon(utilityType, lineType);
                    const marker = L.marker(points[0], {
                        icon: markerIcon,
                        draggable: true
                    }).addTo(utilitiesLayer);
                    
                    // Associate marker with line
                    line.utilityMarker = marker;
                    marker.utilityLine = line;
                    
                    // Generate a unique ID
                    const utilityId = 'utility-' + Date.now();
                    
                    // Create utility data object
                    const utilityData = {
                        id: utilityId,
                        type: utilityType,
                        lineType: lineType,
                        size: 4, // Default size
                        depth: 3, // Default depth
                        points: [...points],
                        marker: marker,
                        line: line,
                        connectedTo: connectedTo
                    };
                    
                    // Add to utilities collection
                    utilities[utilityType].push(utilityData);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utility',
                        utilityData: utilityData
                    });
                    
                    // Add click handlers
                    marker.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(marker);
                    });
                    
                    line.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(marker);
                    });
                    
                    // Update marker position when dragged
                    marker.on('drag', function(e) {
                        // Update line start point
                        const newPos = e.target.getLatLng();
                        const linePoints = [...line.getLatLngs()];
                        linePoints[0] = newPos;
                        
                        // Update line
                        line.setLatLngs(linePoints);
                        
                        // Update utility data
                        utilityData.points = linePoints;
                    });
                    
                    // Update status
                    updateStatus(`${utilityType} ${lineType} added`);
                    
                    return utilityData;
                }
                
                function connectUtilities(connectionType) {
                    if (!selectedElement || selectedElement.type !== 'connecting-utility') return;
                    
                    const { points, utilityType, lineType, nearbyUtilities } = selectedElement;
                    
                    // Check if there are any nearby utilities
                    if (!nearbyUtilities || nearbyUtilities.length === 0) {
                        createUtilityLine(points, utilityType, lineType);
                        return;
                    }
                    
                    const nearestUtility = nearbyUtilities[0]; // Use closest utility
                    
                    // Different connection logic based on type
                    if (connectionType === 'snap') {
                        // Snap connection between lines with smoothing
                        const connectedPoints = createSnapConnection(points, nearestUtility);
                        createUtilityLine(connectedPoints, utilityType, lineType, nearestUtility.utility.id);
                    } 
                    else if (connectionType === 'offset') {
                        // Create offset connection between endpoints
                        const connectedPoints = createOffsetConnection(points, nearestUtility);
                        createUtilityLine(connectedPoints, utilityType, lineType, nearestUtility.utility.id);
                    }
                    else if (connectionType === 'separate') {
                        // Just create the line without connection
                        createUtilityLine(points, utilityType, lineType);
                    }
                    
                    // Reset selected element
                    selectedElement = null;
                }
                
                function createSnapConnection(newPoints, nearUtility) {
                    const utility = nearUtility.utility;
                    const connectPoint = nearUtility.connectPoint;
                    
                    if (!utility || !utility.points || utility.points.length < 2) {
                        return newPoints;
                    }
                    
                    if (connectPoint === 'start') {
                        // Connect to start of existing utility
                        // Reverse existing utility points so we connect to the end
                        const existingPoints = [...utility.points].reverse();
                        
                        // Create a smooth arc-node-arc connection instead of simple Bézier
                        return createSmoothConnection(newPoints, existingPoints);
                    } 
                    else if (connectPoint === 'end') {
                        // Connect to end of existing utility
                        const existingPoints = [...utility.points];
                        
                        // Create a smooth arc-node-arc connection
                        return createSmoothConnection(newPoints, existingPoints);
                    }
                    else if (connectPoint === 'middle') {
                        // For services connecting to middle of a main
                        const connectLatLng = nearUtility.connectLatLng;
                        
                        // Get the segment this connects to
                        const segmentStart = nearUtility.segmentStart;
                        const segmentEnd = nearUtility.segmentEnd;
                        
                        // Insert the connection point into the main's points array
                        if (utility && utility.line) {
                            const utilityPoints = [...utility.line.getLatLngs()];
                            const index = nearUtility.connectIndex;
                            
                            // Insert the connection point
                            utilityPoints.splice(index + 1, 0, connectLatLng);
                            
                            // Update the line
                            utility.line.setLatLngs(utilityPoints);
                            utility.points = utilityPoints;
                        }
                        
                        // Create a perpendicular service line
                        // Calculate the perpendicular vector from the main
                        const connectedPoints = [...newPoints];
                        connectedPoints[0] = connectLatLng;
                        
                        // Apply smoothing to the connected points
                        return applySmoothingToLine(connectedPoints);
                    }
                    
                    return newPoints; // Default fallback
                }
                
                function createSmoothConnection(points1, points2) {
                    if (!points1 || points1.length < 2 || !points2 || points2.length < 2) {
                        return points1;
                    }
                    
                    // Create a new array for the combined points
                    const combinedPoints = [];
                    
                    // Add all points from the first segment except the last one
                    for (let i = 0; i < points1.length - 1; i++) {
                        combinedPoints.push(points1[i]);
                    }
                    
                    // Calculate the joining points
                    const p1End = points1[points1.length - 1];
                    const p2Start = points2[0];
                    
                    // Calculate control points for a smooth curve
                    const controlPoint1 = {
                        lat: p1End.lat + (p2Start.lat - p1End.lat) * 0.33,
                        lng: p1End.lng + (p2Start.lng - p1End.lng) * 0.33
                    };
                    
                    const controlPoint2 = {
                        lat: p1End.lat + (p2Start.lat - p1End.lat) * 0.66,
                        lng: p1End.lng + (p2Start.lng - p1End.lng) * 0.66
                    };
                    
                    // Add curve points
                    const numPoints = 5;
                    for (let i = 0; i <= numPoints; i++) {
                        const t = i / numPoints;
                        
                        // Cubic Bezier formula
                        const lat = Math.pow(1-t, 3) * p1End.lat + 
                                    3 * Math.pow(1-t, 2) * t * controlPoint1.lat + 
                                    3 * (1-t) * Math.pow(t, 2) * controlPoint2.lat + 
                                    Math.pow(t, 3) * p2Start.lat;
                        
                        const lng = Math.pow(1-t, 3) * p1End.lng + 
                                    3 * Math.pow(1-t, 2) * t * controlPoint1.lng + 
                                    3 * (1-t) * Math.pow(t, 2) * controlPoint2.lng + 
                                    Math.pow(t, 3) * p2Start.lng;
                        
                        combinedPoints.push(L.latLng(lat, lng));
                    }
                    
                    // Add remaining points from the second segment
                    for (let i = 1; i < points2.length; i++) {
                        combinedPoints.push(points2[i]);
                    }
                    
                    return combinedPoints;
                }
                
                function createOffsetConnection(newPoints, nearUtility) {
                    const utility = nearUtility.utility;
                    const connectPoint = nearUtility.connectPoint;
                    
                    if (!utility || !utility.points || utility.points.length < 2) {
                        return newPoints;
                    }
                    
                    if (connectPoint === 'start') {
                        // Direct connection to start
                        const startPoint = utility.points[0];
                        const connectedPoints = [...newPoints];
                        connectedPoints[0] = startPoint;
                        return connectedPoints;
                    } 
                    else if (connectPoint === 'end') {
                        // Direct connection to end
                        const endPoint = utility.points[utility.points.length - 1];
                        const connectedPoints = [...newPoints];
                        connectedPoints[0] = endPoint;
                        return connectedPoints;
                    }
                    else if (connectPoint === 'middle') {
                        // For services connecting to middle of a main
                        const connectLatLng = nearUtility.connectLatLng;
                        const connectedPoints = [...newPoints];
                        connectedPoints[0] = connectLatLng;
                        return connectedPoints;
                    }
                    
                    return newPoints; // Default fallback
                }
                
                function smoothConnectPoints(points1, points2) {
                    if (!points1 || points1.length < 2 || !points2 || points2.length < 2) {
                        return points1;
                    }
                    
                    try {
                        // Get the first few points from each set
                        const start1 = points1[0];
                        const next1 = points1[1];
                        const start2 = points2[0];
                        const next2 = points2[1];
                        
                        // Calculate the vectors at each end
                        const vec1 = {
                            x: next1.lng - start1.lng,
                            y: next1.lat - start1.lat
                        };
                        
                        const vec2 = {
                            x: next2.lng - start2.lng,
                            y: next2.lat - start2.lat
                        };
                        
                        // Calculate the average vector
                        const avgVec = {
                            x: (vec1.x + vec2.x) / 2,
                            y: (vec1.y + vec2.y) / 2
                        };
                        
                        // Normalize the average vector
                        const length = Math.sqrt(avgVec.x * avgVec.x + avgVec.y * avgVec.y);
                        
                        // Check for zero length to avoid division by zero
                        if (length > 1e-10) {
                            avgVec.x /= length;
                            avgVec.y /= length;
                        } else {
                            // If vectors are opposite, use a default offset
                            avgVec.x = 0;
                            avgVec.y = -0.0001;
                        }
                        
                        // Calculate the smooth connection point
                        const connPoint = L.latLng(
                            start1.lat - avgVec.y * 0.0001, // Small offset for smooth transition
                            start1.lng - avgVec.x * 0.0001
                        );
                        
                        // Combine points with the connecting point
                        const combinedPoints = [connPoint];
                        
                        // Add remaining points from points1
                        for (let i = 0; i < points1.length; i++) {
                            combinedPoints.push(points1[i]);
                        }
                        
                        return combinedPoints;
                    } catch (err) {
                        console.error('Error creating smooth connection', err);
                        return points1;
                    }
                }
                
                function createUtilityMarkerIcon(utilityType, lineType) {
                    // Get utility colors and icons
                    const colors = {
                        water: '#03a9f4',
                        gas: '#ff9800',
                        electric: '#ffeb3b',
                        sewer: '#795548',
                        telecom: '#9c27b0'
                    };
                    
                    const icons = {
                        water: 'tint',
                        gas: 'fire',
                        electric: 'bolt',
                        sewer: 'toilet',
                        telecom: 'phone'
                    };
                    
                    // Create HTML for the icon
                    const html = `
                        <div class="utility-marker" style="background-color: ${colors[utilityType]};">
                            <i class="fas fa-${icons[utilityType]}"></i>
                            ${lineType === 'main' ? '<div class="main-indicator">M</div>' : ''}
                        </div>
                    `;
                    
                    return L.divIcon({
                        html: html,
                        className: '',
                        iconSize: [40, 40],
                        iconAnchor: [20, 20]
                    });
                }
                
                function showUtilityInfo(marker) {
                    // Find the utility data
                    const line = marker.utilityLine;
                    if (!line) return;
                    
                    const utilityType = line.options.utilityType;
                    const utility = utilities[utilityType].find(u => u.line === line);
                    
                    if (!utility) return;
                    
                    // Update info card contents
                    document.getElementById('info-type').textContent = utilityType.charAt(0).toUpperCase() + utilityType.slice(1);
                    document.getElementById('info-line-type').textContent = utility.lineType.charAt(0).toUpperCase() + utility.lineType.slice(1);
                    document.getElementById('info-size').textContent = `${utility.size || 4} inches`;
                    document.getElementById('info-depth').textContent = `${utility.depth || 3} feet`;
                    
                    // Calculate direction
                    const points = utility.points;
                    if (points && points.length >= 2) {
                        const start = points[0];
                        const end = points[1];
                        const angle = calculateAngle(start, end);
                        document.getElementById('info-direction').textContent = getDirectionName(angle);
                    } else {
                        document.getElementById('info-direction').textContent = 'Unknown';
                    }
                    
                    // Handle media if present
                    const mediaContainer = document.getElementById('info-media-container');
                    if (utility.mediaData) {
                        // Check if image or video based on media type
                        if (utility.mediaData.startsWith('data:image')) {
                            mediaContainer.innerHTML = `<img src="${utility.mediaData}" alt="Utility photo">`;
                        } else if (utility.mediaData.startsWith('data:video')) {
                            mediaContainer.innerHTML = `<video controls width="100%"><source src="${utility.mediaData}" type="video/mp4"></video>`;
                        }
                        mediaContainer.style.display = 'block';
                    } else {
                        mediaContainer.innerHTML = '';
                        mediaContainer.style.display = 'none';
                    }
                    
                    // Position the info card
                    const markerPoint = map.latLngToContainerPoint(marker.getLatLng());
                    const infoCard = document.getElementById('utility-info-card');
                    infoCard.style.left = `${markerPoint.x + 20}px`;
                    infoCard.style.top = `${markerPoint.y - 100}px`;
                    
                    // Show the card
                    infoCard.style.display = 'block';
                    
                    // Store reference to the selected utility
                    selectedElement = {
                        type: 'utility-info',
                        utility: utility
                    };
                }
                
                function hideUtilityInfo() {
                    document.getElementById('utility-info-card').style.display = 'none';
                    
                    if (selectedElement && selectedElement.type === 'utility-info') {
                        selectedElement = null;
                    }
                }
                
                function calculateAngle(start, end) {
                    if (!start || !end) return 0;
                    
                    // Calculate angle in degrees (0 = North, clockwise)
                    const dx = end.lng - start.lng;
                    const dy = end.lat - start.lat;
                    
                    // Prevent division by zero or very small numbers
                    if (Math.abs(dx) < 1e-10 && Math.abs(dy) < 1e-10) {
                        return 0;
                    }
                    
                    let angle = Math.atan2(dx, dy) * 180 / Math.PI;
                    
                    // Normalize to 0-360
                    if (angle < 0) angle += 360;
                    
                    return angle;
                }
                
                function getDirectionName(angle) {
                    // Convert angle to compass direction
                    const directions = ['North', 'Northeast', 'East', 'Southeast', 
                                       'South', 'Southwest', 'West', 'Northwest'];
                    const index = Math.round(((angle + 22.5) % 360) / 45) % 8;
                    return directions[index];
                }
                
                function calculateEndPoint(startLatLng, angleDegrees, lengthMeters) {
                    if (!startLatLng) return null;
                    
                    try {
                        // Convert angle to radians (0 is North, clockwise)
                        const angleRadians = (90 - angleDegrees) * Math.PI / 180;
                        
                        // Earth's radius in meters
                        const R = 6378137;
                        
                        // Convert length to radians
                        const d = lengthMeters / R;
                        
                        // Convert start point to radians
                        const lat1 = startLatLng.lat * Math.PI / 180;
                        const lng1 = startLatLng.lng * Math.PI / 180;
                        
                        // Calculate end point
                        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) + 
                                               Math.cos(lat1) * Math.sin(d) * Math.cos(angleRadians));
                        
                        const lng2 = lng1 + Math.atan2(
                            Math.sin(angleRadians) * Math.sin(d) * Math.cos(lat1),
                            Math.cos(d) - Math.sin(lat1) * Math.sin(lat2)
                        );
                        
                        // Convert back to degrees
                        return L.latLng(lat2 * 180 / Math.PI, lng2 * 180 / Math.PI);
                    } catch (err) {
                        console.error('Error calculating end point:', err);
                        
                        // Fallback - create a point 10 meters north
                        const north = L.latLng(startLatLng.lat + 0.0001, startLatLng.lng);
                        return north;
                    }
                }
                
                function handleMapClick(e) {
                    // Hide context menu if open
                    hideContextMenu();
                    
                    // Hide utility info card if open
                    hideUtilityInfo();
                    
                    // Handle click based on mode and active tool
                    if (activeMode === 'drainage') {
                        if (activeTool === 'add-basin-btn') {
                            addCatchBasin(e.latlng);
                        }
                        else if (activeTool === 'add-pitch-btn') {
                            if (!isDrawing) {
                                // Find nearest curb
                                let nearestCurb = null;
                                let minDist = Infinity;
                                
                                curbs.forEach(curb => {
                                    const result = nearestPointOnCurb(e.latlng, curb);
                                    if (result && result.distance < minDist) {
                                        minDist = result.distance;
                                        nearestCurb = curb;
                                    }
                                });
                                
                                // If within 10 meters of a curb, start drawing
                                if (nearestCurb && minDist <= 10) {
                                    startCurbPitch(e.latlng, nearestCurb);
                                } else {
                                    showNotification('Click on or near a curb to add a pitch');
                                }
                            }
                            else {
                                // Find nearest point on current drawing curb
                                const result = nearestPointOnCurb(e.latlng, drawingCurb);
                                
                                // Complete drawing if valid point and different from start
                                if (result && result.distance <= 10 && result.index > drawingStartIndex) {
                                    completeCurbPitch(result.point, result.index);
                                }
                            }
                        }
                    }
                    else if (activeMode === 'utility') {
                        if (['water-btn', 'gas-btn', 'electric-btn', 'sewer-btn', 'telecom-btn'].includes(activeTool)) {
                            // Show utility workflow modal
                            tempUtilityLocation = e.latlng;
                            showModal('utility-workflow-modal');
                        }
                        else if (activeTool === 'utility-found-btn') {
                            addUtilityFound(e.latlng);
                        }
                        else if (activeTool === 'mapping-btn') {
                            if (isDrawing && currentDrawingType === 'utility') {
                                handleUtilityMappingClick(e.latlng);
                            }
                            else {
                                startUtilityMapping();
                                // Add first point immediately
                                handleUtilityMappingClick(e.latlng);
                            }
                        }
                    }
                }
                
                function handleMouseMove(e) {
                    // Update temporary line during drawing
                    if (isDrawing && tempLine) {
                        let movePoint = e.latlng;
                        
                        // For curb pitch drawing, snap to curb
                        if (currentDrawingType === 'pitch' && isSnapping && drawingCurb) {
                            const result = nearestPointOnCurb(e.latlng, drawingCurb);
                            if (result && result.distance <= 20) {
                                movePoint = result.point;
                                nearestValidPoint = result.point;
                            } else {
                                nearestValidPoint = null;
                            }
                        }
                        
                        // Update temp line
                        const points = [...drawingPoints, movePoint];
                        tempLine.setLatLngs(points);
                    }
                }
                
                function handleTouchMove(e) {
                    // Get touch position
                    if (e.touches && e.touches.length > 0) {
                        const touch = e.touches[0];
                        const containerPoint = L.point(touch.clientX, touch.clientY);
                        const latlng = map.containerPointToLatLng(containerPoint);
                        
                        // Update temporary line during drawing
                        if (isDrawing && tempLine) {
                            let movePoint = latlng;
                            
                            // For curb pitch drawing, snap to curb
                            if (currentDrawingType === 'pitch' && isSnapping && drawingCurb) {
                                const result = nearestPointOnCurb(latlng, drawingCurb);
                                if (result && result.distance <= 20) {
                                    movePoint = result.point;
                                    nearestValidPoint = result.point;
                                } else {
                                    nearestValidPoint = null;
                                }
                            }
                            
                            // Update temp line
                            const points = [...drawingPoints, movePoint];
                            tempLine.setLatLngs(points);
                        }
                    }
                }
                
                function handleContextMenu(e) {
                    // Check for elements under click
                    let clickedElement = findElementAtPoint(e.latlng);
                    
                    if (clickedElement) {
                        // Show context menu for the element
                        showContextMenu(e, clickedElement);
                    }
                }
                
                function findElementAtPoint(latlng) {
                    let foundElement = null;
                    let elementType = null;
                    
                    // Check drainage elements if in drainage mode
                    if (activeMode === 'drainage') {
                        // Check pitch lines
                        curbPitchesLayer.eachLayer(function(layer) {
                            if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                                const distance = distanceToPolyline(latlng, layer.getLatLngs());
                                if (distance <= 10) {
                                    foundElement = layer;
                                    elementType = 'pitch';
                                    
                                    // Find the pitch data
                                    curbs.forEach(curb => {
                                        curb.pitches.forEach(pitch => {
                                            if (pitch.line === layer) {
                                                foundElement = {
                                                    element: layer,
                                                    pitch: pitch,
                                                    curb: curb
                                                };
                                            }
                                        });
                                    });
                                }
                            }
                        });
                        
                        // Check catch basins
                        if (!foundElement) {
                            catchBasinsLayer.eachLayer(function(layer) {
                                if (layer instanceof L.Marker) {
                                    const distance = map.distance(latlng, layer.getLatLng());
                                    if (distance <= 10) {
                                        foundElement = layer;
                                        elementType = 'basin';
                                    }
                                }
                            });
                        }
                    }
                    // Check utility elements if in utility mode
                    else if (activeMode === 'utility') {
                        // Check utility lines
                        utilitiesLayer.eachLayer(function(layer) {
                            if (layer instanceof L.Polyline) {
                                const distance = distanceToPolyline(latlng, layer.getLatLngs());
                                if (distance <= 10) {
                                    const utilityType = layer.options.utilityType;
                                    const utility = utilities[utilityType].find(u => u.line === layer);
                                    
                                    if (utility) {
                                        foundElement = {
                                            element: layer,
                                            utility: utility
                                        };
                                        elementType = 'utility';
                                    }
                                }
                            }
                        });
                        
                        // Check utility markers
                        if (!foundElement) {
                            utilitiesLayer.eachLayer(function(layer) {
                                if (layer instanceof L.Marker) {
                                    const distance = map.distance(latlng, layer.getLatLng());
                                    if (distance <= 10) {
                                        const line = layer.utilityLine;
                                        if (line) {
                                            const utilityType = line.options.utilityType;
                                            const utility = utilities[utilityType].find(u => u.marker === layer);
                                            
                                            if (utility) {
                                                foundElement = {
                                                    element: layer,
                                                    utility: utility
                                                };
                                                elementType = 'utility';
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    }
                    
                    if (foundElement) {
                        return {
                            element: foundElement,
                            type: elementType
                        };
                    }
                    
                    return null;
                }
                
                function distanceToPolyline(point, polyline) {
                    if (!polyline || polyline.length < 2) return Infinity;
                    
                    let minDist = Infinity;
                    
                    for (let i = 0; i < polyline.length - 1; i++) {
                        const segmentResult = projectOnSegment(point, polyline[i], polyline[i+1]);
                        if (segmentResult.distance < minDist) {
                            minDist = segmentResult.distance;
                        }
                    }
                    
                    return minDist;
                }
                
                function showContextMenu(e, clickedElement) {
                    // Set the selected element
                    selectedElement = clickedElement;
                    
                    // Get container point
                    const containerPoint = map.latLngToContainerPoint(e.latlng);
                    
                    // Position the context menu
                    const contextMenu = document.getElementById('context-menu');
                    contextMenu.style.left = `${containerPoint.x}px`;
                    contextMenu.style.top = `${containerPoint.y}px`;
                    
                    // Adjust visible menu items based on element type
                    const editItem = document.getElementById('edit-item');
                    const reverseItem = document.getElementById('reverse-direction');
                    
                    if (clickedElement.type === 'pitch') {
                        editItem.style.display = 'flex';
                        reverseItem.style.display = 'flex';
                    } else if (clickedElement.type === 'basin') {
                        editItem.style.display = 'none';
                        reverseItem.style.display = 'none';
                    } else if (clickedElement.type === 'utility') {
                        editItem.style.display = 'flex';
                        reverseItem.style.display = 'none';
                    }
                    
                    // Show the menu
                    contextMenu.style.display = 'block';
                }
                
                function hideContextMenu() {
                    document.getElementById('context-menu').style.display = 'none';
                }
                
                function reversePitchDirection() {
                    if (!selectedElement || selectedElement.type !== 'pitch') return;
                    
                    const pitchData = selectedElement.pitch;
                    const line = pitchData.line;
                    const curb = selectedElement.curb;
                    
                    // Reverse the line points
                    const latlngs = [...line.getLatLngs()].reverse();
                    line.setLatLngs(latlngs);
                    
                    // Update the pitch angle
                    pitchData.angle = (pitchData.angle + 180) % 360;
                    
                    // Swap start and end indices
                    const temp = pitchData.startIndex;
                    pitchData.startIndex = pitchData.endIndex;
                    pitchData.endIndex = temp;
                    
                    // Toggle the flow direction if it exists
                    if (pitchData.flowDirection !== undefined) {
                        pitchData.flowDirection = !pitchData.flowDirection;
                    }
                    
                    // Remove old markers
                    if (line.arrowMarker) {
                        curbPitchesLayer.removeLayer(line.arrowMarker);
                    }
                    
                    if (line.labelMarker) {
                        curbPitchesLayer.removeLayer(line.labelMarker);
                    }
                    
                    // Add new arrow and label
                    addPitchArrow(line, pitchData.angle);
                    addPitchLabel(line, pitchData.percent);
                    
                    // Update drainage heatmap
                    updateDrainageHeatmap();
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Update status
                    updateStatus('Pitch direction reversed');
                }
                
                function deleteElement() {
                    if (!selectedElement) return;
                    
                    if (selectedElement.type === 'pitch') {
                        const pitchData = selectedElement.pitch;
                        const line = pitchData.line;
                        const curb = selectedElement.curb;
                        
                        // Remove from curb data
                        const pitchIndex = curb.pitches.findIndex(p => p === pitchData);
                        if (pitchIndex !== -1) {
                            curb.pitches.splice(pitchIndex, 1);
                        }
                        
                        // Remove markers
                        if (line.arrowMarker) {
                            curbPitchesLayer.removeLayer(line.arrowMarker);
                        }
                        
                        if (line.labelMarker) {
                            curbPitchesLayer.removeLayer(line.labelMarker);
                        }
                        
                        // Remove line
                        curbPitchesLayer.removeLayer(line);
                        
                        // Update available curbs
                        showAvailableCurbs();
                        
                        // Update drainage heatmap
                        updateDrainageHeatmap();
                    }
                    else if (selectedElement.type === 'basin') {
                        const marker = selectedElement.element;
                        
                        // Remove from drainage points
                        const drainageIndex = drainagePoints.findIndex(p => p.marker === marker);
                        if (drainageIndex !== -1) {
                            drainagePoints.splice(drainageIndex, 1);
                        }
                        
                        // Remove marker
                        catchBasinsLayer.removeLayer(marker);
                        
                        // Update drainage heatmap
                        updateDrainageHeatmap();
                    }
                    else if (selectedElement.type === 'utility') {
                        const utility = selectedElement.utility;
                        
                        // Remove from utilities data
                        const utilityIndex = utilities[utility.type].findIndex(u => u === utility);
                        if (utilityIndex !== -1) {
                            utilities[utility.type].splice(utilityIndex, 1);
                        }
                        
                        // Remove marker and line
                        if (utility.marker) {
                            utilitiesLayer.removeLayer(utility.marker);
                        }
                        
                        if (utility.line) {
                            utilitiesLayer.removeLayer(utility.line);
                        }
                    }
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Update status
                    updateStatus('Element deleted');
                }
                
                function selectElement(element, type) {
                    // Create selected element data
                    let data = { element: element, type: type };
                    
                    // Get additional data based on type
                    if (type === 'pitch') {
                        // Find the pitch data
                        curbs.forEach(curb => {
                            curb.pitches.forEach(pitch => {
                                if (pitch.line === element) {
                                    data = {
                                        element: element,
                                        pitch: pitch,
                                        curb: curb,
                                        type: type
                                    };
                                }
                            });
                        });
                    }
                    else if (type === 'utility') {
                        // Find the utility data
                        const line = element.utilityLine || element;
                        const utilityType = line.options.utilityType;
                        const utility = utilities[utilityType].find(u => 
                            u.line === line || u.marker === element);
                        
                        if (utility) {
                            data = {
                                element: element,
                                utility: utility,
                                type: type
                            };
                        }
                    }
                    
                    // Store selected element
                    selectedElement = data;
                }
                
                function getUserLocation() {
                    // Update status
                    updateStatus('Finding your location...');
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Set a timeout for geolocation (10 seconds)
                    const locationTimeout = setTimeout(() => {
                        document.querySelector('.loading-overlay').style.display = 'none';
                        showNotification('Location timeout. Please try again.');
                        updateStatus('Failed to get your location. Please try again or enter an address.');
                    }, 10000);
                    
                    // Check if geolocation is available
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(function(position) {
                            // Clear timeout
                            clearTimeout(locationTimeout);
                            
                            // Store position
                            currentPosition = [position.coords.latitude, position.coords.longitude];
                            
                            // Update map center
                            map.setView(currentPosition, 19);
                            
                            // Create user marker if not exists
                            if (!userMarker) {
                                userMarker = L.circleMarker(currentPosition, {
                                    radius: 8,
                                    fillColor: '#2962ff',
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(map);
                            } else {
                                userMarker.setLatLng(currentPosition);
                            }
                            
                            // Load road data for current view
                            loadRoadData();
                    
                    // Update status
                            updateStatus('Select a tool to begin');
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Hide location modal if it's open
                            hideModal('location-modal');
                            
                            // Watch position for updates
                            const watchId = navigator.geolocation.watchPosition(function(position) {
                                // Update current position
                                currentPosition = [position.coords.latitude, position.coords.longitude];
                                
                                // Update user marker
                                if (userMarker) {
                                    userMarker.setLatLng(currentPosition);
                                }
                            }, function(error) {
                                console.error('Error watching position:', error);
                            }, {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 5000
                            });
                            
                            // Store watch ID for cleanup
                            window.locationWatchId = watchId;
                            
                        }, function(error) {
                            // Clear timeout
                            clearTimeout(locationTimeout);
                            
                            console.error('Error getting location:', error);
                            
                            let errorMsg = 'Location access denied.';
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMsg = 'Location access denied. Please enable GPS and refresh.';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMsg = 'Location unavailable. Try entering an address instead.';
                                    break;
                                case error.TIMEOUT:
                                    errorMsg = 'Location request timed out. Please try again.';
                                    break;
                            }
                            
                            // Update status
                            updateStatus(errorMsg);
                            showNotification(errorMsg);
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                        }, {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 10000
                        });
                    } else {
                        // Clear timeout
                        clearTimeout(locationTimeout);
                    
                    // Update status
                        updateStatus('Geolocation not supported in this browser. Try entering an address.');
                        showNotification('Geolocation not supported in this browser');
                        
                        // Hide loading overlay
                        document.querySelector('.loading-overlay').style.display = 'none';
                    }
                }
                
                function searchLocation() {
                    const address = document.getElementById('address-input').value;
                    
                    if (!address) {
                        showNotification('Please enter an address to search');
                        return;
                    }
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Build search query with borough if selected
                    let searchQuery = address;
                    if (selectedBorough) {
                        if (!searchQuery.toLowerCase().includes(selectedBorough.toLowerCase())) {
                            searchQuery += `, ${selectedBorough}, NYC`;
                        }
                    } else {
                        searchQuery += ', NYC';
                    }
                    
                    // Use Nominatim for geocoding (OpenStreetMap's geocoding service)
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Network error: ${response.status}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            if (data && data.length > 0) {
                                const result = data[0];
                                const lat = parseFloat(result.lat);
                                const lon = parseFloat(result.lon);
                                
                                // Update map view
                                map.setView([lat, lon], 19);
                                
                                // Load road data for this area
                                loadRoadData();
                                
                                // Hide location modal
                                hideModal('location-modal');
                                
                                // Hide loading overlay
                                document.querySelector('.loading-overlay').style.display = 'none';
                                
                                // Show notification
                                showNotification(`Located: ${result.display_name}`);
                            } else {
                                // Hide loading overlay
                                document.querySelector('.loading-overlay').style.display = 'none';
                                
                                // Show error notification
                                showNotification('Address not found. Please try again with a different address.');
                            }
                        })
                        .catch(error => {
                            console.error('Error searching location:', error);
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Show error notification
                            showNotification('Error searching location. Please try again later.');
                        });
                }
                
                function showNotification(message) {
                    const notification = document.getElementById('notification');
                    document.getElementById('notification-text').textContent = message;
                    notification.classList.add('visible');
                    
                    setTimeout(() => {
                        notification.classList.remove('visible');
                    }, 3000);
                }
                
                function updateStatus(message) {
                    document.getElementById('status-text').textContent = message;
                }
                
                function addToUndoStack(action) {
                    undoStack.push(action);
                    
                    // Limit undo stack size
                    if (undoStack.length > MAX_UNDO_STACK_SIZE) {
                        undoStack.shift(); // Remove oldest action
                    }
                    
                    updateUndoButtonState();
                }
                
                function undoLastAction() {
                    if (undoStack.length === 0) return;
                    
                    const action = undoStack.pop();
                    
                    if (action.type === 'curb-pitch') {
                        // Find the curb and pitch
                        const curb = curbs.find(c => c.id === action.curbId);
                        if (curb) {
                            // Find and remove the pitch
                            const pitchIndex = curb.pitches.findIndex(p => 
                                p.startIndex === action.startIndex && p.endIndex === action.endIndex);
                            
                            if (pitchIndex !== -1) {
                                const pitch = curb.pitches[pitchIndex];
                                
                                // Remove markers
                                if (pitch.line.arrowMarker) {
                                    curbPitchesLayer.removeLayer(pitch.line.arrowMarker);
                                }
                                
                                if (pitch.line.labelMarker) {
                                    curbPitchesLayer.removeLayer(pitch.line.labelMarker);
                                }
                                
                                // Remove line
                                curbPitchesLayer.removeLayer(pitch.line);
                                
                                // Remove from array
                                curb.pitches.splice(pitchIndex, 1);
                            }
                        }
                        
                        // Update available curbs
                        showAvailableCurbs();
                        
                        // Update drainage heatmap
                        updateDrainageHeatmap();
                    }
                    else if (action.type === 'catch-basin') {
                        // Find and remove basin from drainagePoints
                        const drainageIndex = drainagePoints.findIndex(p => p.marker === action.marker);
                        if (drainageIndex !== -1) {
                            drainagePoints.splice(drainageIndex, 1);
                        }
                        
                        // Remove marker
                        catchBasinsLayer.removeLayer(action.marker);
                        
                        // Update drainage heatmap
                        updateDrainageHeatmap();
                    }
                    else if (action.type === 'utility') {
                        // Remove utility data
                        const utility = action.utilityData;
                        const utilityIndex = utilities[utility.type].findIndex(u => u.id === utility.id);
                        
                        if (utilityIndex !== -1) {
                            utilities[utility.type].splice(utilityIndex, 1);
                        }
                        
                        // Remove markers and lines
                        if (utility.marker) {
                            utilitiesLayer.removeLayer(utility.marker);
                        }
                        
                        if (utility.line) {
                            utilitiesLayer.removeLayer(utility.line);
                        }
                    }
                    
                    // Update undo button state
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('Last action undone');
                }
                
                function updateUndoButtonState() {
                    // Update undo button based on stack state
                    const undoButton = document.getElementById('undo-btn');
                    
                    if (undoStack.length > 0) {
                        undoButton.style.opacity = '1';
                    } else {
                        undoButton.style.opacity = '0.5';
                    }
                }
                
                function clearDrainage() {
                    // Confirm before clearing
                    if (!confirm('Are you sure you want to clear all drainage data?')) {
                        return;
                    }
                    
                    // Clear all drainage layers
                    catchBasinsLayer.clearLayers();
                    curbPitchesLayer.clearLayers();
                    
                    // Clear drainage points
                    drainagePoints = [];
                    
                    // Clear pitches from curbs
                    curbs.forEach(curb => {
                        curb.pitches = [];
                    });
                    
                    // Update available curbs
                    showAvailableCurbs();
                    
                    // Update drainage heatmap
                    updateDrainageHeatmap();
                    
                    // Clear undo stack
                    undoStack = [];
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('All drainage data cleared');
                }
                
                function clearUtilities() {
                    // Confirm before clearing
                    if (!confirm('Are you sure you want to clear all utility data?')) {
                        return;
                    }
                    
                    // Clear utility layer
                    utilitiesLayer.clearLayers();
                    
                    // Clear utilities data
                    utilities = {
                        water: [],
                        gas: [],
                        electric: [],
                        sewer: [],
                        telecom: []
                    };
                    
                    // Clear undo stack
                    undoStack = [];
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('All utility data cleared');
                }
                
                function showModal(modalId) {
                    document.getElementById(modalId).style.display = 'flex';
                }
                
                function hideModal(modalId) {
                    document.getElementById(modalId).style.display = 'none';
                }
                
                function toggleLayer(layerName, visible) {
                    // Toggle layer visibility based on name and mode
                    if (activeMode === 'drainage') {
                        if (layerName === 'basins') {
                            if (visible) {
                                if (!map.hasLayer(catchBasinsLayer)) {
                                    map.addLayer(catchBasinsLayer);
                                }
                            } else {
                                if (map.hasLayer(catchBasinsLayer)) {
                                    map.removeLayer(catchBasinsLayer);
                                }
                            }
                        } 
                        else if (layerName === 'pitches') {
                            if (visible) {
                                if (!map.hasLayer(curbPitchesLayer)) {
                                    map.addLayer(curbPitchesLayer);
                                }
                            } else {
                                if (map.hasLayer(curbPitchesLayer)) {
                                    map.removeLayer(curbPitchesLayer);
                                }
                            }
                        }
                        else if (layerName === 'available-curbs') {
                            if (visible) {
                                if (!map.hasLayer(curbAvailableLayer)) {
                                    map.addLayer(curbAvailableLayer);
                                }
                            } else {
                                if (map.hasLayer(curbAvailableLayer)) {
                                    map.removeLayer(curbAvailableLayer);
                                }
                            }
                        }
                        else if (layerName === 'heatmap') {
                            if (visible) {
                                if (drainageHeatmapLayer && !map.hasLayer(drainageHeatmapLayer)) {
                                    map.addLayer(drainageHeatmapLayer);
                                }
                            } else {
                                if (drainageHeatmapLayer && map.hasLayer(drainageHeatmapLayer)) {
                                    map.removeLayer(drainageHeatmapLayer);
                                }
                            }
                        }
                    }
                    else if (activeMode === 'utility') {
                        // For utility type layers (water, gas, etc.)
                        if (['water', 'gas', 'electric', 'sewer', 'telecom'].includes(layerName)) {
                            // Show/hide all utilities of this type
                            utilities[layerName].forEach(utility => {
                                if (utility.marker && utility.line) {
                                    if (visible) {
                                        if (!map.hasLayer(utility.marker)) {
                                            utilitiesLayer.addLayer(utility.marker);
                                        }
                                        if (!map.hasLayer(utility.line)) {
                                            utilitiesLayer.addLayer(utility.line);
                                        }
                                    } else {
                                        if (map.hasLayer(utility.marker)) {
                                            utilitiesLayer.removeLayer(utility.marker);
                                        }
                                        if (map.hasLayer(utility.line)) {
                                            utilitiesLayer.removeLayer(utility.line);
                                        }
                                    }
                                }
                            });
                        }
                        // For line type layers (mains, services)
                        else if (layerName === 'mains' || layerName === 'services') {
                            // Get type to show/hide
                            const lineType = layerName === 'mains' ? 'main' : 'service';
                            
                            // Loop through all utility types
                            for (const type in utilities) {
                                utilities[type].forEach(utility => {
                                    if (utility.lineType === lineType) {
                                        if (utility.marker && utility.line) {
                                            if (visible) {
                                                if (!map.hasLayer(utility.marker)) {
                                                    utilitiesLayer.addLayer(utility.marker);
                                                }
                                                if (!map.hasLayer(utility.line)) {
                                                    utilitiesLayer.addLayer(utility.line);
                                                }
                                            } else {
                                                if (map.hasLayer(utility.marker)) {
                                                    utilitiesLayer.removeLayer(utility.marker);
                                                }
                                                if (map.hasLayer(utility.line)) {
                                                    utilitiesLayer.removeLayer(utility.line);
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
                
                function setActiveMode(mode) {
                    // Update mode buttons
                    document.getElementById('drainage-mode').classList.remove('active');
                    document.getElementById('utility-mode').classList.remove('active');
                    document.getElementById(mode + '-mode').classList.add('active');
                    
                    // Update active mode
                    activeMode = mode;
                    
                    // Show/hide toolbars
                    if (mode === 'drainage') {
                        document.getElementById('drainage-toolbar').style.display = 'flex';
                        document.getElementById('utility-toolbar').style.display = 'none';
                        document.getElementById('drainage-layers').style.display = 'block';
                        document.getElementById('utility-layers').style.display = 'none';
                        
                        // Show drainage layers
                        if (document.getElementById('basins-toggle').checked) {
                            map.addLayer(catchBasinsLayer);
                        }
                        if (document.getElementById('pitches-toggle').checked) {
                            map.addLayer(curbPitchesLayer);
                        }
                        if (document.getElementById('available-curbs-toggle').checked) {
                            map.addLayer(curbAvailableLayer);
                        }
                        if (document.getElementById('heatmap-toggle').checked && drainageHeatmapLayer) {
                            map.addLayer(drainageHeatmapLayer);
                        }
                        
                        // Hide any utility UI elements and the layer
                        hideUtilityInfo();
                        hideContextMenu();
                        map.removeLayer(utilitiesLayer);
                        
                        // Generate curb availability areas if not already done
                        showAvailableCurbs();
                        
                        // Update drainage heatmap if needed
                        if (!drainageHeatmapLayer) {
                            initDrainageHeatmap();
                        } else {
                            updateDrainageHeatmap();
                        }
                    } 
                    else if (mode === 'utility') {
                        document.getElementById('drainage-toolbar').style.display = 'none';
                        document.getElementById('utility-toolbar').style.display = 'flex';
                        document.getElementById('drainage-layers').style.display = 'none';
                        document.getElementById('utility-layers').style.display = 'block';
                        
                        // Hide drainage layers
                        map.removeLayer(catchBasinsLayer);
                        map.removeLayer(curbPitchesLayer);
                        map.removeLayer(curbAvailableLayer);
                        if (drainageHeatmapLayer) {
                            map.removeLayer(drainageHeatmapLayer);
                        }
                        
                        // Show utility layers
                        map.addLayer(utilitiesLayer);
                    }
                    
                    // Reset active tool
                    setActiveTool(null);
                    
                    // Cancel any active drawing
                    cancelDrawing();
                    
                    // Update status
                    updateStatus(`Switched to ${mode} mode`);
                }
                
                function setActiveTool(toolId) {
                    // Get all tool buttons
                    const toolbarButtons = document.querySelectorAll('.toolbar-button');
                    
                    // Remove active class from all
                    toolbarButtons.forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Set active tool
                    activeTool = toolId;
                    
                    // Add active class to selected tool
                    if (toolId) {
                        document.getElementById(toolId).classList.add('active');
                    }
                    
                    // Update status based on selected tool
                    if (activeMode === 'drainage') {
                        if (toolId === 'add-basin-btn') {
                            updateStatus('Tap to add a catch basin');
                        } else if (toolId === 'add-pitch-btn') {
                            updateStatus('Tap on a curb to add a pitch');
                        } else if (toolId === 'edit-pitch-btn') {
                            updateStatus('Tap on a pitch to edit it');
                        } else if (toolId === 'analyze-drainage-btn') {
                            // For analyze button, immediately run analysis instead of setting a tool
                            analyzeDrainage();
                            // Reset active tool after analysis
                            setActiveTool(null);
                            return;
                        } else {
                            updateStatus('Select a tool to begin');
                        }
                    } 
                    else if (activeMode === 'utility') {
                        // Utility tool handling (unchanged)
                        if (toolId === 'utility-found-btn') {
                            updateStatus('Click to mark a utility that was found');
                        } else if (toolId === 'mapping-btn') {
                            if (selectedUtilityType && selectedLineType) {
                                updateStatus(`Click to start mapping a ${selectedUtilityType} ${selectedLineType}`);
                            } else {
                                updateStatus('Select a utility type first');
                            }
                        } else if (['water-btn', 'gas-btn', 'electric-btn', 'sewer-btn', 'telecom-btn'].includes(toolId)) {
                            // Set selected utility type
                            selectedUtilityType = toolId.replace('-btn', '');
                            updateStatus(`Selected ${selectedUtilityType}. Now choose 'Found' or 'Map'`);
                        } else {
                            updateStatus('Select a tool to begin');
                        }
                    }
                }
                
                function cancelDrawing() {
                    // Clear any temporary drawing
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Reset drawing state
                    isDrawing = false;
                    drawingPoints = [];
                    drawingCurb = null;
                    drawingStartIndex = 0;
                    nearestValidPoint = null;
                    currentDrawingType = null;
                    
                    // Hide drawing buttons
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    document.getElementById('finish-mapping-btn').style.display = 'none';
                    
                    // Update status
                    if (activeTool) {
                        setActiveTool(activeTool); // Reset status message
                    } else {
                        updateStatus('Select a tool to begin');
                    }
                }
                
                function exportData() {
                    // Create export data object
                    const exportData = {
                        timestamp: new Date().toISOString(),
                        version: '1.0',
                        location: map.getCenter(),
                        zoom: map.getZoom(),
                        drainage: {
                            catchBasins: drainagePoints.filter(p => p.type === 'basin').map(p => ({
                                lat: p.latlng.lat,
                                lng: p.latlng.lng
                            })),
                            curbs: curbs.map(curb => ({
                                id: curb.id,
                                streetId: curb.streetId,
                                pitches: curb.pitches.map(pitch => ({
                                    startIndex: pitch.startIndex,
                                    endIndex: pitch.endIndex,
                                    percent: pitch.percent,
                                    angle: pitch.angle
                                }))
                            }))
                        },
                        utilities: {}
                    };
                    
                    // Prepare utilities for export (removing circular references)
                    for (const type in utilities) {
                        exportData.utilities[type] = utilities[type].map(util => ({
                            id: util.id,
                            type: util.type,
                            lineType: util.lineType,
                            size: util.size,
                            depth: util.depth,
                            points: util.points.map(p => ({
                                lat: p.lat,
                                lng: p.lng
                            })),
                            angle: util.angle,
                            connectedTo: util.connectedTo,
                            mediaData: util.mediaData
                        }));
                    }
                    
                    try {
                        // Convert to JSON string
                        const jsonString = JSON.stringify(exportData, null, 2);
                        
                        // Show loading overlay
                        document.querySelector('.loading-overlay').style.display = 'flex';
                        
                        // Create download link
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `cac-pocket-export-${new Date().toISOString().split('T')[0]}.json`;
                        
                        // Trigger download
                        document.body.appendChild(a);
                        a.click();
                        
                        // Cleanup
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        // Hide loading overlay with a short delay
                        setTimeout(() => {
                            document.querySelector('.loading-overlay').style.display = 'none';
                            showNotification('Data exported successfully');
                        }, 500);
                    } catch (err) {
                        console.error('Error exporting data:', err);
                        document.querySelector('.loading-overlay').style.display = 'none';
                        showNotification('Error exporting data. Please try again.');
                    }
                }
                
                function importData() {
                    // Create a file input
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'application/json';
                    
                    // Listen for file selection
                    fileInput.addEventListener('change', function() {
                        if (fileInput.files.length > 0) {
                            const file = fileInput.files[0];
                            const reader = new FileReader();
                            
                            // Show loading overlay
                            document.querySelector('.loading-overlay').style.display = 'flex';
                            
                            reader.onload = function(e) {
                                try {
                                    // Parse JSON
                                    const importData = JSON.parse(e.target.result);
                                    
                                    // Validate data structure
                                    if (!importData.drainage || !importData.utilities || !importData.version) {
                                        throw new Error('Invalid import file format');
                                    }
                                    
                                    // Clear existing data
                                    clearDrainage();
                                    clearUtilities();
                                    
                                    // Center map on saved location
                                    if (importData.location) {
                                        map.setView([importData.location.lat, importData.location.lng], 
                                                    importData.zoom || 19);
                                    }
                                    
                                    // Load road data and wait for it to finish
                                    loadRoadData();
                                    
                                    // Use a timeout to wait for road data to load
                                    // This is a compromise since there's no easy way to know when the async road data finishes loading
                                    let dataImportDelay = 2000;
                                    
                                    setTimeout(() => {
                                        // Check if we have enough roads
                                        if (streets.length === 0) {
                                            showNotification('Warning: No streets loaded. Some data may not import correctly.');
                                            dataImportDelay += 1000; // Give it a bit more time
                                        }
                                        
                                        // Continue with import
                                        setTimeout(() => {
                                            try {
                                                // Import catch basins
                                                if (importData.drainage.catchBasins) {
                                                    importData.drainage.catchBasins.forEach(basin => {
                                                        if (basin.lat && basin.lng) {
                                                            addCatchBasin(L.latLng(basin.lat, basin.lng));
                                                        }
                                                    });
                                                }
                                                
                                                // Import curb pitches
                                                if (importData.drainage.curbs && importData.drainage.curbs.length > 0) {
                                                    // We need roads to be loaded to match curbs
                                                    importData.drainage.curbs.forEach(importCurb => {
                                                        // Find matching curb
                                                        const curb = curbs.find(c => c.id === importCurb.id);
                                                        
                                                        if (curb) {
                                                            // Import pitches
                                                            importCurb.pitches.forEach(pitch => {
                                                                if (pitch.startIndex >= 0 && 
                                                                    pitch.endIndex < curb.latlngs.length && 
                                                                    pitch.startIndex <= pitch.endIndex) {
                                                                    
                                                                    // Create pitch points
                                                                    const points = curb.latlngs.slice(
                                                                        pitch.startIndex, pitch.endIndex + 1);
                                                                    
                                                                    // Create pitch data
                                                                    const pitchData = {
                                                                        curbId: curb.id,
                                                                        startIndex: pitch.startIndex,
                                                                        endIndex: pitch.endIndex,
                                                                        points: points,
                                                                        angle: pitch.angle || 0,
                                                                        percent: pitch.percent || 2.0
                                                                    };
                                                                    
                                                                    // Finalize pitch
                                                                    finalizeCurbPitch(pitchData);
                                                                }
                                                            });
                                                        }
                                                    });
                                                }
                                                
                                                // Import utilities
                                                let utilityCount = 0;
                                                for (const type in importData.utilities) {
                                                    if (importData.utilities[type] && importData.utilities[type].length > 0) {
                                                        importData.utilities[type].forEach(utility => {
                                                            if (utility.points && utility.points.length >= 2) {
                                                                // Convert points to LatLng objects
                                                                const points = utility.points.map(p => L.latLng(p.lat, p.lng));
                                                                
                                                                // Create utility line
                                                                createUtilityLine(
                                                                    points, 
                                                                    utility.type || type, 
                                                                    utility.lineType || 'service',
                                                                    utility.connectedTo
                                                                );
                                                                utilityCount++;
                                                            }
                                                        });
                                                    }
                                                }
                                                
                                                // Hide loading overlay
                                                document.querySelector('.loading-overlay').style.display = 'none';
                                                
                                                // Generate success message
                                                let successMsg = 'Data imported successfully:';
                                                const basinCount = drainagePoints.filter(p => p.type === 'basin').length;
                                                const pitchCount = curbs.reduce((count, curb) => count + curb.pitches.length, 0);
                                                
                                                if (basinCount > 0) successMsg += ` ${basinCount} basins,`;
                                                if (pitchCount > 0) successMsg += ` ${pitchCount} pitches,`;
                                                if (utilityCount > 0) successMsg += ` ${utilityCount} utilities,`;
                                                
                                                // Remove trailing comma
                                                successMsg = successMsg.replace(/,$/, '');
                                                
                                                showNotification(successMsg);
                                                updateStatus('Data imported. Select a tool to continue.');
                                                
                                            } catch (innerError) {
                                                console.error('Error during final import steps:', innerError);
                                                document.querySelector('.loading-overlay').style.display = 'none';
                                                showNotification('Error importing some data: ' + innerError.message);
                                            }
                                        }, 500); // Short delay for UI updates
                                        
                                    }, dataImportDelay);
                                    
                                } catch (error) {
                                    console.error('Import error:', error);
                                    document.querySelector('.loading-overlay').style.display = 'none';
                                    showNotification('Error importing data: ' + error.message);
                                }
                            };
                            
                            reader.onerror = function() {
                                document.querySelector('.loading-overlay').style.display = 'none';
                                showNotification('Error reading file. Please try again.');
                            };
                            
                            reader.readAsText(file);
                        }
                    });
                    
                    // Trigger file selection
                    fileInput.click();
                }
                
                function cleanupResources() {
                    // Cleanup watch position if active
                    if (window.locationWatchId) {
                        navigator.geolocation.clearWatch(window.locationWatchId);
                        window.locationWatchId = null;
                    }
                    
                    // Remove all event listeners to avoid memory leaks
                    // This would be done more thoroughly in a real application
                }
                
                function initUIHandlers() {
                    // Mode toggle
                    document.getElementById('drainage-mode').addEventListener('click', function() {
                        setActiveMode('drainage');
                    });
                    
                    document.getElementById('utility-mode').addEventListener('click', function() {
                        setActiveMode('utility');
                    });
                    
                    // Action bar buttons
                    document.getElementById('locate-btn').addEventListener('click', function() {
                        getUserLocation();
                    });
                    
                    document.getElementById('undo-btn').addEventListener('click', function() {
                        undoLastAction();
                    });
                    
                    document.getElementById('layers-btn').addEventListener('click', function() {
                        // Hide menu panel if open
                        document.getElementById('menu-panel').style.display = 'none';
                        
                        // Toggle layers panel
                        const panel = document.getElementById('layers-panel');
                        panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    document.getElementById('menu-btn').addEventListener('click', function() {
                        // Hide layers panel if open
                        document.getElementById('layers-panel').style.display = 'none';
                        
                        // Toggle menu panel
                        const panel = document.getElementById('menu-panel');
                        panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
                    });
                    
                    // Drainage toolbar
                    document.getElementById('add-basin-btn').addEventListener('click', function() {
                        setActiveTool('add-basin-btn');
                    });
                    
                    document.getElementById('add-pitch-btn').addEventListener('click', function() {
                        setActiveTool('add-pitch-btn');
                    });
                    
                    document.getElementById('edit-pitch-btn').addEventListener('click', function() {
                        setActiveTool('edit-pitch-btn');
                    });
                    
                    // Add new handler for analyze button
                    document.getElementById('analyze-drainage-btn').addEventListener('click', function() {
                        analyzeDrainage();
                    });
                    
                    document.getElementById('clear-drainage-btn').addEventListener('click', function() {
                        clearDrainage();
                    });
                    
                    // Utility toolbar
                    document.getElementById('utility-found-btn').addEventListener('click', function() {
                        setActiveTool('utility-found-btn');
                    });
                    
                    document.getElementById('mapping-btn').addEventListener('click', function() {
                        setActiveTool('mapping-btn');
                    });
                    
                    document.getElementById('water-btn').addEventListener('click', function() {
                        setActiveTool('water-btn');
                        selectedUtilityType = 'water';
                        updateStatus('Select a location to add water utility');
                    });
                    
                    document.getElementById('gas-btn').addEventListener('click', function() {
                        setActiveTool('gas-btn');
                        selectedUtilityType = 'gas';
                        updateStatus('Select a location to add gas utility');
                    });
                    
                    document.getElementById('electric-btn').addEventListener('click', function() {
                        setActiveTool('electric-btn');
                        selectedUtilityType = 'electric';
                        updateStatus('Select a location to add electric utility');
                    });
                    
                    document.getElementById('sewer-btn').addEventListener('click', function() {
                        setActiveTool('sewer-btn');
                        selectedUtilityType = 'sewer';
                        updateStatus('Select a location to add sewer utility');
                    });
                    
                    document.getElementById('telecom-btn').addEventListener('click', function() {
                        setActiveTool('telecom-btn');
                        selectedUtilityType = 'telecom';
                        updateStatus('Select a location to add telecom utility');
                    });
                    
                    document.getElementById('clear-utilities-btn').addEventListener('click', function() {
                        clearUtilities();
                    });
                    
                    // Side controls
                    document.getElementById('zoom-in-btn').addEventListener('click', function() {
                        map.zoomIn(1);
                    });
                    
                    document.getElementById('zoom-out-btn').addEventListener('click', function() {
                        map.zoomOut(1);
                    });
                    
                    document.getElementById('cancel-drawing-btn').addEventListener('click', function() {
                        cancelDrawing();
                    });
                    
                    // Layer toggles - Drainage
                    document.getElementById('basins-toggle').addEventListener('change', function() {
                        toggleLayer('basins', this.checked);
                    });
                    
                    document.getElementById('pitches-toggle').addEventListener('change', function() {
                        toggleLayer('pitches', this.checked);
                    });
                    
                    document.getElementById('available-curbs-toggle').addEventListener('change', function() {
                        toggleLayer('available-curbs', this.checked);
                    });
                    
                    document.getElementById('heatmap-toggle').addEventListener('change', function() {
                        toggleLayer('heatmap', this.checked);
                    });
                    
                    // Layer toggles - Utilities
                    document.getElementById('water-toggle').addEventListener('change', function() {
                        toggleLayer('water', this.checked);
                    });
                    
                    document.getElementById('gas-toggle').addEventListener('change', function() {
                        toggleLayer('gas', this.checked);
                    });
                    
                    document.getElementById('electric-toggle').addEventListener('change', function() {
                        toggleLayer('electric', this.checked);
                    });
                    
                    document.getElementById('sewer-toggle').addEventListener('change', function() {
                        toggleLayer('sewer', this.checked);
                    });
                    
                    document.getElementById('telecom-toggle').addEventListener('change', function() {
                        toggleLayer('telecom', this.checked);
                    });
                    
                    document.getElementById('mains-toggle').addEventListener('change', function() {
                        toggleLayer('mains', this.checked);
                    });
                    
                    document.getElementById('services-toggle').addEventListener('change', function() {
                        toggleLayer('services', this.checked);
                    });
                    
                    // Panel close buttons
                    document.querySelectorAll('.panel-close').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const panel = btn.closest('.panel');
                            panel.style.display = 'none';
                            });
                        });
                        
                    // Menu panel buttons
                    document.getElementById('search-location-btn').addEventListener('click', function() {
                        document.getElementById('menu-panel').style.display = 'none';
                        showModal('location-modal');
                    });
                    
                    document.getElementById('help-btn').addEventListener('click', function() {
                        showNotification('Help functionality coming soon!');
                    });
                    
                    document.getElementById('export-btn').addEventListener('click', function() {
                        exportData();
                    });
                    
                    document.getElementById('import-btn').addEventListener('click', function() {
                        importData();
                    });
                    
                    // Location modal handlers
                    document.getElementById('use-current-location-btn').addEventListener('click', function() {
                        hideModal('location-modal');
                        getUserLocation();
                    });
                    
                    document.getElementById('search-address-btn').addEventListener('click', function() {
                        searchLocation();
                    });
                    
                    // Borough selection
                    document.querySelectorAll('#location-modal .connection-option').forEach(opt => {
                        opt.addEventListener('click', function() {
                            // Toggle selected class
                            if (this.classList.contains('selected')) {
                                this.classList.remove('selected');
                                selectedBorough = null;
                    } else {
                                // Clear other selections
                                document.querySelectorAll('#location-modal .connection-option').forEach(o => {
                                    o.classList.remove('selected');
                                });
                                
                                // Set this selection
                                this.classList.add('selected');
                                selectedBorough = this.getAttribute('data-borough');
                            }
                        });
                    });
                    
                    // Context menu handlers
                    document.getElementById('edit-item').addEventListener('click', function() {
                        // Show edit options for the selected element
                        if (selectedElement) {
                            // Different edit actions based on element type
                            if (selectedElement.type === 'pitch') {
                                // TODO: Show pitch edit modal
                                showNotification('Pitch editing coming soon');
                            } else if (selectedElement.type === 'utility') {
                                showUtilityInfo(selectedElement.element);
                            }
                        }
                        
                        hideContextMenu();
                    });
                    
                    document.getElementById('reverse-direction').addEventListener('click', function() {
                        reversePitchDirection();
                    });
                    
                    document.getElementById('delete-item').addEventListener('click', function() {
                        deleteElement();
                    });
                    
                    // Modal close buttons
                    document.querySelectorAll('.modal-close').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const modal = btn.closest('.modal');
                            modal.style.display = 'none';
                        });
                    });
                    
                    // Utility info card close
                    document.querySelector('.utility-info-close').addEventListener('click', function() {
                        hideUtilityInfo();
                    });
                    
                    // Add pitch modal handlers
                    document.getElementById('rotate-left-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle - 15) % 360;
                        if (directionAngle < 0) directionAngle += 360;
                        document.getElementById('pitch-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('rotate-right-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle + 15) % 360;
                        document.getElementById('pitch-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('increase-pitch').addEventListener('click', function() {
                        pitchPercent = Math.min(10, pitchPercent + 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('decrease-pitch').addEventListener('click', function() {
                        pitchPercent = Math.max(0.1, pitchPercent - 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('cancel-pitch-btn').addEventListener('click', function() {
                        hideModal('add-pitch-modal');
                        selectedElement = null;
                    });
                    
                    document.getElementById('confirm-pitch-btn').addEventListener('click', function() {
                        hideModal('add-pitch-modal');
                        
                        if (selectedElement && selectedElement.type === 'new-pitch') {
                            // Get values from the inputs
                            const pitchSlider = document.getElementById('pitch-slider');
                            const pitchValue = parseFloat(pitchSlider.value);
                            
                            // Update pitch data with the final values
                            selectedElement.pitchData.angle = directionAngle;
                            selectedElement.pitchData.percent = pitchValue;
                            
                            // Finalize the pitch with the modified data
                            finalizeCurbPitch(selectedElement.pitchData);
                        }
                        
                        selectedElement = null;
                    });
                    
                    // Gap pitch modal handlers
                    document.querySelectorAll('#gap-pitch-modal .connection-option').forEach(opt => {
                        opt.addEventListener('click', function() {
                            const option = this.getAttribute('data-option');
                            
                            // Toggle selected class
                            document.querySelectorAll('#gap-pitch-modal .connection-option').forEach(o => {
                                o.classList.remove('selected');
                            });
                            this.classList.add('selected');
                            
                            // Show/hide pitch options
                            if (option === 'add-pitch') {
                                document.getElementById('add-pitch-option').style.display = 'block';
                            } else {
                                document.getElementById('add-pitch-option').style.display = 'none';
                            }
                        });
                    });
                    
                    document.getElementById('gap-rotate-left-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle - 15) % 360;
                        if (directionAngle < 0) directionAngle += 360;
                        document.getElementById('gap-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('gap-direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('gap-rotate-right-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle + 15) % 360;
                        document.getElementById('gap-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('gap-direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('gap-increase-pitch').addEventListener('click', function() {
                        pitchPercent = Math.min(10, pitchPercent + 0.1);
                        document.getElementById('gap-pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('gap-decrease-pitch').addEventListener('click', function() {
                        pitchPercent = Math.max(0.1, pitchPercent - 0.1);
                        document.getElementById('gap-pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('cancel-gap-btn').addEventListener('click', function() {
                        hideModal('gap-pitch-modal');
                        selectedElement = null;
                    });
                    
                    document.getElementById('confirm-gap-btn').addEventListener('click', function() {
                        hideModal('gap-pitch-modal');
                        
                        if (selectedElement && selectedElement.type === 'gap') {
                            const option = document.querySelector('#gap-pitch-modal .connection-option.selected');
                            
                            if (option) {
                                const optionType = option.getAttribute('data-option');
                                
                                if (optionType === 'add-pitch') {
                                    // Create new pitch
                                    const layer = selectedElement.layer;
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    
                                    // Create pitch data
                                    const pitchData = {
                                        curbId: curb.id,
                                        startIndex: startIndex,
                                        endIndex: endIndex,
                                        points: layer.getLatLngs(),
                                        angle: directionAngle,
                                        percent: pitchPercent
                                    };
                                    
                                    // Finalize the pitch
                                    finalizeCurbPitch(pitchData);
                                } 
                                else if (optionType === 'transition') {
                                    // Create transition pitch between existing pitches
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    const prevPitch = selectedElement.prevPitch;
                                    const nextPitch = selectedElement.nextPitch;
                                    
                                    createTransitionPitch(prevPitch, nextPitch, startIndex, endIndex, curb);
                                }
                                else if (optionType === 'highpoint') {
                                    // Create highpoint with dual transitions
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    const prevPitch = selectedElement.prevPitch;
                                    const nextPitch = selectedElement.nextPitch;
                                    
                                    // Calculate the highpoint index (midpoint by default)
                                    const highpointIndex = Math.floor((startIndex + endIndex) / 2);
                                    
                                    // Create transitions from highpoint to both sides
                                    if (prevPitch) {
                                        createTransitionPitch(null, prevPitch, startIndex, highpointIndex, curb, true);
                                    }
                                    
                                    if (nextPitch) {
                                        createTransitionPitch(null, nextPitch, highpointIndex, endIndex, curb, true);
                                    }
                                }
                            }
                        }
                        
                        selectedElement = null;
                    });
                    
                    // Utility Found modal handlers
                    document.getElementById('utility-rotate-left-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle - 15) % 360;
                        if (directionAngle < 0) directionAngle += 360;
                        document.getElementById('utility-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('utility-direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('utility-rotate-right-btn').addEventListener('click', function() {
                        directionAngle = (directionAngle + 15) % 360;
                        document.getElementById('utility-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
                        document.getElementById('utility-direction-angle').textContent = `${directionAngle}°`;
                    });
                    
                    document.getElementById('cancel-utility-btn').addEventListener('click', function() {
                        hideModal('utility-found-modal');
                        tempUtilityLocation = null;
                    });
                    
                    document.getElementById('confirm-utility-btn').addEventListener('click', function() {
                        hideModal('utility-found-modal');
                        finalizeUtilityFound();
                    });
                    
                    // Utility Connection modal handlers
                    document.querySelectorAll('#utility-connection-modal .connection-option').forEach(opt => {
                        opt.addEventListener('click', function() {
                            const option = this.getAttribute('data-option');
                            
                            // Toggle selected class
                            document.querySelectorAll('#utility-connection-modal .connection-option').forEach(o => {
                                o.classList.remove('selected');
                            });
                            this.classList.add('selected');
                            });
                        });
                        
                    document.getElementById('cancel-connection-btn').addEventListener('click', function() {
                        hideModal('utility-connection-modal');
                        if (selectedElement && selectedElement.type === 'connecting-utility') {
                            createUtilityLine(selectedElement.points, selectedElement.utilityType, selectedElement.lineType);
                        }
                        selectedElement = null;
                    });
                    
                    document.getElementById('confirm-connection-btn').addEventListener('click', function() {
                        hideModal('utility-connection-modal');
                        
                        const option = document.querySelector('#utility-connection-modal .connection-option.selected');
                        
                        if (option) {
                            const connectionType = option.getAttribute('data-option');
                            connectUtilities(connectionType);
                        } else {
                            // Default to separate if nothing selected
                            connectUtilities('separate');
                        }
                    });
                    
                    // Handle document clicks to close context menu
                    document.addEventListener('click', function(e) {
                        // Close context menu if clicking outside
                        const contextMenu = document.getElementById('context-menu');
                        if (e.target.closest('#context-menu') === null && 
                            contextMenu.style.display === 'block') {
                            hideContextMenu();
                        }
                        
                        // Close utility info if clicking outside
                        const infoCard = document.getElementById('utility-info-card');
                        if (e.target.closest('#utility-info-card') === null && 
                            infoCard.style.display === 'block') {
                            hideUtilityInfo();
                        }
                        
                        // Close panels if clicking outside (except their toggle buttons)
                        const layersPanel = document.getElementById('layers-panel');
                        if (e.target.closest('#layers-panel') === null && 
                            e.target.closest('#layers-btn') === null && 
                            layersPanel.style.display === 'block') {
                            layersPanel.style.display = 'none';
                        }
                        
                        const menuPanel = document.getElementById('menu-panel');
                        if (e.target.closest('#menu-panel') === null && 
                            e.target.closest('#menu-btn') === null && 
                            menuPanel.style.display === 'block') {
                            menuPanel.style.display = 'none';
                        }
                    });
                    
                    // Escape key to close modals/cancel drawing
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            // Cancel drawing if active
                            if (isDrawing) {
                                cancelDrawing();
                            }
                            
                            // Close context menu if open
                            hideContextMenu();
                            
                            // Close utility info if open
                            hideUtilityInfo();
                            
                            // Close all modals
                            document.querySelectorAll('.modal').forEach(modal => {
                                modal.style.display = 'none';
                            });
                            
                            // Close all panels
                            document.querySelectorAll('.panel').forEach(panel => {
                                panel.style.display = 'none';
                            });
                        }
                    });
                    
                    // Initialize radio buttons
                    document.getElementById('service-type').checked = true;
                    selectedLineType = 'service';
                    
                    // Add change event for line type radios
                    document.querySelectorAll('input[name="line-type"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            selectedLineType = this.value;
                            });
                        });
                        
                    // Add window resize handler to update UI
                    window.addEventListener('resize', function() {
                        // Reposition any open cards or panels
                        if (document.getElementById('utility-info-card').style.display === 'block' && 
                            selectedElement && selectedElement.type === 'utility-info') {
                            const marker = selectedElement.utility.marker;
                            if (marker) {
                                const markerPoint = map.latLngToContainerPoint(marker.getLatLng());
                                const infoCard = document.getElementById('utility-info-card');
                                infoCard.style.left = `${markerPoint.x + 20}px`;
                                infoCard.style.top = `${markerPoint.y - 100}px`;
                            }
                        }
                    });
                    
                    // Add beforeunload handler to warn about unsaved changes
                    window.addEventListener('beforeunload', function(e) {
                        // Check if there are any unsaved changes
                        if (undoStack.length > 0) {
                            // Set a warning message
                            const message = 'You have unsaved changes. Are you sure you want to leave?';
                            e.returnValue = message;
                            return message;
                        }
                    });
                    
                    // Add highpoint option to gap modal HTML right after the existing gap-pitch-modal content
                    const gapModal = document.getElementById('gap-pitch-modal');
                    const gapModalContainer = gapModal.querySelector('.modal-container');
                    const gapModalBody = gapModalContainer.querySelector('.modal-body');
                    
                    // Add the highpoint option to the connection-options div
                    const connectionOptions = gapModalBody.querySelector('.connection-options');
                    if (connectionOptions) {
                        // Add the highpoint option if it doesn't exist
                        if (!connectionOptions.querySelector('[data-option="highpoint"]')) {
                            const highpointOption = document.createElement('div');
                            highpointOption.className = 'connection-option';
                            highpointOption.setAttribute('data-option', 'highpoint');
                            highpointOption.innerHTML = `
                                <div class="connection-icon">
                                    <i class="fas fa-mountain"></i>
                                </div>
                                <div class="connection-label">Highpoint</div>
                            `;
                            connectionOptions.appendChild(highpointOption);
                        }
                    }
                    
                    // Add highpoint option implementation in gap modal handlers
                    document.getElementById('confirm-gap-btn').addEventListener('click', function() {
                        hideModal('gap-pitch-modal');
                        
                        if (selectedElement && selectedElement.type === 'gap') {
                            const option = document.querySelector('#gap-pitch-modal .connection-option.selected');
                            
                            if (option) {
                                const optionType = option.getAttribute('data-option');
                                
                                if (optionType === 'add-pitch') {
                                    // Create new pitch
                                    const layer = selectedElement.layer;
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    
                                    // Create pitch data
                                    const pitchData = {
                                        curbId: curb.id,
                                        startIndex: startIndex,
                                        endIndex: endIndex,
                                        points: layer.getLatLngs(),
                                        angle: directionAngle,
                                        percent: pitchPercent
                                    };
                                    
                                    // Finalize the pitch
                                    finalizeCurbPitch(pitchData);
                                } 
                                else if (optionType === 'transition') {
                                    // Create transition pitch between existing pitches
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    const prevPitch = selectedElement.prevPitch;
                                    const nextPitch = selectedElement.nextPitch;
                                    
                                    createTransitionPitch(prevPitch, nextPitch, startIndex, endIndex, curb);
                                }
                                else if (optionType === 'highpoint') {
                                    // Create highpoint with dual transitions
                                    const curb = selectedElement.curb;
                                    const startIndex = selectedElement.startIndex;
                                    const endIndex = selectedElement.endIndex;
                                    const prevPitch = selectedElement.prevPitch;
                                    const nextPitch = selectedElement.nextPitch;
                                    
                                    // Calculate the highpoint index (midpoint by default)
                                    const highpointIndex = Math.floor((startIndex + endIndex) / 2);
                                    
                                    // Create transitions from highpoint to both sides
                                    if (prevPitch) {
                                        createTransitionPitch(null, prevPitch, startIndex, highpointIndex, curb, true);
                                    }
                                    
                                    if (nextPitch) {
                                        createTransitionPitch(null, nextPitch, highpointIndex, endIndex, curb, true);
                                    }
                                }
                            }
                        }
                        
                        selectedElement = null;
                    });
                    
                    // Add utility workflow handlers
                    document.querySelectorAll('#utility-workflow-modal .connection-option').forEach(option => {
                        option.addEventListener('click', function() {
                            const action = this.getAttribute('data-option');
                            hideModal('utility-workflow-modal');
                            
                            if (action === 'map-utility') {
                                // Show utility type selection modal
                                showModal('utility-type-modal');
                            } else if (action === 'found-utility') {
                                // Show found utility modal
                                addUtilityFound(tempUtilityLocation);
                            }
                        });
                    });
                    
                    // Add utility type selection handlers
                    document.querySelectorAll('#utility-type-modal .connection-option').forEach(option => {
                        option.addEventListener('click', function() {
                            const lineType = this.getAttribute('data-type');
                            hideModal('utility-type-modal');
                            
                            // Set the line type
                            selectedLineType = lineType;
                            
                            // Start mapping
                            startUtilityMapping();
                            
                            // Add first point at the location user initially clicked
                            if (tempUtilityLocation) {
                                handleUtilityMappingClick(tempUtilityLocation);
                                tempUtilityLocation = null;
                            }
                        });
                    });
                    
                    // Tap main modal handlers
                    document.getElementById('confirm-tap-btn').addEventListener('click', function() {
                        hideModal('tap-main-modal');
                        if (selectedElement && selectedElement.type === 'tap-main') {
                            tapMainUtility(selectedElement.servicePoints, selectedElement.mainUtility, selectedElement.tapPoint);
                        }
                    });
                    
                    document.getElementById('cancel-tap-btn').addEventListener('click', function() {
                        hideModal('tap-main-modal');
                        if (selectedElement && selectedElement.type === 'tap-main') {
                            // Just create the service line without connecting to main
                            createUtilityLine(selectedElement.servicePoints, selectedUtilityType, 'service');
                        }
                    });

                    // Add event listener for the finish mapping button
                    document.getElementById('finish-mapping-btn').addEventListener('click', function() {
                        if (isDrawing) {
                            if (currentDrawingType === 'utility' && drawingPoints.length >= 2) {
                                completeUtilityMapping();
                            }
                            else if (currentDrawingType === 'curb' && drawingPoints.length >= 2) {
                                completeCurbDrawing();
                            }
                            else if (currentDrawingType === 'pitch' && drawingPoints.length >= 1) {
                                // For pitch, we need to find a valid end point on the curb
                                if (drawingCurb) {
                                    // Find a reasonable end point on the curb
                                    const lastPoint = drawingPoints[drawingPoints.length - 1];
                                    const result = nearestPointOnCurb(lastPoint, drawingCurb);
                                    
                                    if (result && result.index > drawingStartIndex) {
                                        completeCurbPitch(result.point, result.index);
                                    } else {
                                        showNotification('Please select a valid end point on the curb');
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Register cleanup function for when the window is closed or unloaded
                window.addEventListener('unload', cleanupResources);
            }
        });

        // Add after createOffsetConnection
        function applySmoothingToLine(points) {
            if (points.length <= 2) return points;
            
            // For service lines, don't smooth if it's short
            if (selectedLineType === 'service' && points.length <= 3) return points;
            
            const smoothedPoints = [];
            
            // Add first point
            smoothedPoints.push(points[0]);
            
            // Apply Bezier smoothing to middle points
            for (let i = 1; i < points.length - 1; i++) {
                const p0 = i > 0 ? points[i-1] : points[i];
                const p1 = points[i];
                const p2 = i < points.length - 1 ? points[i+1] : points[i];
                
                // Calculate control points
                const controlPoint1 = {
                    lat: p0.lat + (p1.lat - p0.lat) * 0.5,
                    lng: p0.lng + (p1.lng - p0.lng) * 0.5
                };
                
                const controlPoint2 = {
                    lat: p1.lat + (p2.lat - p1.lat) * 0.5,
                    lng: p1.lng + (p2.lng - p1.lng) * 0.5
                };
                
                // Generate intermediate points for smoothness
                for (let t = 0; t <= 1; t += 0.2) {
                    // Quadratic Bezier curve formula
                    const lat = (1-t)*(1-t)*p0.lat + 2*(1-t)*t*controlPoint1.lat + t*t*p1.lat;
                    const lng = (1-t)*(1-t)*p0.lng + 2*(1-t)*t*controlPoint1.lng + t*t*p1.lng;
                    
                    smoothedPoints.push(L.latLng(lat, lng));
                }
            }
            
            // Add last point
            smoothedPoints.push(points[points.length - 1]);
            
            return smoothedPoints;
        }

        function findNearbyMains(point, utilityType) {
            const nearbyList = [];
            const maxDistance = 10; // meters
            
            // Check each utility of the same type
            utilities[utilityType].forEach(utility => {
                // Only check mains
                if (utility.lineType !== 'main') return;
                
                const utilityPoints = utility.points;
                if (!utilityPoints || utilityPoints.length < 2) return;
                
                // Check each segment of the main line
                for (let i = 0; i < utilityPoints.length - 1; i++) {
                    const segmentStart = utilityPoints[i];
                    const segmentEnd = utilityPoints[i+1];
                    
                    // Calculate distance to segment
                    const segmentResult = projectOnSegment(point, segmentStart, segmentEnd);
                    
                    if (segmentResult.distance <= maxDistance) {
                        nearbyList.push({
                            utility: utility,
                            connectLatLng: segmentResult.point,
                            distance: segmentResult.distance,
                            segmentIndex: i
                        });
                        
                        break;
                    }
                }
            });
            
            // Sort by distance
            return nearbyList.sort((a, b) => a.distance - b.distance);
        }

        function tapMainUtility(servicePoints, mainUtility, tapPoint) {
            // Add the tap point to the service
            const finalServicePoints = [...servicePoints];
            finalServicePoints[finalServicePoints.length - 1] = tapPoint;
            
            // Create the service line connected to the main
            const serviceData = createUtilityLine(finalServicePoints, selectedUtilityType, 'service', mainUtility.id);
            
            // Update the service line's connection data
            serviceData.tappedMain = mainUtility.id;
            serviceData.tapPoint = tapPoint;
            
            updateStatus(`Service connected to ${selectedUtilityType} main`);
        }

        function createSmoothConnection(points1, points2) {
            if (!points1 || points1.length < 2 || !points2 || points2.length < 2) {
                return points1;
            }
            
            // Create a new array for the combined points
            const combinedPoints = [];
            
            // Add all points from the first segment except the last one
            for (let i = 0; i < points1.length - 1; i++) {
                combinedPoints.push(points1[i]);
            }
            
            // Calculate the joining points
            const p1End = points1[points1.length - 1];
            const p2Start = points2[0];
            
            // Calculate control points for a smooth curve
            const controlPoint1 = {
                lat: p1End.lat + (p2Start.lat - p1End.lat) * 0.33,
                lng: p1End.lng + (p2Start.lng - p1End.lng) * 0.33
            };
            
            const controlPoint2 = {
                lat: p1End.lat + (p2Start.lat - p1End.lat) * 0.66,
                lng: p1End.lng + (p2Start.lng - p1End.lng) * 0.66
            };
            
            // Add curve points
            const numPoints = 5;
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                
                // Cubic Bezier formula
                const lat = Math.pow(1-t, 3) * p1End.lat + 
                            3 * Math.pow(1-t, 2) * t * controlPoint1.lat + 
                            3 * (1-t) * Math.pow(t, 2) * controlPoint2.lat + 
                            Math.pow(t, 3) * p2Start.lat;
                        
                const lng = Math.pow(1-t, 3) * p1End.lng + 
                            3 * Math.pow(1-t, 2) * t * controlPoint1.lng + 
                            3 * (1-t) * Math.pow(t, 2) * controlPoint2.lng + 
                            Math.pow(t, 3) * p2Start.lng;
                        
                combinedPoints.push(L.latLng(lat, lng));
            }
            
            // Add remaining points from the second segment
            for (let i = 1; i < points2.length; i++) {
                combinedPoints.push(points2[i]);
            }
            
            return combinedPoints;
        }

        function updateUtilityConnectionModal() {
            const connectionOptions = document.querySelector('#utility-connection-modal .connection-options');
            if (!connectionOptions) return;
            
            // Clear existing options
            connectionOptions.innerHTML = '';
            
            // Add the connection options
            connectionOptions.innerHTML = `
                <div class="connection-option" data-option="snap">
                    <div class="connection-icon">
                        <i class="fas fa-magnet"></i>
                    </div>
                    <div class="connection-label">Snap</div>
                </div>
                <div class="connection-option" data-option="offset">
                    <div class="connection-icon">
                        <i class="fas fa-grip-lines"></i>
                    </div>
                    <div class="connection-label">Offset</div>
                </div>
                <div class="connection-option" data-option="separate">
                    <div class="connection-icon">
                        <i class="fas fa-unlink"></i>
                    </div>
                    <div class="connection-label">No Connection</div>
                </div>
            `;
            
            // Add event listeners to the new options
            document.querySelectorAll('#utility-connection-modal .connection-option').forEach(opt => {
                opt.addEventListener('click', function() {
                    // Toggle selected class
                    document.querySelectorAll('#utility-connection-modal .connection-option').forEach(o => {
                        o.classList.remove('selected');
                    });
                    this.classList.add('selected');
                });
            });
        }

        // Add startCurbDrawing and completeCurbDrawing functions after the drainage heatmap functions
        function startCurbDrawing() {
            // Start drawing a new curb
            isDrawing = true;
            drawingPoints = [];
            currentDrawingType = 'curb';
            
            // Show the drawing buttons
            document.getElementById('cancel-drawing-btn').style.display = 'block';
            document.getElementById('finish-mapping-btn').style.display = 'block';
            
            updateStatus('Click on the map to draw a curb. Double-click to finish.');
        }

        function completeCurbDrawing() {
            // Remove temp line
            if (tempLine) {
                map.removeLayer(tempLine);
                tempLine = null;
            }
            
            // Hide the drawing buttons
            document.getElementById('cancel-drawing-btn').style.display = 'none';
            document.getElementById('finish-mapping-btn').style.display = 'none';
            
            // Need at least 2 points for a valid line
            if (drawingPoints.length < 2) {
                isDrawing = false;
                drawingPoints = [];
                return;
            }
            
            // Create actual curb object
            const curbId = 'curb-' + Date.now();
            
            // Store curb data
            curbs.push({
                id: curbId,
                latlngs: [...drawingPoints],
                streetId: null, // Manual curb, not associated with a street
                pitches: [] // Will store pitch info
            });
            
            // Visualize the curb
            L.polyline(drawingPoints, {
                color: '#757575',
                weight: 6,
                opacity: 1,
                className: 'curb-line'
            }).addTo(curbsLayer);
            
            // Add to undo stack
            addToUndoStack({
                type: 'curb',
                curbId: curbId,
                points: [...drawingPoints]
            });
            
            // Reset drawing
            isDrawing = false;
            drawingPoints = [];
            
            // Update available curbs for pitches
            showAvailableCurbs();
            
            updateStatus('Curb added successfully');
        }

        // Add the analyze drainage functionality
        function analyzeDrainage() {
            // Get all drainage elements
            const basins = drainagePoints.filter(p => p.type === 'basin');
            const allPitches = [];
            
            curbs.forEach(curb => {
                curb.pitches.forEach(pitch => {
                    allPitches.push({
                        points: pitch.line.getLatLngs(),
                        angle: pitch.angle,
                        percent: pitch.percent,
                        curb: curb.id
                    });
                });
            });
            
            // Show analysis loading
            showNotification('Analyzing drainage patterns...');
            document.querySelector('.loading-overlay').style.display = 'flex';
            
            // Use setTimeout to avoid blocking the UI
            setTimeout(() => {
                // Update drainage heatmap
                updateDrainageHeatmap();
                
                // Calculate some analysis metrics
                const basinCount = basins.length;
                const pitchCount = allPitches.length;
                
                // Calculate average pitch percentage
                let totalPercent = 0;
                allPitches.forEach(pitch => {
                    totalPercent += pitch.percent;
                });
                const avgPitch = pitchCount > 0 ? (totalPercent / pitchCount).toFixed(1) : 0;
                
                // Calculate total drainage length
                let totalPitchLength = 0;
                allPitches.forEach(pitch => {
                    const points = pitch.points;
                    if (points && points.length > 1) {
                        for (let i = 0; i < points.length - 1; i++) {
                            totalPitchLength += map.distance(points[i], points[i + 1]);
                        }
                    }
                });
                const pitchLengthMeters = Math.round(totalPitchLength);
                
                // Check for potential drainage issues
                let issues = [];
                
                // Check for areas with no catch basins
                if (basinCount === 0) {
                    issues.push('No catch basins found');
                }
                
                // Check for disconnected pitches (not flowing to a catch basin)
                let disconnectedPitches = 0;
                allPitches.forEach(pitch => {
                    let hasBasinNearby = false;
                    const points = pitch.points;
                    if (points && points.length > 0) {
                        const pitchEnd = points[points.length - 1];
                        basins.forEach(basin => {
                            // Check if this pitch is flowing toward a basin
                            if (flowsTowardsBasin(pitchEnd, pitch.angle, [basin.latlng])) {
                                // And is reasonably close (within 30 meters)
                                if (map.distance(pitchEnd, basin.latlng) < 30) {
                                    hasBasinNearby = true;
                                }
                            }
                        });
                    }
                    
                    if (!hasBasinNearby) {
                        disconnectedPitches++;
                    }
                });
                
                if (disconnectedPitches > 0 && basinCount > 0) {
                    issues.push(`${disconnectedPitches} pitch(es) not directed towards catch basins`);
                }
                
                // Hide loading overlay
                document.querySelector('.loading-overlay').style.display = 'none';
                
                // Show analysis results
                let resultMessage = `Analysis complete: ${basinCount} basins, ${pitchCount} pitches`;
                if (pitchCount > 0) {
                    resultMessage += `, avg ${avgPitch}%, ${pitchLengthMeters}m total length`;
                }
                
                showNotification(resultMessage);
                
                // If issues found, show another notification after a delay
                if (issues.length > 0) {
                    setTimeout(() => {
                        showNotification('Potential issues: ' + issues.join(', '));
                    }, 3000);
                }
                
                // Highlight areas that need attention by flashing the heatmap
                if (drainageHeatmapLayer) {
                    const originalOpacity = drainageHeatmapLayer.options.opacity || 0.7;
                    
                    // Flash the heatmap to draw attention to problem areas
                    drainageHeatmapLayer.setOpacity(0.9);
                    setTimeout(() => {
                        drainageHeatmapLayer.setOpacity(originalOpacity);
                    }, 500);
                }
                
                updateStatus('Drainage analysis complete');
            }, 500); // Small delay to allow the UI to update
        }

        // Improved pitch arrow visualization
        function addPitchArrow(line, angle) {
            // Get the line's points
            const points = line.getLatLngs();
            if (!points || points.length < 2) return;
            
            // Calculate the midpoint of the line
            const midIdx = Math.floor(points.length / 2);
            const midPoint = points[midIdx];
            
            // Create arrow icon with animation
            const arrowIcon = L.divIcon({
                html: `<i class="fas fa-long-arrow-alt-down curb-pitch-arrow"></i>`,
                className: '',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            
            // Create marker at midpoint
            const marker = L.marker(midPoint, {
                icon: arrowIcon,
                interactive: false,
                zIndexOffset: 1000
            }).addTo(curbPitchesLayer);
            
            // Set arrow direction with animation
            const arrowElement = marker._icon.querySelector('i');
            
            // First set initial position
            arrowElement.style.transform = `rotate(${angle}deg) scale(0)`;
            
            // Then animate in
            setTimeout(() => {
                arrowElement.style.transition = 'transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)';
                arrowElement.style.transform = `rotate(${angle}deg) scale(1.2)`;
                
                // Then scale back to normal size
                setTimeout(() => {
                    arrowElement.style.transform = `rotate(${angle}deg) scale(1)`;
                }, 150);
            }, 10);
            
            // Store reference to marker
            line.arrowMarker = marker;
        }

        // Improved pitch label
        function addPitchLabel(line, percent) {
            // Get the line's points
            const points = line.getLatLngs();
            if (!points || points.length < 2) return;
            
            // Calculate the center point of the line
            const centerIdx = Math.floor(points.length / 2);
            const centerPoint = points[centerIdx];
            
            // Create label icon with animation
            const labelIcon = L.divIcon({
                html: `<div class="curb-pitch-label">${percent.toFixed(1)}%</div>`,
                className: '',
                iconSize: [36, 24],
                iconAnchor: [18, 12]
            });
            
            // Create marker at center, offset slightly from arrow
            const marker = L.marker(centerPoint, {
                icon: labelIcon,
                interactive: false,
                zIndexOffset: 900
            }).addTo(curbPitchesLayer);
            
            // Add animation
            const labelElement = marker._icon.querySelector('.curb-pitch-label');
            
            // First set initial position
            labelElement.style.transform = 'scale(0)';
            labelElement.style.opacity = '0';
            
            // Then animate in
            setTimeout(() => {
                labelElement.style.transition = 'all 0.3s ease-out';
                labelElement.style.transform = 'scale(1)';
                labelElement.style.opacity = '1';
            }, 300); // Delay to appear after the arrow
            
            // Store reference to marker
            line.labelMarker = marker;
        }

        function showPitchEditorModal() {
            // Get the current pitch data
            const pitchData = selectedElement.pitchData;
            const curb = selectedElement.curb;
            
            // Calculate total available range for repositioning
            const curbLength = curb.latlngs.length;
            const pitchLength = pitchData.endIndex - pitchData.startIndex;
            const maxPosition = curbLength - pitchLength;
            
            // Update the modal with a position slider
            const modal = document.getElementById('add-pitch-modal');
            
            // Add position slider HTML if not already present
            if (!document.getElementById('pitch-position-slider')) {
                const positionGroup = document.createElement('div');
                positionGroup.className = 'form-group';
                positionGroup.innerHTML = `
                    <label for="pitch-position-slider">Position Along Curb</label>
                    <div class="pitch-input-container">
                        <input type="range" id="pitch-position-slider" min="0" max="${maxPosition}" 
                               value="${pitchData.startIndex}" class="pitch-slider">
                        <div class="pitch-value-container">
                            <button class="pitch-adjust-btn" id="decrease-position">
                                <i class="fas fa-minus"></i>
                            </button>
                            <div class="pitch-value" id="position-value">Position: ${pitchData.startIndex}</div>
                            <button class="pitch-adjust-btn" id="increase-position">
                                <i class="fas fa-plus"></i>
                            </button>
                        </div>
                    </div>
                `;
                
                // Add the position slider before the modal footer
                const modalBody = modal.querySelector('.modal-body');
                modalBody.appendChild(positionGroup);
                
                // Add event listeners for position adjustment
                document.getElementById('pitch-position-slider').addEventListener('input', updatePitchPosition);
                document.getElementById('decrease-position').addEventListener('click', decreasePitchPosition);
                document.getElementById('increase-position').addEventListener('click', increasePitchPosition);
            } else {
                // Update existing slider
                const slider = document.getElementById('pitch-position-slider');
                slider.max = maxPosition;
                slider.value = pitchData.startIndex;
                document.getElementById('position-value').textContent = `Position: ${pitchData.startIndex}`;
            }
            
            // Add a reverse direction button if not already present
            if (!document.getElementById('reverse-pitch-direction')) {
                const reverseBtn = document.createElement('button');
                reverseBtn.id = 'reverse-pitch-direction';
                reverseBtn.className = 'btn btn-primary';
                reverseBtn.style.marginBottom = '12px';
                reverseBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Reverse Direction';
                
                const modalBody = modal.querySelector('.modal-body');
                modalBody.insertBefore(reverseBtn, modalBody.firstChild);
                
                // Add event listener for reversing direction
                reverseBtn.addEventListener('click', reversePitchDirection);
            }
            
            // Show the enhanced modal
            showModal('add-pitch-modal');
        }

        // Function to update pitch position when slider changes
        function updatePitchPosition(e) {
            const newStart = parseInt(e.target.value);
            const pitchData = selectedElement.pitchData;
            const curb = selectedElement.curb;
            const pitchLength = pitchData.endIndex - pitchData.startIndex;
            
            // Update the display
            document.getElementById('position-value').textContent = `Position: ${newStart}`;
            
            // Update the pitch data
            pitchData.startIndex = newStart;
            pitchData.endIndex = newStart + pitchLength;
            
            // Update points array
            pitchData.points = [];
            for (let i = newStart; i <= newStart + pitchLength; i++) {
                pitchData.points.push(curb.latlngs[i]);
            }
            
            // If flow direction is reversed, reverse the points
            if (!pitchData.flowDirection) {
                pitchData.points.reverse();
            }
        }

        // Helper functions for position adjustment buttons
        function decreasePitchPosition() {
            const slider = document.getElementById('pitch-position-slider');
            const newValue = Math.max(0, parseInt(slider.value) - 1);
            slider.value = newValue;
            
            // Trigger the input event to update everything
            const event = new Event('input');
            slider.dispatchEvent(event);
        }

        function increasePitchPosition() {
            const slider = document.getElementById('pitch-position-slider');
            const newValue = Math.min(parseInt(slider.max), parseInt(slider.value) + 1);
            slider.value = newValue;
            
            // Trigger the input event to update everything
            const event = new Event('input');
            slider.dispatchEvent(event);
        }

        // Function to reverse pitch direction
        function reversePitchDirection() {
            const pitchData = selectedElement.pitchData;
            
            // Flip the flow direction
            pitchData.flowDirection = !pitchData.flowDirection;
            
            // Reverse the points
            pitchData.points.reverse();
            
            // Update the angle
            pitchData.angle = (pitchData.angle + 180) % 360;
            
            // Update the UI
            directionAngle = pitchData.angle;
            document.getElementById('pitch-direction-arrow').style.transform = `rotate(${directionAngle}deg)`;
            document.getElementById('direction-angle').textContent = `${directionAngle}°`;
        }
    </script>
</body>
</html>
