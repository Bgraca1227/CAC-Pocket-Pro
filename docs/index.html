<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC Pocket</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    
    <style>
        :root {
            --primary-color: #0075ff;
            --secondary-color: #ffcc00;
            --accent-color: #ff3e30;
            --success-color: #00c853;
            --dark-color: #263238;
            --light-color: #f5f5f5;
            --text-color: #212121;
            --gray-color: #757575;
            --panel-bg: rgba(255, 255, 255, 0.97);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --rounded: 12px;

            /* Utility-specific colors */
            --water-color: #2196f3;
            --gas-color: #ff9800;
            --electric-color: #ffeb3b;
            --sewer-color: #795548;
            --telecom-color: #9c27b0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html, body {
            height: 100%;
            color: var(--text-color);
            background-color: var(--light-color);
            overflow-x: hidden;
            overflow-y: auto;
        }

        .app-container {
            position: relative;
            height: 100dvh;
            width: 100vw;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* Mode Tabs */
        .mode-tabs {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1500;
            display: flex;
            justify-content: center;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
        }

        .mode-tab {
            padding: 12px 24px;
            border: none;
            background: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--dark-color);
            touch-action: manipulation;
        }

        .mode-tab.active {
            color: var(--primary-color);
            border-bottom: 3px solid var(--primary-color);
        }

        /* Always visible controls */
        .always-visible-controls {
            position: fixed;
            bottom: 100px;
            right: 16px;
            z-index: 1500;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .control-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            color: var(--dark-color);
            touch-action: manipulation;
        }

        .control-button:active {
            transform: scale(0.95);
        }

        /* Top Action Bar */
        .action-bar {
            position: absolute;
            top: 55px; /* Adjusted to account for mode tabs */
            left: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
            pointer-events: none;
        }

        .action-group {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .action-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
            touch-action: manipulation;
        }

        .action-button i {
            font-size: 20px;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Drawing Toolbars */
        .drawing-toolbar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 8px;
            background-color: var(--panel-bg);
            border-radius: 24px;
            padding: 6px;
            box-shadow: var(--shadow);
            max-width: 95%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .utilities-toolbar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
            gap: 8px;
            background-color: var(--panel-bg);
            border-radius: 24px;
            padding: 6px;
            box-shadow: var(--shadow);
            max-width: 95%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
        }

        .tool-button {
            min-width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
            flex-shrink: 0;
            touch-action: manipulation;
        }

        .tool-button i {
            font-size: 20px;
        }

        .tool-button:active {
            transform: scale(0.95);
        }

        /* Tool button active states */
        .tool-button.street-tool.active {
            background-color: var(--primary-color);
            color: white;
            border-color: white;
        }

        .tool-button.curb-tool.active {
            background-color: var(--secondary-color);
            color: var(--dark-color);
            border-color: white;
        }

        .tool-button.utilities-tool.active {
            background-color: #673ab7;
            color: white;
            border-color: white;
        }

        .tool-button.catch-basin-tool.active {
            background-color: #2196f3;
            color: white;
            border-color: white;
        }

        .tool-button.draw-guide-tool.active {
            background-color: #9c27b0;
            color: white;
            border-color: white;
        }

        /* Utility-specific tool buttons */
        .tool-button.water-main-tool.active {
            background-color: var(--water-color);
            color: white;
            border-color: white;
        }

        .tool-button.gas-main-tool.active {
            background-color: var(--gas-color);
            color: var(--dark-color);
            border-color: white;
        }

        .tool-button.electric-main-tool.active {
            background-color: var(--electric-color);
            color: var(--dark-color);
            border-color: white;
        }

        .tool-button.sewer-main-tool.active {
            background-color: var(--sewer-color);
            color: white;
            border-color: white;
        }

        .tool-button.telecom-main-tool.active {
            background-color: var(--telecom-color);
            color: white;
            border-color: white;
        }

        /* Complete Guide Button */
        .finish-guide-btn {
            position: absolute;
            right: 16px;
            bottom: 90px;
            z-index: 1000;
            display: none;
            background-color: var(--success-color);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            border: none;
            box-shadow: var(--shadow);
            font-weight: 600;
            cursor: pointer;
            touch-action: manipulation;
        }

        .finish-guide-btn.visible {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Menu Panel */
        .menu-panel {
            position: absolute;
            top: 115px; /* Adjusted for mode tabs */
            right: 10px;
            z-index: 1000;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 12px;
            box-shadow: var(--shadow);
            min-width: 200px;
            transform: translateX(220px);
            transition: transform 0.3s ease;
            max-height: calc(100dvh - 130px);
            overflow-y: auto;
        }

        .menu-panel.visible {
            transform: translateX(0);
        }

        .menu-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .menu-panel-title {
            font-weight: 600;
            font-size: 16px;
        }

        .menu-panel-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--dark-color);
            font-size: 18px;
        }

        .menu-section {
            margin-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 16px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        .menu-section-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .layer-toggle:last-child {
            margin-bottom: 0;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 42px;
            height: 22px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .toggle-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .street-indicator {
            background-color: var(--primary-color);
        }

        .curb-indicator {
            background-color: var(--secondary-color);
        }

        .basin-indicator {
            color: #2196f3;
            font-size: 14px;
        }

        .guide-indicator {
            color: #9c27b0;
            font-size: 14px;
        }

        /* Utility layer toggles */
        .utility-water-indicator {
            color: var(--water-color);
            font-size: 14px;
        }

        .utility-gas-indicator {
            color: var(--gas-color);
            font-size: 14px;
        }

        .utility-electric-indicator {
            color: var(--electric-color);
            font-size: 14px;
        }

        .utility-sewer-indicator {
            color: var(--sewer-color);
            font-size: 14px;
        }

        .utility-telecom-indicator {
            color: var(--telecom-color);
            font-size: 14px;
        }

        /* Basemap options */
        .basemap-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .basemap-option {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid transparent;
            border-radius: var(--rounded);
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .basemap-option.active {
            border-color: var(--primary-color);
            background-color: rgba(0, 117, 255, 0.1);
        }

        .basemap-thumbnail {
            width: 100%;
            height: 80px;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .osm-thumbnail {
            background-image: url('https://a.tile.openstreetmap.org/15/9644/12321.png');
            background-size: cover;
        }

        .satellite-thumbnail {
            background-image: url('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/15/12321/9644');
            background-size: cover;
        }

        .basemap-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* Export buttons */
        .menu-button {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: var(--rounded);
            background-color: var(--light-color);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            text-align: left;
        }

        .menu-button:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .menu-button i {
            width: 20px;
            text-align: center;
            color: var(--primary-color);
        }

        /* Pitch Input Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 20px;
            width: 90%;
            max-width: 320px;
            box-shadow: var(--shadow);
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .modal-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pitch-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .pitch-adjust-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--light-color);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
        }

        .pitch-value {
            font-size: 24px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .modal-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
            margin-top: 16px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: var(--rounded);
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .cancel-btn {
            background-color: var(--light-color);
            color: var(--dark-color);
        }

        .confirm-btn {
            background-color: var(--primary-color);
            color: white;
        }

        .modal-btn:active {
            transform: scale(0.98);
        }

        /* Help Modal */
        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .help-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 480px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
        }

        .help-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .help-title {
            font-size: 20px;
            font-weight: 600;
        }

        .help-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            touch-action: manipulation;
        }

        .help-content {
            padding: 20px;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        .help-text {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 12px;
        }

        .feature-list {
            list-style: none;
        }

        .feature-item {
            display: flex;
            margin-bottom: 16px;
            align-items: flex-start;
        }

        .feature-icon {
            flex-shrink: 0;
            width: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: var(--primary-color);
        }

        /* Location Select Modal */
        .location-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .location-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 480px;
            box-shadow: var(--shadow);
        }

        .location-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .location-title {
            font-size: 20px;
            font-weight: 600;
        }

        .location-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            touch-action: manipulation;
        }

        .location-content {
            padding: 20px;
        }

        .location-input {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .location-input label {
            font-weight: 600;
            font-size: 14px;
        }

        .location-input input {
            padding: 12px;
            border-radius: var(--rounded);
            border: 1px solid #ddd;
            font-size: 16px;
        }

        .borough-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .borough-btn {
            padding: 10px 15px;
            border-radius: 20px;
            border: 2px solid var(--primary-color);
            background: white;
            color: var(--primary-color);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .borough-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .location-actions {
            display: flex;
            justify-content: space-between;
            gap: 12px;
        }

        .location-btn {
            flex: 1;
            padding: 12px;
            border-radius: var(--rounded);
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .location-current-btn {
            background-color: var(--secondary-color);
            color: var(--dark-color);
        }

        .location-search-btn {
            background-color: var(--primary-color);
            color: white;
        }

        /* Utility details modal */
        .utility-details-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .utility-details-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 350px;
            box-shadow: var(--shadow);
        }

        .utility-details-header {
            font-size: 18px;
            font-weight: 600;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .utility-details-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .utility-details-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .utility-details-field label {
            font-weight: 500;
            font-size: 14px;
        }

        .utility-details-field input,
        .utility-details-field select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 14px;
        }

        /* Connection options modal */
        .connection-options-modal {
            position: absolute;
            z-index: 2000;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            width: 300px;
            overflow: hidden;
        }

        .connection-header {
            padding: 12px 16px;
            font-weight: 600;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }

        .connection-options {
            display: flex;
            flex-direction: column;
            padding: 12px;
        }

        .connection-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid rgba(0,0,0,0.1);
            border-radius: var(--rounded);
            background: none;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .connection-btn:hover {
            background-color: rgba(0,0,0,0.05);
        }

        .connection-btn i {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .option-description {
            font-size: 12px;
            color: var(--gray-color);
            margin-top: 4px;
        }

        /* Utility info card */
        .utility-info-card {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 1500;
            width: 280px;
            max-width: 90vw;
            display: none;
        }

        .utility-info-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 8px;
        }

        .utility-info-title {
            font-weight: 600;
            font-size: 16px;
        }

        .utility-info-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            touch-action: manipulation;
        }

        .utility-info-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .utility-info-row {
            display: flex;
            justify-content: space-between;
        }

        .utility-info-label {
            font-weight: 500;
            color: var(--gray-color);
        }

        .utility-info-value {
            font-weight: 500;
        }

        .utility-info-image {
            width: 100%;
            margin-top: 10px;
            border-radius: 8px;
            overflow: hidden;
        }

        .utility-info-image img {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--dark-color);
            color: white;
            border-radius: var(--rounded);
            padding: 12px 20px;
            z-index: 2000;
            box-shadow: var(--shadow);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        /* Map Styling */
        .pitch-arrow {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .pitch-arrow svg {
            width: 100%;
            height: 100%;
        }

        .street-arrow path {
            fill: var(--primary-color);
        }

        .curb-arrow path {
            fill: var(--secondary-color);
        }

        .street-line {
            stroke: var(--primary-color);
            stroke-width: 5;
        }

        .curb-line {
            stroke: var(--secondary-color);
            stroke-width: 5;
        }

        /* Flow animation */
        .flow-animation {
            animation: flow 2s linear infinite;
        }

        @keyframes flow {
            0% { stroke-dashoffset: 24; }
            100% { stroke-dashoffset: 0; }
        }

        .catch-basin-icon {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            background-color: #2196f3;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
        }

        /* Utility marker styles */
        .utility-marker {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            background-color: #673ab7;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
        }

        .utility-direction-line {
            stroke-width: 4;
            stroke-dasharray: 5,3;
        }

        /* Utility main lines */
        .utility-water-line {
            stroke: var(--water-color);
            stroke-width: 5;
        }

        .utility-gas-line {
            stroke: var(--gas-color);
            stroke-width: 5;
        }

        .utility-electric-line {
            stroke: var(--electric-color);
            stroke-width: 5;
        }

        .utility-sewer-line {
            stroke: var(--sewer-color);
            stroke-width: 5;
        }

        .utility-telecom-line {
            stroke: var(--telecom-color);
            stroke-width: 5;
        }

        .utility-connection {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .trapped-water-area {
            fill: rgba(255, 0, 0, 0.3);
            stroke: #ff0000;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 0.9; }
            100% { opacity: 0.6; }
        }

        /* Custom styles for roads */
        .street-guide {
            stroke: rgba(0, 117, 255, 0.3);
            stroke-width: 18;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: auto;
        }

        .curb-guide {
            stroke: rgba(255, 204, 0, 0.3);
            stroke-width: 6;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: auto;
        }

        .custom-guide {
            stroke: rgba(156, 39, 176, 0.3);
            stroke-width: 18;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: auto;
        }

        /* Valid area highlight */
        .highlight-area {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 900;
            opacity: 0.5;
            transform: translate(-50%, -50%);
            display: none;
        }

        .highlight-street {
            background-color: var(--primary-color);
        }

        .highlight-curb {
            background-color: var(--secondary-color);
        }

        .highlight-utility {
            background-color: var(--water-color);
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            padding: 8px 0;
            z-index: 1500;
            min-width: 160px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item i {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 48px;
            margin-bottom: 20px;
        }

        .splash-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--light-color);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Status bar */
        .status-bar {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 999;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-bar i {
            color: var(--primary-color);
            flex-shrink: 0;
        }

        /* iOS safe area support */
        @supports(padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: env(safe-area-inset-bottom);
            }
            .drawing-toolbar, .utilities-toolbar {
                bottom: calc(16px + env(safe-area-inset-bottom));
            }
        }

        /* Style adjustments for smaller screens */
        @media (max-width: 480px) {
            .drawing-toolbar, .utilities-toolbar {
                padding: 4px;
                gap: 6px;
            }

            .tool-button {
                width: 44px;
                height: 44px;
            }

            .tool-button i {
                font-size: 18px;
            }

            .action-button {
                width: 40px;
                height: 40px;
            }

            .action-button i {
                font-size: 16px;
            }

            .mode-tab {
                padding: 10px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-water"></i>
        </div>
        <div class="splash-title">CAC Pocket</div>
        <div class="splash-subtitle">NYC Drainage & Utility Planning Tool</div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Map Element -->
        <div id="map"></div>

        <!-- Highlight for valid drawing area -->
        <div id="highlight-area" class="highlight-area"></div>
        
        <!-- Mode Tabs -->
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="drainage">Drainage Planning</button>
            <button class="mode-tab" data-mode="utilities">Utility Planning</button>
        </div>
        
        <!-- Always visible controls -->
        <div class="always-visible-controls">
            <button class="control-button" id="zoom-in-btn" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="control-button" id="zoom-out-btn" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="control-button" id="cancel-drawing-btn" title="Cancel Drawing" style="display: none;">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <!-- Top Action Bar -->
        <div class="action-bar">
            <div class="action-group">
                <button class="action-button" id="locate-btn" title="My Location">
                    <i class="fas fa-crosshairs"></i>
                </button>
                <button class="action-button" id="undo-btn" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            </div>
            <div class="action-group">
                <button class="action-button" id="menu-btn" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
                <button class="action-button" id="help-btn" title="Help">
                    <i class="fas fa-question"></i>
                </button>
            </div>
        </div>

        <!-- Menu Panel -->
        <div class="menu-panel" id="menu-panel">
            <div class="menu-panel-header">
                <div class="menu-panel-title">Menu</div>
                <button class="menu-panel-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Drainage Layers Section -->
            <div class="menu-section drainage-layers">
                <div class="menu-section-title">Drainage Layers</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <div class="toggle-indicator street-indicator"></div>
                        Street Pitches
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="street-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <div class="toggle-indicator curb-indicator"></div>
                        Curb Pitches
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="curb-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-drain toggle-indicator basin-indicator"></i>
                        Catch Basins
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="basin-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-exclamation-triangle toggle-indicator" style="color: var(--accent-color);"></i>
                        Trapped Water
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="trapped-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Utility Layers Section -->
            <div class="menu-section utilities-layers">
                <div class="menu-section-title">Utility Layers</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-tint toggle-indicator utility-water-indicator"></i>
                        Water Lines
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="water-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-fire toggle-indicator utility-gas-indicator"></i>
                        Gas Lines
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="gas-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-bolt toggle-indicator utility-electric-indicator"></i>
                        Electric Lines
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="electric-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-toilet toggle-indicator utility-sewer-indicator"></i>
                        Sewer Lines
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sewer-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-phone toggle-indicator utility-telecom-indicator"></i>
                        Telecom Lines
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="telecom-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Guides Layer Section -->
            <div class="menu-section">
                <div class="menu-section-title">Guide Layers</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-route toggle-indicator guide-indicator"></i>
                        Street Guides
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="guide-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Basemap Options Section -->
            <div class="menu-section">
                <div class="menu-section-title">Basemap</div>
                <div class="basemap-options">
                    <div class="basemap-option active" data-basemap="osm">
                        <div class="basemap-thumbnail osm-thumbnail"></div>
                        <div class="basemap-label">Street Map</div>
                    </div>
                    <div class="basemap-option" data-basemap="satellite">
                        <div class="basemap-thumbnail satellite-thumbnail"></div>
                        <div class="basemap-label">Satellite</div>
                    </div>
                </div>
            </div>
            
            <!-- Options Section -->
            <div class="menu-section">
                <div class="menu-section-title">Options</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-magnet toggle-indicator" style="color: var(--primary-color);"></i>
                        Snap to Roads
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="snap-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-search toggle-indicator" style="color: var(--primary-color);"></i>
                        Show Valid Areas
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="highlight-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <!-- Export Section -->
            <div class="menu-section">
                <div class="menu-section-title">Export & Share</div>
                <button id="export-image-btn" class="menu-button">
                    <i class="fas fa-image"></i> Export as Image
                </button>
                <button id="export-pdf-btn" class="menu-button">
                    <i class="fas fa-file-pdf"></i> Export as PDF
                </button>
                <button id="save-project-btn" class="menu-button">
                    <i class="fas fa-save"></i> Save Project
                </button>
            </div>
        </div>

        <!-- Drainage Drawing Toolbar -->
        <div class="drawing-toolbar" id="drainage-toolbar">
            <button class="tool-button street-tool" id="street-tool" title="Draw Street Pitch">
                <i class="fas fa-road"></i>
            </button>
            <button class="tool-button curb-tool" id="curb-tool" title="Draw Curb Pitch">
                <i class="fas fa-grip-lines"></i>
            </button>
            <button class="tool-button catch-basin-tool" id="catch-basin-tool" title="Add Catch Basin">
                <i class="fas fa-water"></i>
            </button>
            <button class="tool-button draw-guide-tool" id="draw-guide-tool" title="Draw Custom Guide">
                <i class="fas fa-pen"></i>
            </button>
            <button class="tool-button" id="analyze-tool" title="Analyze Drainage">
                <i class="fas fa-chart-network"></i>
            </button>
            <button class="tool-button" id="clear-drainage-tool" title="Clear Drainage">
                <i class="fas fa-trash"></i>
            </button>
            <button class="tool-button" id="toolbar-undo-btn" title="Undo">
                <i class="fas fa-undo"></i>
            </button>
        </div>
        
        <!-- Utilities Drawing Toolbar -->
        <div class="utilities-toolbar" id="utilities-toolbar">
            <button class="tool-button water-main-tool" id="water-main-tool" title="Draw Water Main">
                <i class="fas fa-tint"></i>
            </button>
            <button class="tool-button gas-main-tool" id="gas-main-tool" title="Draw Gas Main">
                <i class="fas fa-fire"></i>
            </button>
            <button class="tool-button electric-main-tool" id="electric-main-tool" title="Draw Electric Main">
                <i class="fas fa-bolt"></i>
            </button>
            <button class="tool-button sewer-main-tool" id="sewer-main-tool" title="Draw Sewer Main">
                <i class="fas fa-toilet"></i>
            </button>
            <button class="tool-button telecom-main-tool" id="telecom-main-tool" title="Draw Telecom Main">
                <i class="fas fa-phone"></i>
            </button>
            <button class="tool-button" id="service-tool" title="Draw Service Connection">
                <i class="fas fa-plug"></i>
            </button>
            <button class="tool-button" id="clear-utility-tool" title="Clear Utilities">
                <i class="fas fa-trash"></i>
            </button>
            <button class="tool-button" id="utility-undo-btn" title="Undo">
                <i class="fas fa-undo"></i>
            </button>
        </div>

        <!-- Finish Guide Button -->
        <button class="finish-guide-btn" id="finish-guide-btn">
            <i class="fas fa-check"></i> Finish Guide
        </button>

        <!-- Status Bar -->
        <div class="status-bar">
            <i class="fas fa-info-circle"></i>
            <span id="status-text">Select a tool to begin</span>
        </div>

        <!-- Pitch Input Modal -->
        <div class="modal-overlay" id="pitch-modal">
            <div class="modal-container">
                <div class="modal-header" id="pitch-modal-title">Set Pitch Percentage</div>
                <div class="modal-content">
                    <div class="pitch-input-container">
                        <button class="pitch-adjust-btn" id="decrease-pitch">
                            <i class="fas fa-minus"></i>
                        </button>
                        <div class="pitch-value" id="pitch-value">2.0%</div>
                        <button class="pitch-adjust-btn" id="increase-pitch">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn cancel-btn" id="cancel-pitch">Cancel</button>
                        <button class="modal-btn confirm-btn" id="confirm-pitch">Confirm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Utility Direction Modal -->
        <div class="modal-overlay" id="utility-direction-modal">
            <div class="modal-container">
                <div class="modal-header">Set Utility Direction</div>
                <div class="modal-content">
                    <div class="pitch-input-container">
                        <button class="pitch-adjust-btn" id="rotate-left">
                            <i class="fas fa-undo"></i>
                        </button>
                        <div class="pitch-value">
                            <i class="fas fa-arrow-up" style="font-size: 24px;" id="direction-indicator"></i>
                        </div>
                        <button class="pitch-adjust-btn" id="rotate-right">
                            <i class="fas fa-redo"></i>
                        </button>
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn cancel-btn" id="cancel-direction">Cancel</button>
                        <button class="modal-btn confirm-btn" id="confirm-direction">Confirm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Utility Details Modal -->
        <div class="modal-overlay" id="utility-details-modal">
            <div class="modal-container" style="max-width: 350px;">
                <div class="modal-header">Utility Details</div>
                <div class="modal-content">
                    <div style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label for="utility-type" style="display: block; margin-bottom: 5px; font-weight: 500;">Type:</label>
                            <select id="utility-type" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ddd;">
                                <option value="water">Water</option>
                                <option value="gas">Gas</option>
                                <option value="electric">Electric</option>
                                <option value="sewer">Sewer</option>
                                <option value="telecom">Telecom</option>
                            </select>
                        </div>
                        <div>
                            <label for="utility-size" style="display: block; margin-bottom: 5px; font-weight: 500;">Size (inches):</label>
                            <input type="number" id="utility-size" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ddd;" value="4">
                        </div>
                        <div>
                            <label for="utility-depth" style="display: block; margin-bottom: 5px; font-weight: 500;">Depth (feet):</label>
                            <input type="number" id="utility-depth" style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #ddd;" value="3">
                        </div>
                        <div>
                            <label for="utility-image" style="display: block; margin-bottom: 5px; font-weight: 500;">Image (optional):</label>
                            <input type="file" id="utility-image" accept="image/*" style="width: 100%;">
                        </div>
                    </div>
                    <div class="modal-actions" style="margin-top: 20px;">
                        <button class="modal-btn cancel-btn" id="cancel-details">Cancel</button>
                        <button class="modal-btn confirm-btn" id="confirm-details">Confirm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Utility Service Connection Modal -->
        <div class="modal-overlay" id="service-connection-modal">
            <div class="modal-container">
                <div class="modal-header">Service Connection</div>
                <div class="modal-content">
                    <p style="margin-bottom: 15px; font-size: 14px;">Select the utility line to connect to:</p>
                    <div id="utility-options" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 15px;">
                        <!-- Utility options will be populated here -->
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn cancel-btn" id="cancel-service">Cancel</button>
                        <button class="modal-btn confirm-btn" id="confirm-service">Next</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Connection Options Modal (Dynamic, created when needed) -->
        
        <!-- Utility Info Card -->
        <div class="utility-info-card" id="utility-info-card">
            <div class="utility-info-header">
                <div class="utility-info-title">Utility Information</div>
                <button class="utility-info-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="utility-info-content">
                <div class="utility-info-row">
                    <div class="utility-info-label">Type:</div>
                    <div class="utility-info-value" id="info-type">Water</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Size:</div>
                    <div class="utility-info-value" id="info-size">4 inches</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Depth:</div>
                    <div class="utility-info-value" id="info-depth">3 feet</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Direction:</div>
                    <div class="utility-info-value" id="info-direction">North</div>
                </div>
                <div class="utility-info-image" id="info-image-container">
                    <!-- Image will be inserted here if available -->
                </div>
            </div>
        </div>

        <!-- Location Modal -->
        <div class="location-modal" id="location-modal">
            <div class="location-container">
                <div class="location-header">
                    <div class="location-title">NYC Location</div>
                    <button class="location-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="location-content">
                    <div class="location-input">
                        <label for="address-input">Enter Address or Intersection</label>
                        <input type="text" id="address-input" placeholder="Example: 123 Main St, Brooklyn, NY">
                    </div>
                    
                    <div class="borough-options">
                        <button class="borough-btn" data-borough="Brooklyn">Brooklyn</button>
                        <button class="borough-btn" data-borough="Queens">Queens</button>
                        <button class="borough-btn" data-borough="Manhattan">Manhattan</button>
                        <button class="borough-btn" data-borough="Bronx">Bronx</button>
                    </div>
                    
                    <div class="location-actions">
                        <button class="location-btn location-current-btn" id="location-current-btn">
                            <i class="fas fa-crosshairs"></i> Use My Location
                        </button>
                        <button class="location-btn location-search-btn" id="location-search-btn">
                            <i class="fas fa-search"></i> Search
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="edit-item">
                <i class="fas fa-edit"></i>
                <span>Edit</span>
            </div>
            <div class="context-menu-item" id="reverse-direction">
                <i class="fas fa-exchange-alt"></i>
                <span>Reverse Direction</span>
            </div>
            <div class="context-menu-item" id="delete-item">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>

        <!-- Help Modal -->
        <div class="help-modal" id="help-modal">
            <div class="help-container">
                <div class="help-header">
                    <div class="help-title">CAC Pocket Help</div>
                    <button class="help-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="help-content">
                    <div class="help-section">
                        <div class="help-section-title">Getting Started</div>
                        <p class="help-text">CAC Pocket uses real street data to help you plan water drainage and utility layouts on construction sites in New York City boroughs.</p>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Mode Selection</div>
                        <p class="help-text">The app has two working modes:</p>
                        <ul class="feature-list">
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-water"></i>
                                </div>
                                <div>
                                    <strong>Drainage Planning Mode</strong> - Design pitch lines, place catch basins, and ensure proper water flow.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-tools"></i>
                                </div>
                                <div>
                                    <strong>Utility Planning Mode</strong> - Draw utility mains for water, gas, electric, sewer, and telecom services.
                                </div>
                            </li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Drainage Tools</div>
                        <ul class="feature-list">
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-road"></i>
                                </div>
                                <div>
                                    <strong>Street Pitch</strong> - Draw blue slope lines on streets to indicate drainage direction.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-grip-lines"></i>
                                </div>
                                <div>
                                    <strong>Curb Pitch</strong> - Draw yellow slope lines on curbs to indicate drainage direction.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-water"></i>
                                </div>
                                <div>
                                    <strong>Catch Basins</strong> - Mark drainage points where water will collect.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-pen"></i>
                                </div>
                                <div>
                                    <strong>Custom Guides</strong> - Draw your own street guides if real street data is unavailable.
                                </div>
                            </li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <div class="help-section-title">Utility Tools</div>
                        <ul class="feature-list">
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-tint"></i>
                                </div>
                                <div>
                                    <strong>Water Main</strong> - Draw water utility lines.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-fire"></i>
                                </div>
                                <div>
                                    <strong>Gas Main</strong> - Draw gas utility lines.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-bolt"></i>
                                </div>
                                <div>
                                    <strong>Electric Main</strong> - Draw electric utility lines.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-toilet"></i>
                                </div>
                                <div>
                                    <strong>Sewer Main</strong> - Draw sewer utility lines.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-phone"></i>
                                </div>
                                <div>
                                    <strong>Telecom Main</strong> - Draw telecom utility lines.
                                </div>
                            </li>
                            <li class="feature-item">
                                <div class="feature-icon">
                                    <i class="fas fa-plug"></i>
                                </div>
                                <div>
                                    <strong>Service Connection</strong> - Connect building services to utility mains.
                                </div>
                            </li>
                        </ul>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">Drawing Tips</div>
                        <p class="help-text">• The app will snap to the nearest valid street or curb when drawing<br>
                        • A highlight will show valid drawing areas as you move your finger<br>
                        • After drawing a line, you can set its pitch percentage or utility properties<br>
                        • Long-press or right-click on elements to edit, reverse direction, or delete<br>
                        • Use the mode tabs at the top to switch between drainage and utility planning</p>
                    </div>

                    <div class="help-section">
                        <div class="help-section-title">NYC Borough Support</div>
                        <p class="help-text">This app is optimized for use in Brooklyn, Queens, Manhattan, and the Bronx. Street data is loaded automatically based on your location.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Notification -->
        <div class="notification" id="notification">
            <i class="fas fa-info-circle"></i>
            <span id="notification-text">Notification message</span>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for splash screen
            setTimeout(() => {
                document.querySelector('.splash-screen').style.opacity = 0;
                setTimeout(() => {
                    document.querySelector('.splash-screen').style.display = 'none';
                    initApp();
                }, 500);
            }, 2000);

            function initApp() {
                // Initialize variables
                let map, userMarker, currentPosition;
                let activeDrawingMode = null;
                let pitchPercent = 2.0;
                let currentDrawingType = null;
                let tempLine = null;
                let drawingPoints = [];
                let isDrawing = false;
                let undoStack = [];
                let selectedElement = null;
                let selectedBorough = null;
                let highlightArea = document.getElementById('highlight-area');
                let snapEnabled = true;
                let highlightEnabled = true;
                let nearestValidPoint = null;
                let finishGuideBtn = document.getElementById('finish-guide-btn');
                let utilityAngle = 0;
                let tempUtilityMarker = null;
                let tempUtilityLine = null;
                let selectedUtility = null;
                let utilityInfoCard = document.getElementById('utility-info-card');
                let currentMode = 'drainage';
                let currentUtilityType = null;
                let serviceConnectionStart = null;
                let serviceConnectionEnd = null;
                
                // Feature layers
                let streetPitchesLayer = L.layerGroup();
                let curbPitchesLayer = L.layerGroup();
                let catchBasinsLayer = L.layerGroup();
                let trappedWaterLayer = L.layerGroup();
                let streetGuidesLayer = L.layerGroup();
                let curbGuidesLayer = L.layerGroup();
                let customGuidesLayer = L.layerGroup();
                
                // Utility layers
                let waterLinesLayer = L.layerGroup();
                let gasLinesLayer = L.layerGroup();
                let electricLinesLayer = L.layerGroup();
                let sewerLinesLayer = L.layerGroup();
                let telecomLinesLayer = L.layerGroup();
                let serviceConnectionsLayer = L.layerGroup();
                
                // Road network data
                let streets = [];
                let curbs = [];
                let customGuides = [];
                
                // Utility network data
                let utilityMains = {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                };
                
                // Basemap layers
                let osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22
                });
                
                let satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    maxZoom: 22
                });
                
                let basemaps = {
                    'osm': osmLayer,
                    'satellite': satelliteLayer
                };
                
                // Initialize map
                initMap();
                
                // Initialize UI interactions
                initUIHandlers();
                
                // Show location modal to start
                showLocationModal();
                
                function initMap() {
                    // Create map with default view (will be updated with user location)
                    map = L.map('map', {
                        zoomControl: false,
                        attributionControl: false
                    }).setView([40.7128, -74.0060], 12); // Default to NYC
                    
                    // Add default basemap layer
                    basemaps.osm.addTo(map);
                    
                    // Add feature layers to map
                    streetGuidesLayer.addTo(map);
                    curbGuidesLayer.addTo(map);
                    customGuidesLayer.addTo(map);
                    streetPitchesLayer.addTo(map);
                    curbPitchesLayer.addTo(map);
                    catchBasinsLayer.addTo(map);
                    trappedWaterLayer.addTo(map);
                    
                    // Add utility layers to map
                    waterLinesLayer.addTo(map);
                    gasLinesLayer.addTo(map);
                    electricLinesLayer.addTo(map);
                    sewerLinesLayer.addTo(map);
                    telecomLinesLayer.addTo(map);
                    serviceConnectionsLayer.addTo(map);
                    
                    // Map event listeners
                    map.on('click', handleMapClick);
                    map.on('pointermove', handlePointerMove);
                    map.on('contextmenu', handleContextMenu);
                    
                    // Hide context menu on map move
                    map.on('movestart', hideContextMenu);
                    
                    // Road data load on map movement
                    map.on('moveend', loadRoadData);
                }
                
                function showLocationModal() {
                    document.getElementById('location-modal').style.display = 'flex';
                }
                
                function getUserLocation() {
                    // Update status
                    updateStatus('Finding your location...');
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Check if geolocation is available
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(function(position) {
                            // Store position
                            currentPosition = [position.coords.latitude, position.coords.longitude];
                            
                            // Update map center
                            map.setView(currentPosition, 19);
                            
                            // Create user marker if not exists
                            if (!userMarker) {
                                userMarker = L.circleMarker(currentPosition, {
                                    radius: 8,
                                    fillColor: '#2962ff',
                                    color: '#fff',
                                    weight: 2,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                }).addTo(map);
                            } else {
                                userMarker.setLatLng(currentPosition);
                            }
                            
                            // Load road data for current view
                            loadRoadData();
                            
                            // Update status
                            updateStatus('Select a tool to begin');
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Hide location modal if it's open
                            document.getElementById('location-modal').style.display = 'none';
                            
                            // Watch position for updates
                            navigator.geolocation.watchPosition(function(position) {
                                // Update current position
                                currentPosition = [position.coords.latitude, position.coords.longitude];
                                
                                // Update user marker
                                if (userMarker) {
                                    userMarker.setLatLng(currentPosition);
                                }
                            }, function(error) {
                                console.error('Error watching position:', error);
                            }, {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 5000
                            });
                            
                        }, function(error) {
                            console.error('Error getting location:', error);
                            
                            // Update status
                            updateStatus('Location access denied. Please enable GPS.');
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                        }, {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 5000
                        });
                    } else {
                        // Update status
                        updateStatus('Geolocation not supported in this browser');
                        
                        // Hide loading overlay
                        document.querySelector('.loading-overlay').style.display = 'none';
                    }
                }
                
                function searchLocation() {
                    const address = document.getElementById('address-input').value;
                    
                    if (!address) {
                        showNotification('Please enter an address to search');
                        return;
                    }
                    
                    // Show loading overlay
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    
                    // Build search query with borough if selected
                    let searchQuery = address;
                    if (selectedBorough) {
                        if (!searchQuery.toLowerCase().includes(selectedBorough.toLowerCase())) {
                            searchQuery += `, ${selectedBorough}, NYC`;
                        }
                    } else {
                        searchQuery += ', NYC';
                    }
                    
                    // Use Nominatim for geocoding (OpenStreetMap's geocoding service)
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.length > 0) {
                                const result = data[0];
                                const lat = parseFloat(result.lat);
                                const lon = parseFloat(result.lon);
                                
                                // Update map view
                                map.setView([lat, lon], 19);
                                
                                // Load road data for this area
                                loadRoadData();
                                
                                // Hide location modal
                                document.getElementById('location-modal').style.display = 'none';
                                
                                // Hide loading overlay
                                document.querySelector('.loading-overlay').style.display = 'none';
                                
                                // Show notification
                                showNotification(`Located: ${result.display_name}`);
                            } else {
                                // Hide loading overlay
                                document.querySelector('.loading-overlay').style.display = 'none';
                                
                                // Show error notification
                                showNotification('Address not found. Please try again.');
                            }
                        })
                        .catch(error => {
                            console.error('Error searching location:', error);
                            
                            // Hide loading overlay
                            document.querySelector('.loading-overlay').style.display = 'none';
                            
                            // Show error notification
                            showNotification('Error searching location. Please try again.');
                        });
                }
                
                function loadRoadData() {
                    // Show loading message
                    updateStatus('Loading street data...');
                    
                    // Get current map bounds
                    const bounds = map.getBounds();
                    const south = bounds.getSouth();
                    const west = bounds.getWest();
                    const north = bounds.getNorth();
                    const east = bounds.getEast();
                    
                    // Clear existing guides
                    streetGuidesLayer.clearLayers();
                    curbGuidesLayer.clearLayers();
                    streets = [];
                    curbs = [];
                    
                    // Check if we're zoomed in enough to fetch detailed street data
                    if (map.getZoom() < 16) {
                        updateStatus('Zoom in closer to see street details');
                        return;
                    }
                    
                    // Use Overpass API to get road data
                    // This query gets highways (roads) within the current view
                    const overpassQuery = `
                        [out:json];
                        (
                          way["highway"](${south},${west},${north},${east});
                        );
                        out body geom;
                    `;
                    
                    // Overpass API endpoint
                    const overpassUrl = "https://overpass-api.de/api/interpreter";
                    
                    // Properly encode the request for Overpass API
                    fetch(overpassUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
                        },
                        body: 'data=' + encodeURIComponent(overpassQuery.trim())
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Network error: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data && data.elements) {
                            processRoadData(data.elements);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching road data:', error);
                        updateStatus('Failed to load street data. You can draw custom guides.');
                    });
                }
                
                function processRoadData(elements) {
                    if (!elements || elements.length === 0) {
                        updateStatus('No street data found. You can draw custom guides.');
                        return;
                    }
                    
                    let counter = 0;
                    let validRoads = 0;
                    
                    // Filter out non-walkable highway types
                    const roadTypes = ['motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'residential', 'service', 'unclassified'];
                    
                    elements.forEach(element => {
                        if (element.type === 'way' && element.tags && element.tags.highway && roadTypes.includes(element.tags.highway)) {
                            if (element.geometry && element.geometry.length > 1) {
                                // Convert geometry to LatLng array
                                const latlngs = element.geometry.map(node => [node.lat, node.lon]);
                                
                                // Add to streets array
                                streets.push({
                                    id: element.id,
                                    latlngs: latlngs,
                                    type: element.tags.highway
                                });
                                
                                // Create street guide
                                const streetGuide = L.polyline(latlngs, {
                                    className: 'street-guide',
                                    interactive: true,
                                    bubblingMouseEvents: false
                                }).addTo(streetGuidesLayer);
                                
                                // Generate curb lines on both sides
                                createCurbLines(latlngs, element.id, element.tags.highway);
                                
                                validRoads++;
                            }
                        }
                        
                        counter++;
                        if (counter === elements.length) {
                            if (validRoads > 0) {
                                updateStatus(`Loaded ${validRoads} streets. Select a tool to begin.`);
                            } else {
                                updateStatus('No valid streets found. You can draw custom guides.');
                            }
                        }
                    });
                }
                
                function getRoadWidth(roadType) {
                    // Return appropriate road width in meters based on road type
                    switch (roadType) {
                        case 'motorway': return 7;
                        case 'trunk': return 6; 
                        case 'primary': return 5;
                        case 'secondary': return 4.5;
                        case 'tertiary': return 4;
                        case 'residential': return 3.5;
                        case 'service': return 3;
                        case 'unclassified': return 3.5;
                        default: return 4;
                    }
                }
                
                function createCurbLines(streetPoints, streetId, roadType) {
                    if (streetPoints.length < 2) return;
                    
                    // Calculate road width based on road type
                    const roadWidth = getRoadWidth(roadType);
                    
                    // Calculate curb offsets with improved algorithm
                    const curbOffsets = generateSmoothCurbOffsets(streetPoints, roadWidth);
                    
                    if (curbOffsets && curbOffsets.length > 0) {
                        // Create left and right curb polylines
                        const leftCurbPoints = curbOffsets.map(pair => pair[0]);
                        const rightCurbPoints = curbOffsets.map(pair => pair[1]);
                        
                        // Add curbs to map
                        const leftCurb = L.polyline(leftCurbPoints, {
                            className: 'curb-guide',
                            interactive: true,
                            bubblingMouseEvents: false
                        }).addTo(curbGuidesLayer);
                        
                        const rightCurb = L.polyline(rightCurbPoints, {
                            className: 'curb-guide',
                            interactive: true,
                            bubblingMouseEvents: false
                        }).addTo(curbGuidesLayer);
                        
                        // Store curb data
                        curbs.push({
                            id: `${streetId}-left`,
                            latlngs: leftCurbPoints,
                            streetId: streetId
                        });
                        
                        curbs.push({
                            id: `${streetId}-right`,
                            latlngs: rightCurbPoints,
                            streetId: streetId
                        });
                    }
                }
                
                function generateSmoothCurbOffsets(streetPts, offsetMeters) {
                    // Enhanced algorithm for smoother curb generation
                    let offsets = [];
                    
                    for (let i = 0; i < streetPts.length - 1; i++) {
                        const current = L.latLng(streetPts[i]);
                        const next = L.latLng(streetPts[i + 1]);
                        
                        // Calculate direction vector
                        const dx = next.lng - current.lng;
                        const dy = next.lat - current.lat;
                        
                        // Normalize direction vector
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length === 0) continue;
                        
                        const nx = dx / length;
                        const ny = dy / length;
                        
                        // Calculate perpendicular vector
                        const px = -ny;
                        const py = nx;
                        
                        // Calculate offset distance in degrees (approximate conversion)
                        // 1 meter ≈ 0.00001 degrees at the equator
                        const offsetFactor = offsetMeters * 0.00001;
                        
                        // Apply offset for left and right curbs
                        const leftLat = current.lat + py * offsetFactor;
                        const leftLng = current.lng + px * offsetFactor;
                        const rightLat = current.lat - py * offsetFactor;
                        const rightLng = current.lng - px * offsetFactor;
                        
                        offsets.push([
                            [leftLat, leftLng],
                            [rightLat, rightLng]
                        ]);
                    }
                    
                    // Add final point
                    if (streetPts.length > 1) {
                        const last = streetPts.length - 1;
                        const preLast = streetPts.length - 2;
                        
                        // Use the same offset direction as the previous segment
                        const current = L.latLng(streetPts[preLast]);
                        const next = L.latLng(streetPts[last]);
                        
                        const dx = next.lng - current.lng;
                        const dy = next.lat - current.lat;
                        
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length !== 0) {
                            const nx = dx / length;
                            const ny = dy / length;
                            
                            const px = -ny;
                            const py = nx;
                            
                            const offsetFactor = offsetMeters * 0.00001;
                            
                            const leftLat = next.lat + py * offsetFactor;
                            const leftLng = next.lng + px * offsetFactor;
                            const rightLat = next.lat - py * offsetFactor;
                            const rightLng = next.lng - px * offsetFactor;
                            
                            offsets.push([
                                [leftLat, leftLng],
                                [rightLat, rightLng]
                            ]);
                        }
                    }
                    
                    return offsets;
                }
                
                function drawCustomGuide() {
                    // Start new guide
                    isDrawing = true;
                    drawingPoints = [];
                    currentDrawingType = 'guide';
                    
                    // Create temporary line
                    tempLine = L.polyline([], {
                        color: '#9c27b0',
                        weight: 5,
                        opacity: 0.7,
                        dashArray: '5,5'
                    }).addTo(map);
                    
                    // Show finish button
                    finishGuideBtn.classList.add('visible');
                    
                    // Show cancel drawing button
                    document.getElementById('cancel-drawing-btn').style.display = 'block';
                    
                    updateStatus('Click to add points to your custom guide. Click "Finish Guide" when done.');
                }
                
                function completeCustomGuide() {
                    // Hide finish button
                    finishGuideBtn.classList.remove('visible');
                    
                    // Hide cancel drawing button
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    
                    // Need at least 2 points for a valid guide
                    if (drawingPoints.length < 2) {
                        if (tempLine) {
                            map.removeLayer(tempLine);
                            tempLine = null;
                        }
                        isDrawing = false;
                        drawingPoints = [];
                        return;
                    }
                    
                    // Create guide polyline
                    const guideId = 'custom-' + Date.now();
                    const guide = L.polyline(drawingPoints, {
                        className: 'custom-guide',
                        interactive: true,
                        bubblingMouseEvents: false
                    }).addTo(customGuidesLayer);
                    
                    // Setup guide interaction
                    guide.on('contextmenu', function(e) {
                        handleContextMenu(e, guide, 'guide');
                    });
                    
                    // Store guide data
                    customGuides.push({
                        id: guideId,
                        latlngs: drawingPoints.slice()
                    });
                    
                    // Generate curb lines for the custom guide
                    createCurbLines(drawingPoints, guideId, 'residential');
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'guide',
                        element: guide,
                        guideId: guideId
                    });
                    
                    // Remove temp line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Reset drawing state
                    isDrawing = false;
                    drawingPoints = [];
                    
                    // Update status
                    updateStatus('Custom guide added. You can now draw on it.');
                    showNotification('Custom guide created');
                }
                
                function handlePointerMove(e) {
                    // Update temporary line during drawing
                    if (isDrawing && tempLine) {
                        let movePoint = e.latlng;
                        
                        // Use snapping if enabled and we're drawing a line
                        if (snapEnabled) {
                            if (currentDrawingType === 'street-tool' || currentDrawingType === 'curb-tool') {
                                const isStreetTool = currentDrawingType === 'street-tool';
                                const validResult = findNearestValidPoint(e.latlng, isStreetTool ? 'street' : 'curb');
                                
                                if (validResult.valid) {
                                    movePoint = validResult.point;
                                }
                            } else if (currentDrawingType.includes('main-tool') || currentDrawingType === 'utility-main') {
                                // Snap utility mains to streets
                                const validResult = findNearestValidPoint(e.latlng, 'street');
                                
                                if (validResult.valid) {
                                    movePoint = validResult.point;
                                }
                            }
                        }
                        
                        const points = [...drawingPoints, movePoint];
                        tempLine.setLatLngs(points);
                    }
                    
                    // Update highlight area
                    updateHighlightArea(e);
                }
                
                function updateHighlightArea(e) {
                    if (!highlightEnabled || !activeDrawingMode) {
                        highlightArea.style.display = 'none';
                        return;
                    }
                    
                    let validationType;
                    
                    if (activeDrawingMode === 'street-tool') {
                        validationType = 'street';
                    } else if (activeDrawingMode === 'curb-tool') {
                        validationType = 'curb';
                    } else if (activeDrawingMode.includes('main-tool')) {
                        validationType = 'street';
                    } else {
                        highlightArea.style.display = 'none';
                        return;
                    }
                    
                    // Find nearest valid point
                    const validResult = findNearestValidPoint(e.latlng, validationType);
                    
                    if (validResult.valid) {
                        // Place the highlight at the valid point
                        const pixelPoint = map.latLngToContainerPoint(validResult.point);
                        highlightArea.style.left = `${pixelPoint.x}px`;
                        highlightArea.style.top = `${pixelPoint.y}px`;
                        highlightArea.style.display = 'block';
                        
                        // Set the appropriate class
                        highlightArea.className = 'highlight-area';
                        if (validationType === 'street') {
                            highlightArea.classList.add('highlight-street');
                        } else if (validationType === 'curb') {
                            highlightArea.classList.add('highlight-curb');
                        } else if (validationType === 'utility') {
                            highlightArea.classList.add('highlight-utility');
                        }
                        
                        // Store nearest valid point for snapping
                        nearestValidPoint = validResult.point;
                    } else {
                        highlightArea.style.display = 'none';
                        nearestValidPoint = null;
                    }
                }
                
                function findNearestValidPoint(point, type) {
                    // Convert to Leaflet latLng if needed
                    if (!point.lat) {
                        point = L.latLng(point);
                    }
                    
                    // Convert point to screen coordinates
                    const screenPoint = map.latLngToContainerPoint(point);
                    
                    // Maximum distance in pixels to consider valid
                    const maxDistancePx = 30;
                    
                    // Get layers to check based on type
                    const layersToCheck = getLayersForType(type);
                    
                    // Find nearest valid point
                    let minDistancePx = Infinity;
                    let nearestPoint = null;
                    let validationType = null;
                    
                    // Check each layer for valid points
                    layersToCheck.forEach(layerInfo => {
                        const layer = layerInfo.layer;
                        const dataArray = layerInfo.data;
                        
                        dataArray.forEach(item => {
                            const latlngs = item.latlngs;
                            
                            // Skip if no valid latLngs
                            if (!latlngs || latlngs.length < 2) return;
                            
                            // Check each segment for the nearest point
                            for (let i = 0; i < latlngs.length - 1; i++) {
                                const segmentResult = projectPointOnLineSegment(point, latlngs[i], latlngs[i+1]);
                                
                                if (segmentResult.distancePx < minDistancePx && segmentResult.distancePx <= maxDistancePx) {
                                    minDistancePx = segmentResult.distancePx;
                                    nearestPoint = segmentResult.nearestPoint;
                                    validationType = type;
                                }
                            }
                        });
                    });
                    
                    return {
                        point: nearestPoint || point,
                        valid: !!nearestPoint,
                        type: validationType,
                        distance: minDistancePx
                    };
                }
                
                function getLayersForType(type) {
                    // Return appropriate layers based on validation type
                    switch (type) {
                        case 'street':
                            return [
                                { layer: streetGuidesLayer, data: streets },
                                { layer: customGuidesLayer, data: customGuides }
                            ];
                        case 'curb':
                            return [{ layer: curbGuidesLayer, data: curbs }];
                        case 'utility-water':
                            return [{ layer: waterLinesLayer, data: utilityMains.water }];
                        case 'utility-gas':
                            return [{ layer: gasLinesLayer, data: utilityMains.gas }];
                        case 'utility-electric':
                            return [{ layer: electricLinesLayer, data: utilityMains.electric }];
                        case 'utility-sewer':
                            return [{ layer: sewerLinesLayer, data: utilityMains.sewer }];
                        case 'utility-telecom':
                            return [{ layer: telecomLinesLayer, data: utilityMains.telecom }];
                        case 'utility-all':
                            return [
                                { layer: waterLinesLayer, data: utilityMains.water },
                                { layer: gasLinesLayer, data: utilityMains.gas },
                                { layer: electricLinesLayer, data: utilityMains.electric },
                                { layer: sewerLinesLayer, data: utilityMains.sewer },
                                { layer: telecomLinesLayer, data: utilityMains.telecom }
                            ];
                        default:
                            return [];
                    }
                }
                
                function projectPointOnLineSegment(point, start, end) {
                    // Convert to layer points (screen pixels)
                    const lp = map.latLngToLayerPoint(point);
                    const ls = map.latLngToLayerPoint(L.latLng(start));
                    const le = map.latLngToLayerPoint(L.latLng(end));
                    
                    // Calculate vector from start to end
                    const v = L.point(le.x - ls.x, le.y - ls.y);
                    
                    // Calculate vector from start to point
                    const w = L.point(lp.x - ls.x, lp.y - ls.y);
                    
                    // Calculate projection scalar
                    const c1 = w.x * v.x + w.y * v.y;
                    const c2 = v.x * v.x + v.y * v.y;
                    
                    // Calculate normalized projection (clamped to [0,1])
                    const t = c2 === 0 ? 0 : Math.max(0, Math.min(1, c1 / c2));
                    
                    // Calculate projected point
                    const px = ls.x + t * v.x;
                    const py = ls.y + t * v.y;
                    const projPoint = L.point(px, py);
                    
                    // Calculate distance in pixels
                    const distancePx = Math.sqrt(Math.pow(lp.x - px, 2) + Math.pow(lp.y - py, 2));
                    
                    // Return result
                    return {
                        nearestPoint: map.layerPointToLatLng(projPoint),
                        distancePx: distancePx
                    };
                }
                
                function handleMapClick(e) {
                    // Hide context menu if open
                    hideContextMenu();
                    
                    // Hide utility info card if open
                    hideUtilityInfo();
                    
                    // Handle click based on active drawing mode
                    if (activeDrawingMode === 'street-tool' || activeDrawingMode === 'curb-tool') {
                        handleDrainageLineDrawing(e);
                    } else if (activeDrawingMode === 'catch-basin-tool') {
                        addCatchBasin(e.latlng);
                    } else if (activeDrawingMode === 'draw-guide-tool') {
                        handleGuideDrawing(e);
                    } else if (activeDrawingMode.includes('main-tool')) {
                        handleUtilityLineDrawing(e);
                    } else if (activeDrawingMode === 'service-tool') {
                        handleServiceConnection(e);
                    }
                }
                
                function handleDrainageLineDrawing(e) {
                    // Use snapping if enabled
                    let clickPoint = e.latlng;
                    let isValidPoint = false;
                    
                    const isStreetTool = activeDrawingMode === 'street-tool';
                    
                    if (snapEnabled && nearestValidPoint) {
                        clickPoint = nearestValidPoint;
                        isValidPoint = true;
                    } else {
                        // Check if click is on appropriate surface
                        const validResult = findNearestValidPoint(e.latlng, isStreetTool ? 'street' : 'curb');
                        isValidPoint = validResult.valid;
                        
                        if (isValidPoint) {
                            clickPoint = validResult.point;
                        }
                    }
                    
                    if (!isValidPoint) {
                        showNotification(`Can only draw ${isStreetTool ? 'street' : 'curb'} pitches on ${isStreetTool ? 'streets' : 'curbs'}`);
                        return;
                    }
                    
                    // Handle line drawing
                    if (!isDrawing) {
                        // Start new line
                        isDrawing = true;
                        drawingPoints = [clickPoint];
                        currentDrawingType = activeDrawingMode;
                        
                        // Create temporary line
                        tempLine = L.polyline([clickPoint, clickPoint], {
                            color: isStreetTool ? '#0075ff' : '#ffcc00',
                            weight: 5,
                            opacity: 0.7,
                            dashArray: '5,5'
                        }).addTo(map);
                        
                        // Show cancel drawing button
                        document.getElementById('cancel-drawing-btn').style.display = 'block';
                        
                        updateStatus('Click to complete the line or press Escape to cancel');
                    } else if (isDrawing && currentDrawingType === activeDrawingMode) {
                        // Complete line
                        drawingPoints.push(clickPoint);
                        completeDrainageLine();
                    }
                }
                
                function handleUtilityLineDrawing(e) {
                    // Use snapping if enabled
                    let clickPoint = e.latlng;
                    let isValidPoint = false;
                    
                    if (snapEnabled && nearestValidPoint) {
                        clickPoint = nearestValidPoint;
                        isValidPoint = true;
                    } else {
                        // Check if click is near a street (utilities typically follow streets)
                        const validResult = findNearestValidPoint(e.latlng, 'street');
                        isValidPoint = validResult.valid;
                        
                        if (isValidPoint) {
                            clickPoint = validResult.point;
                        }
                    }
                    
                    // Set utility type based on active tool
                    if (!currentUtilityType) {
                        if (activeDrawingMode === 'water-main-tool') currentUtilityType = 'water';
                        else if (activeDrawingMode === 'gas-main-tool') currentUtilityType = 'gas';
                        else if (activeDrawingMode === 'electric-main-tool') currentUtilityType = 'electric';
                        else if (activeDrawingMode === 'sewer-main-tool') currentUtilityType = 'sewer';
                        else if (activeDrawingMode === 'telecom-main-tool') currentUtilityType = 'telecom';
                    }
                    
                    // Handle line drawing
                    if (!isDrawing) {
                        // Start new line
                        isDrawing = true;
                        drawingPoints = [clickPoint];
                        currentDrawingType = 'utility-main';
                        
                        // Create temporary line
                        tempLine = L.polyline([clickPoint, clickPoint], {
                            color: getUtilityColor(currentUtilityType),
                            weight: 5,
                            opacity: 0.7,
                            dashArray: '5,5'
                        }).addTo(map);
                        
                        // Show cancel drawing button
                        document.getElementById('cancel-drawing-btn').style.display = 'block';
                        
                        updateStatus('Click to add points to the utility main. Double-click or click a second time to complete.');
                    } else if (isDrawing && currentDrawingType === 'utility-main') {
                        // Add point or complete line
                        // Check if this is a double-click or close to the first point
                        const firstPoint = drawingPoints[0];
                        const distToFirst = map.distance(clickPoint, firstPoint);
                        
                        if (distToFirst < 20 && drawingPoints.length > 1) {
                            // Close the loop if near the start
                            drawingPoints.push(firstPoint);
                            completeUtilityLine();
                        } else {
                            // Add point and continue
                            drawingPoints.push(clickPoint);
                            tempLine.setLatLngs(drawingPoints);
                        }
                    }
                }
                
                function handleGuideDrawing(e) {
                    if (!isDrawing) {
                        drawCustomGuide();
                        // Add first point
                        drawingPoints.push(e.latlng);
                        tempLine.setLatLngs([e.latlng, e.latlng]);
                    } else if (isDrawing && currentDrawingType === 'guide') {
                        // Add point to guide
                        drawingPoints.push(e.latlng);
                        tempLine.setLatLngs(drawingPoints);
                        
                        // Update status
                        updateStatus(`Guide has ${drawingPoints.length} points. Click "Finish Guide" when done.`);
                    }
                }
                
                function handleServiceConnection(e) {
                    if (!serviceConnectionStart) {
                        // First click - find the nearest utility line
                        const result = findNearestPoint('utility-all', e.latlng, 30);
                        
                        if (result.valid) {
                            // Found a utility line to connect from
                            serviceConnectionStart = {
                                point: result.point,
                                type: result.utilityType
                            };
                            
                            // Start drawing service connection
                            isDrawing = true;
                            drawingPoints = [result.point];
                            
                            // Create temporary line
                            tempLine = L.polyline([result.point, e.latlng], {
                                color: getUtilityColor(result.utilityType),
                                weight: 3,
                                opacity: 0.7,
                                dashArray: '3,5'
                            }).addTo(map);
                            
                            // Create marker at start point
                            tempUtilityMarker = L.circleMarker(result.point, {
                                radius: 5,
                                fillColor: getUtilityColor(result.utilityType),
                                color: '#fff',
                                weight: 2,
                                fillOpacity: 1
                            }).addTo(map);
                            
                            updateStatus('Click to place end point of service connection.');
                        } else {
                            showNotification('No utility main found nearby. Click near a utility line.');
                        }
                    } else {
                        // Second click - place end point
                        serviceConnectionEnd = e.latlng;
                        
                        // Complete service connection
                        completeServiceConnection();
                    }
                }
                
                function findNearestPoint(utilityType, point, maxDistancePx) {
                    let result = {
                        valid: false,
                        point: point,
                        utilityType: null,
                        line: null
                    };
                    
                    let minDistance = maxDistancePx;
                    
                    // Check appropriate utility layers
                    if (utilityType === 'utility-all' || utilityType === 'utility-water') {
                        utilityMains.water.forEach(main => {
                            const nearest = nearestPointOnArray(point, main.latlngs);
                            if (nearest.distPx < minDistance) {
                                minDistance = nearest.distPx;
                                result = {
                                    valid: true,
                                    point: nearest.point,
                                    utilityType: 'water',
                                    line: main
                                };
                            }
                        });
                    }
                    
                    if (utilityType === 'utility-all' || utilityType === 'utility-gas') {
                        utilityMains.gas.forEach(main => {
                            const nearest = nearestPointOnArray(point, main.latlngs);
                            if (nearest.distPx < minDistance) {
                                minDistance = nearest.distPx;
                                result = {
                                    valid: true,
                                    point: nearest.point,
                                    utilityType: 'gas',
                                    line: main
                                };
                            }
                        });
                    }
                    
                    if (utilityType === 'utility-all' || utilityType === 'utility-electric') {
                        utilityMains.electric.forEach(main => {
                            const nearest = nearestPointOnArray(point, main.latlngs);
                            if (nearest.distPx < minDistance) {
                                minDistance = nearest.distPx;
                                result = {
                                    valid: true,
                                    point: nearest.point,
                                    utilityType: 'electric',
                                    line: main
                                };
                            }
                        });
                    }
                    
                    if (utilityType === 'utility-all' || utilityType === 'utility-sewer') {
                        utilityMains.sewer.forEach(main => {
                            const nearest = nearestPointOnArray(point, main.latlngs);
                            if (nearest.distPx < minDistance) {
                                minDistance = nearest.distPx;
                                result = {
                                    valid: true,
                                    point: nearest.point,
                                    utilityType: 'sewer',
                                    line: main
                                };
                            }
                        });
                    }
                    
                    if (utilityType === 'utility-all' || utilityType === 'utility-telecom') {
                        utilityMains.telecom.forEach(main => {
                            const nearest = nearestPointOnArray(point, main.latlngs);
                            if (nearest.distPx < minDistance) {
                                minDistance = nearest.distPx;
                                result = {
                                    valid: true,
                                    point: nearest.point,
                                    utilityType: 'telecom',
                                    line: main
                                };
                            }
                        });
                    }
                    
                    return result;
                }
                
                function nearestPointOnArray(point, latlngs) {
                    let minDist = { distPx: Infinity, point: null };
                    
                    for (let i = 0; i < latlngs.length - 1; i++) {
                        const segmentResult = projectPointOnLineSegment(point, latlngs[i], latlngs[i+1]);
                        if (segmentResult.distancePx < minDist.distPx) {
                            minDist = {
                                distPx: segmentResult.distancePx,
                                point: segmentResult.nearestPoint
                            };
                        }
                    }
                    
                    return minDist;
                }
                
                function completeDrainageLine() {
                    // Remove temporary drawing line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Hide cancel drawing button
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    
                    // Reset drawing state
                    isDrawing = false;
                    
                    // Need at least 2 points for a valid line
                    if (drawingPoints.length < 2) {
                        drawingPoints = [];
                        return;
                    }
                    
                    // If drawing a curb line, snap to the nearest curb
                    if (currentDrawingType === 'curb-tool') {
                        snapLineToNearestCurb();
                    } else if (currentDrawingType === 'street-tool') {
                        snapLineToNearestStreet();
                    }
                    
                    // Show pitch input modal
                    showPitchModal();
                }
                
                function completeUtilityLine() {
                    // Remove temporary drawing line
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    // Hide cancel drawing button
                    document.getElementById('cancel-drawing-btn').style.display = 'none';
                    
                    // Reset drawing state
                    isDrawing = false;
                    
                    // Need at least 2 points for a valid line
                    if (drawingPoints.length < 2) {
                        drawingPoints = [];
                        currentUtilityType = null;
                        return;
                    }
                    
                    // Create the utility line
                    createUtilityLine(drawingPoints, currentUtilityType);
                    
                    // Reset current utility type
                    currentUtilityType = null;
                }
                
                function completeServiceConnection() {
                    // Remove temporary objects
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    
                    if (tempUtilityMarker) {
                        map.removeLayer(tempUtilityMarker);
                        tempUtilityMarker = null;
                    }
                    
                    // Reset drawing state
                    isDrawing = false;
                    
                    // Create the service connection
                    const serviceId = 'service-' + Date.now();
                    const servicePoints = [serviceConnectionStart.point, serviceConnectionEnd];
                    
                    // Create service connection line
                    const serviceLine = L.polyline(servicePoints, {
                        color: getUtilityColor(serviceConnectionStart.type),
                        weight: 3,
                        opacity: 0.9,
                        dashArray: '5,7',
                        className: `utility-${serviceConnectionStart.type}-line`
                    }).addTo(serviceConnectionsLayer);
                    
                    // Add connection markers
                    const mainMarker = L.circleMarker(serviceConnectionStart.point, {
                        radius: 5,
                        fillColor: getUtilityColor(serviceConnectionStart.type),
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).addTo(serviceConnectionsLayer);
                    
                    const endMarker = L.circleMarker(serviceConnectionEnd, {
                        radius: 5,
                        fillColor: getUtilityColor(serviceConnectionStart.type),
                        color: '#fff',
                        weight: 2,
                        fillOpacity: 1
                    }).addTo(serviceConnectionsLayer);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'service',
                        serviceId: serviceId,
                        line: serviceLine,
                        markers: [mainMarker, endMarker],
                        utilityType: serviceConnectionStart.type
                    });
                    
                    // Reset service connection state
                    serviceConnectionStart = null;
                    serviceConnectionEnd = null;
                    
                    // Update status
                    updateStatus('Service connection added');
                    showNotification('Service connection created');
                }
                
                function snapLineToNearestCurb() {
                    // For each point in the drawing, find the nearest point on any curb
                    const snappedPoints = [];
                    
                    drawingPoints.forEach(point => {
                        const validResult = findNearestValidPoint(point, 'curb');
                        if (validResult.valid) {
                            snappedPoints.push(validResult.point);
                        } else {
                            snappedPoints.push(point); // Keep original if no curb found
                        }
                    });
                    
                    // Replace drawing points with snapped points
                    if (snappedPoints.length === drawingPoints.length) {
                        drawingPoints = snappedPoints;
                    }
                }
                
                function snapLineToNearestStreet() {
                    // For each point in the drawing, find the nearest point on any street
                    const snappedPoints = [];
                    
                    drawingPoints.forEach(point => {
                        const validResult = findNearestValidPoint(point, 'street');
                        if (validResult.valid) {
                            snappedPoints.push(validResult.point);
                        } else {
                            snappedPoints.push(point); // Keep original if no street found
                        }
                    });
                    
                    // Replace drawing points with snapped points
                    if (snappedPoints.length === drawingPoints.length) {
                        drawingPoints = snappedPoints;
                    }
                }
                
                function finalizeLineWithPitch(percent) {
                    // Create final polyline
                    const lineType = currentDrawingType === 'street-tool' ? 'street' : 'curb';
                    const line = L.polyline(drawingPoints, {
                        color: lineType === 'street' ? '#0075ff' : '#ffcc00',
                        weight: 5,
                        opacity: 1,
                        className: `${lineType}-line`,
                        pitchPercent: percent,
                        lineType: lineType
                    });
                    
                    // Save to appropriate layer
                    if (lineType === 'street') {
                        line.addTo(streetPitchesLayer);
                    } else {
                        line.addTo(curbPitchesLayer);
                    }
                    
                    // Add direction arrow
                    addDirectionArrow(line);
                    
                    // Add pitch label
                    addPitchLabel(line);
                    
                    // Add flow animation
                    addFlowAnimation(line);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'line',
                        lineType: lineType,
                        layer: lineType === 'street' ? streetPitchesLayer : curbPitchesLayer,
                        element: line
                    });
                    
                    // Setup context menu for line
                    setupContextMenu(line, lineType);
                    
                    // Reset drawing points
                    drawingPoints = [];
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update status
                    updateStatus(`${lineType.charAt(0).toUpperCase() + lineType.slice(1)} pitch added at ${percent}%`);
                }
                
                function createUtilityLine(points, utilityType) {
                    // Create unique ID for this utility line
                    const mainId = `${utilityType}-main-${Date.now()}`;
                    
                    // Create final polyline
                    const line = L.polyline(points, {
                        color: getUtilityColor(utilityType),
                        weight: 5,
                        opacity: 1,
                        className: `utility-${utilityType}-line`
                    });
                    
                    // Get the appropriate layer based on utility type
                    let targetLayer;
                    switch (utilityType) {
                        case 'water': targetLayer = waterLinesLayer; break;
                        case 'gas': targetLayer = gasLinesLayer; break;
                        case 'electric': targetLayer = electricLinesLayer; break;
                        case 'sewer': targetLayer = sewerLinesLayer; break;
                        case 'telecom': targetLayer = telecomLinesLayer; break;
                        default: targetLayer = waterLinesLayer;
                    }
                    
                    // Add the line to the appropriate layer
                    line.addTo(targetLayer);
                    
                    // Store utility details with the line
                    line.utilityData = {
                        id: mainId,
                        type: utilityType,
                        size: 6, // Default size in inches
                        depth: 3  // Default depth in feet
                    };
                    
                    // Store in utility mains array
                    utilityMains[utilityType].push({
                        id: mainId,
                        latlngs: points,
                        line: line,
                        type: utilityType,
                        size: 6,
                        depth: 3
                    });
                    
                    // Setup context menu for line
                    setupContextMenu(line, `utility-${utilityType}`);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utility-main',
                        mainId: mainId,
                        utilityType: utilityType,
                        layer: targetLayer,
                        element: line
                    });
                    
                    // Check if we need to add connection to crossing utility
                    checkForUtilityCrossings(line, utilityType);
                    
                    // Update status
                    updateStatus(`${utilityType.charAt(0).toUpperCase() + utilityType.slice(1)} utility main added`);
                    showNotification('Utility main created');
                    
                    // Reset drawing state
                    drawingPoints = [];
                }
                
                function checkForUtilityCrossings(newLine, newUtilityType) {
                    // Get all utility types except the new one
                    const otherTypes = Object.keys(utilityMains).filter(type => type !== newUtilityType);
                    
                    // Check for crossings with each utility type
                    otherTypes.forEach(utilityType => {
                        utilityMains[utilityType].forEach(main => {
                            // Find intersection points
                            const intersections = findIntersections(newLine, main.line);
                            
                            // Process each intersection
                            intersections.forEach(intersection => {
                                // Add a connection marker at the intersection point
                                const connectionMarker = L.circleMarker(intersection, {
                                    radius: 4,
                                    color: '#fff',
                                    weight: 2,
                                    fillColor: '#333',
                                    fillOpacity: 1,
                                    className: 'utility-connection'
                                }).addTo(targetLayer);
                                
                                // Store connection data
                                connectionMarker.connectionData = {
                                    point: intersection,
                                    utilities: [
                                        { type: newUtilityType, id: newLine.utilityData.id },
                                        { type: utilityType, id: main.line.utilityData.id }
                                    ]
                                };
                            });
                        });
                    });
                }
                
                function findIntersections(line1, line2) {
                    const intersections = [];
                    const line1Points = line1.getLatLngs();
                    const line2Points = line2.getLatLngs();
                    
                    // Check each segment of line1 against each segment of line2
                    for (let i = 0; i < line1Points.length - 1; i++) {
                        for (let j = 0; j < line2Points.length - 1; j++) {
                            // Convert to screen coordinates
                            const a = map.latLngToLayerPoint(line1Points[i]);
                            const b = map.latLngToLayerPoint(line1Points[i + 1]);
                            const c = map.latLngToLayerPoint(line2Points[j]);
                            const d = map.latLngToLayerPoint(line2Points[j + 1]);
                            
                            // Calculate intersection
                            const intersection = lineIntersection(a, b, c, d);
                            
                            if (intersection) {
                                // Convert back to geographic coordinates
                                const intersectionLatLng = map.layerPointToLatLng(intersection);
                                intersections.push(intersectionLatLng);
                            }
                        }
                    }
                    
                    return intersections;
                }
                
                function lineIntersection(a, b, c, d) {
                    // Line AB represented as a1x + b1y = c1
                    const a1 = b.y - a.y;
                    const b1 = a.x - b.x;
                    const c1 = a1 * a.x + b1 * a.y;
                    
                    // Line CD represented as a2x + b2y = c2
                    const a2 = d.y - c.y;
                    const b2 = c.x - d.x;
                    const c2 = a2 * c.x + b2 * c.y;
                    
                    const determinant = a1 * b2 - a2 * b1;
                    
                    if (determinant === 0) {
                        // Lines are parallel
                        return null;
                    }
                    
                    // Calculate intersection point
                    const x = (b2 * c1 - b1 * c2) / determinant;
                    const y = (a1 * c2 - a2 * c1) / determinant;
                    const point = L.point(x, y);
                    
                    // Check if the intersection is within both line segments
                    if (isPointOnSegment(point, a, b) && isPointOnSegment(point, c, d)) {
                        return point;
                    }
                    
                    return null;
                }
                
                function isPointOnSegment(p, a, b) {
                    // Check if point p is on line segment ab
                    const minX = Math.min(a.x, b.x) - 1; // Small buffer for numerical precision
                    const maxX = Math.max(a.x, b.x) + 1;
                    const minY = Math.min(a.y, b.y) - 1;
                    const maxY = Math.max(a.y, b.y) + 1;
                    
                    return p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY;
                }
                
                function setupContextMenu(element, elementType) {
                    // Add context menu for right-click or long press
                    element.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        handleContextMenu(e, element, elementType);
                    });
                    
                    // Handle long press for mobile
                    let longPressTimer;
                    const longPressDuration = 500; // ms
                    
                    element.on('pointerdown', function(e) {
                        L.DomEvent.stopPropagation(e);
                        longPressTimer = setTimeout(() => {
                            handleContextMenu(e.originalEvent, element, elementType);
                        }, longPressDuration);
                    });
                    
                    element.on('pointerup pointercancel pointermove', function() {
                        clearTimeout(longPressTimer);
                    });
                }
                
                function handleContextMenu(e, element, elementType) {
                    // Store the selected element
                    selectedElement = {
                        element: element,
                        type: elementType
                    };
                    
                    // Get container point
                    let containerPoint;
                    if (e.containerPoint) {
                        containerPoint = e.containerPoint;
                    } else if (e.latlng) {
                        containerPoint = map.latLngToContainerPoint(e.latlng);
                    } else if (e.touches && e.touches.length > 0) {
                        containerPoint = L.point(e.touches[0].clientX, e.touches[0].clientY);
                    } else if (element.getLatLng) {
                        containerPoint = map.latLngToContainerPoint(element.getLatLng());
                    } else {
                        containerPoint = map.latLngToContainerPoint(element.getLatLngs()[0]);
                    }
                    
                    // Position the context menu
                    const contextMenu = document.getElementById('context-menu');
                    contextMenu.style.left = `${containerPoint.x}px`;
                    contextMenu.style.top = `${containerPoint.y}px`;
                    
                    // Show/hide appropriate menu items based on element type
                    const reverseItem = document.getElementById('reverse-direction');
                    const editItem = document.getElementById('edit-item');
                    
                    if (elementType === 'street' || elementType === 'curb') {
                        reverseItem.style.display = 'flex';
                        editItem.style.display = 'none';
                    } else if (elementType.startsWith('utility-')) {
                        reverseItem.style.display = 'none';
                        editItem.style.display = 'flex';
                    } else {
                        reverseItem.style.display = 'none';
                        editItem.style.display = 'none';
                    }
                    
                    // Show the menu
                    contextMenu.style.display = 'block';
                }
                
                function hideContextMenu() {
                    document.getElementById('context-menu').style.display = 'none';
                    selectedElement = null;
                }
                
                function addDirectionArrow(line) {
                    // Get line midpoint
                    const latlngs = line.getLatLngs();
                    const midIndex = Math.floor(latlngs.length / 2);
                    const point1 = latlngs[midIndex > 0 ? midIndex - 1 : 0];
                    const point2 = latlngs[midIndex];
                    
                    // Calculate angle
                    const p1 = map.latLngToLayerPoint(point1);
                    const p2 = map.latLngToLayerPoint(point2);
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    // Create SVG arrow icon
                    const arrowSvg = `
                        <div class="pitch-arrow">
                            <svg viewBox="0 0 24 24" class="${line.options.lineType}-arrow">
                                <path d="M12,2L4,12h5v8h6v-8h5L12,2z" style="transform: rotate(${angle}deg); transform-origin: center;"/>
                            </svg>
                        </div>
                    `;
                    
                    const arrowIcon = L.divIcon({
                        html: arrowSvg,
                        className: '',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    // Create marker and associate with line
                    const arrowMarker = L.marker(point2, {
                        icon: arrowIcon,
                        interactive: false
                    });
                    
                    // Add to appropriate layer
                    if (line.options.lineType === 'street') {
                        arrowMarker.addTo(streetPitchesLayer);
                    } else {
                        arrowMarker.addTo(curbPitchesLayer);
                    }
                    
                    // Store reference
                    line.arrowMarker = arrowMarker;
                }
                
                function addPitchLabel(line) {
                    // Get first point of line
                    const latlngs = line.getLatLngs();
                    const point = latlngs[0];
                    
                    // Create label icon
                    const labelHtml = `
                        <div style="background-color: white; padding: 2px 6px; border-radius: 10px; font-size: 12px; font-weight: bold; border: 2px solid ${line.options.lineType === 'street' ? '#0075ff' : '#ffcc00'};">
                            ${line.options.pitchPercent}%
                        </div>
                    `;
                    
                    const labelIcon = L.divIcon({
                        html: labelHtml,
                        className: '',
                        iconSize: [40, 24],
                        iconAnchor: [20, 12]
                    });
                    
                    // Create marker and associate with line
                    const labelMarker = L.marker(point, {
                        icon: labelIcon,
                        interactive: false
                    });
                    
                    // Add to appropriate layer
                    if (line.options.lineType === 'street') {
                        labelMarker.addTo(streetPitchesLayer);
                    } else {
                        labelMarker.addTo(curbPitchesLayer);
                    }
                    
                    // Store reference
                    line.labelMarker = labelMarker;
                }
                
                function addFlowAnimation(line) {
                    // Get line element
                    const path = line.getElement();
                    if (!path) return;
                    
                    // Apply flow animation class
                    path.classList.add('flow-animation');
                    
                    // Add line-specific stroke-dasharray based on line length
                    const length = path.getTotalLength();
                    path.style.strokeDasharray = `${length / 6},${length / 8}`;
                }
                
                function addCatchBasin(latlng) {
                    // Create catch basin icon
                    const catchBasinIcon = L.divIcon({
                        html: '<div class="catch-basin-icon"><i class="fas fa-water"></i></div>',
                        className: '',
                        iconSize: [36, 36],
                        iconAnchor: [18, 18]
                    });
                    
                    // Create marker
                    const marker = L.marker(latlng, {
                        icon: catchBasinIcon,
                        draggable: true
                    }).addTo(catchBasinsLayer);
                    
                    // Setup context menu for marker
                    setupContextMenu(marker, 'catchBasin');
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'marker',
                        markerType: 'catchBasin',
                        layer: catchBasinsLayer,
                        element: marker
                    });
                    
                    // Update status
                    updateStatus('Catch basin added');
                    
                    // Check for trapped water after adding catch basin
                    detectTrappedWater();
                }
                
                function reversePitchDirection() {
                    if (!selectedElement || (selectedElement.type !== 'street' && selectedElement.type !== 'curb')) {
                        return;
                    }
                    
                    // Get the line
                    const line = selectedElement.element;
                    
                    // Reverse points
                    const latlngs = line.getLatLngs();
                    line.setLatLngs(latlngs.reverse());
                    
                    // Remove old markers
                    if (line.arrowMarker) {
                        if (selectedElement.type === 'street') {
                            streetPitchesLayer.removeLayer(line.arrowMarker);
                        } else {
                            curbPitchesLayer.removeLayer(line.arrowMarker);
                        }
                    }
                    
                    if (line.labelMarker) {
                        if (selectedElement.type === 'street') {
                            streetPitchesLayer.removeLayer(line.labelMarker);
                        } else {
                            curbPitchesLayer.removeLayer(line.labelMarker);
                        }
                    }
                    
                    // Add new arrow and label
                    addDirectionArrow(line);
                    addPitchLabel(line);
                    
                    // Update flow animation
                    addFlowAnimation(line);
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Check for trapped water
                    detectTrappedWater();
                    
                    // Update status
                    updateStatus('Pitch direction reversed');
                }
                
                function deleteItem() {
                    if (!selectedElement) return;
                    
                    // Delete based on element type
                    if (selectedElement.type === 'street') {
                        // Remove arrow and label markers
                        if (selectedElement.element.arrowMarker) {
                            streetPitchesLayer.removeLayer(selectedElement.element.arrowMarker);
                        }
                        if (selectedElement.element.labelMarker) {
                            streetPitchesLayer.removeLayer(selectedElement.element.labelMarker);
                        }
                        
                        // Remove line
                        streetPitchesLayer.removeLayer(selectedElement.element);
                        
                    } else if (selectedElement.type === 'curb') {
                        // Remove arrow and label markers
                        if (selectedElement.element.arrowMarker) {
                            curbPitchesLayer.removeLayer(selectedElement.element.arrowMarker);
                        }
                        if (selectedElement.element.labelMarker) {
                            curbPitchesLayer.removeLayer(selectedElement.element.labelMarker);
                        }
                        
                        // Remove line
                        curbPitchesLayer.removeLayer(selectedElement.element);
                        
                    } else if (selectedElement.type === 'catchBasin') {
                        catchBasinsLayer.removeLayer(selectedElement.element);
                    } else if (selectedElement.type.startsWith('utility-')) {
                        // Get utility type from element type
                        const utilityType = selectedElement.type.replace('utility-', '');
                        const line = selectedElement.element;
                        
                        // Find and remove from utilityMains array
                        const mainIndex = utilityMains[utilityType].findIndex(main => main.id === line.utilityData.id);
                        if (mainIndex !== -1) {
                            utilityMains[utilityType].splice(mainIndex, 1);
                        }
                        
                        // Remove the line from the map
                        let targetLayer;
                        switch (utilityType) {
                            case 'water': targetLayer = waterLinesLayer; break;
                            case 'gas': targetLayer = gasLinesLayer; break;
                            case 'electric': targetLayer = electricLinesLayer; break;
                            case 'sewer': targetLayer = sewerLinesLayer; break;
                            case 'telecom': targetLayer = telecomLinesLayer; break;
                        }
                        
                        if (targetLayer) {
                            targetLayer.removeLayer(line);
                        }
                    }
                    
                    // Hide context menu
                    hideContextMenu();
                    
                    // Check for trapped water if in drainage mode
                    if (currentMode === 'drainage') {
                        detectTrappedWater();
                    }
                    
                    // Update status
                    updateStatus('Element deleted');
                }
                
                function editItem() {
                    if (!selectedElement || !selectedElement.type.startsWith('utility-')) {
                        return;
                    }
                    
                    // Get the utility line
                    const line = selectedElement.element;
                    const utilityType = selectedElement.type.replace('utility-', '');
                    
                    // Show utility edit modal
                    showUtilityDetailsModal(line, utilityType);
                    
                    // Hide context menu
                    hideContextMenu();
                }
                
                function showUtilityDetailsModal(line, utilityType) {
                    // Populate form with current values
                    document.getElementById('utility-type').value = utilityType;
                    document.getElementById('utility-size').value = line.utilityData.size || 6;
                    document.getElementById('utility-depth').value = line.utilityData.depth || 3;
                    
                    // Update modal title
                    document.querySelector('.modal-header').textContent = 'Edit Utility Details';
                    
                    // Show modal
                    document.getElementById('utility-details-modal').style.display = 'flex';
                    
                    // Store reference to utility being edited
                    selectedUtility = line;
                }
                
                function detectTrappedWater() {
                    // Clear existing trapped water areas
                    trappedWaterLayer.clearLayers();
                    
                    // Build drainage network
                    const drainageNetwork = buildDrainageNetwork();
                    
                    // Find potential drainage problems
                    const problemAreas = findDrainageProblems(drainageNetwork);
                    
                    // Visualize problem areas
                    problemAreas.forEach(problem => {
                        addTrappedWaterIndicator(problem.center, problem.radius);
                    });
                }
                
                class DrainageNetwork {
                    constructor() {
                        this.nodes = new Map(); // Maps node IDs to node objects
                        this.edges = []; // Array of edge objects
                        this.drainagePoints = []; // Array of catch basin locations
                        this.nodeIdCounter = 0;
                    }
                    
                    addNode(latlng) {
                        const id = `node-${this.nodeIdCounter++}`;
                        const node = {
                            id: id,
                            latlng: latlng,
                            edges: []
                        };
                        this.nodes.set(id, node);
                        return node;
                    }
                    
                    addEdge(line) {
                        const latlngs = line.getLatLngs();
                        if (latlngs.length < 2) return;
                        
                        // Get or create start and end nodes
                        const startNode = this.getOrCreateNode(latlngs[0]);
                        const endNode = this.getOrCreateNode(latlngs[latlngs.length - 1]);
                        
                        // Create edge
                        const edge = {
                            id: `edge-${this.edges.length}`,
                            line: line,
                            start: startNode,
                            end: endNode,
                            pitchPercent: line.options.pitchPercent,
                            type: line.options.lineType
                        };
                        
                        // Add edge to network
                        this.edges.push(edge);
                        
                        // Add edge to nodes
                        startNode.edges.push(edge);
                        endNode.edges.push(edge);
                        
                        return edge;
                    }
                    
                    getOrCreateNode(latlng) {
                        // Check if node exists at this location (within a small threshold)
                        const threshold = 0.0001; // Approximately a few meters
                        for (const [id, node] of this.nodes.entries()) {
                            const distance = L.latLng(node.latlng).distanceTo(L.latLng(latlng));
                            if (distance < threshold) {
                                return node;
                            }
                        }
                        
                        // Create new node
                        return this.addNode(latlng);
                    }
                    
                    addDrainagePoint(latlng) {
                        // Add catch basin as drainage point
                        this.drainagePoints.push(latlng);
                        
                        // Create a node for the drainage point
                        const drainNode = this.getOrCreateNode(latlng);
                        drainNode.isDrainagePoint = true;
                    }
                    
                    getOutflowNodes() {
                        // Find all nodes that have outflowing water
                        const outflowNodes = [];
                        
                        for (const [id, node] of this.nodes.entries()) {
                            // Check if node has more outflow edges than inflow edges
                            let inflows = 0;
                            let outflows = 0;
                            
                            node.edges.forEach(edge => {
                                if (edge.end === node) {
                                    inflows++;
                                } else if (edge.start === node) {
                                    outflows++;
                                }
                            });
                            
                            // If more outflows than inflows, or is a drainage point, it's an outflow node
                            if (outflows > inflows || node.isDrainagePoint) {
                                outflowNodes.push(node);
                            }
                        }
                        
                        return outflowNodes;
                    }
                    
                    getNodesWithoutOutflow() {
                        // Find nodes that have no outflow (potential trapped water)
                        const nodesWithoutOutflow = [];
                        
                        for (const [id, node] of this.nodes.entries()) {
                            // Skip drainage points
                            if (node.isDrainagePoint) continue;
                            
                            // Check if node has any outflow edges
                            let hasOutflow = false;
                            
                            node.edges.forEach(edge => {
                                if (edge.start === node) {
                                    hasOutflow = true;
                                }
                            });
                            
                            // If no outflow and not a drainage point, it's a potential problem
                            if (!hasOutflow) {
                                nodesWithoutOutflow.push(node);
                            }
                        }
                        
                        return nodesWithoutOutflow;
                    }
                }
                
                function buildDrainageNetwork() {
                    // Create a new drainage network
                    const network = new DrainageNetwork();
                    
                    // Add all street pitches as edges
                    streetPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                            network.addEdge(layer);
                        }
                    });
                    
                    // Add all curb pitches as edges
                    curbPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && !layer.arrowMarker && !layer.labelMarker) {
                            network.addEdge(layer);
                        }
                    });
                    
                    // Add catch basins as drainage points
                    catchBasinsLayer.eachLayer(function(layer) {
                        network.addDrainagePoint(layer.getLatLng());
                    });
                    
                    return network;
                }
                
                function findDrainageProblems(network) {
                    // Find nodes without outflow (potential trapped water)
                    const problemNodes = network.getNodesWithoutOutflow();
                    
                    // Create problem areas around these nodes
                    return problemNodes.map(node => {
                        return {
                            center: node.latlng,
                            radius: 5 // Default radius in meters
                        };
                    });
                }
                
                function addTrappedWaterIndicator(center, radius) {
                    // Create a circle to represent trapped water
                    const circle = L.circle(center, {
                        radius: radius,
                        fillColor: 'red',
                        fillOpacity: 0.6,
                        color: 'red',
                        weight: 2,
                        className: 'trapped-water-area'
                    }).addTo(trappedWaterLayer);
                    
                    // Add pulsing animation via CSS class
                    const path = circle.getElement();
                    if (path) {
                        path.classList.add('pulse-animation');
                    }
                }
                
                function showPitchModal() {
                    document.getElementById('pitch-modal').style.display = 'flex';
                    document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    document.getElementById('pitch-modal-title').textContent = 
                        `Set ${currentDrawingType === 'street-tool' ? 'Street' : 'Curb'} Pitch Percentage`;
                }
                
                function hideUtilityInfo() {
                    utilityInfoCard.style.display = 'none';
                    selectedUtility = null;
                }
                
                function getUtilityColor(type) {
                    // Return appropriate color based on utility type
                    switch (type) {
                        case 'water': return '#2196f3'; // Blue
                        case 'gas': return '#ff9800'; // Orange
                        case 'electric': return '#ffeb3b'; // Yellow
                        case 'sewer': return '#795548'; // Brown
                        case 'telecom': return '#9c27b0'; // Purple
                        default: return '#673ab7'; // Default purple
                    }
                }
                
                function getUtilityIcon(type) {
                    // Return appropriate Font Awesome icon based on utility type
                    switch (type) {
                        case 'water': return 'tint';
                        case 'gas': return 'fire';
                        case 'electric': return 'bolt';
                        case 'sewer': return 'toilet';
                        case 'telecom': return 'phone';
                        default: return 'tools';
                    }
                }
                
                function showNotification(message) {
                    const notification = document.getElementById('notification');
                    document.getElementById('notification-text').textContent = message;
                    notification.classList.add('visible');
                    
                    setTimeout(() => {
                        notification.classList.remove('visible');
                    }, 3000);
                }
                
                function updateStatus(message) {
                    document.getElementById('status-text').textContent = message;
                }
                
                function addToUndoStack(action) {
                    undoStack.push(action);
                    updateUndoButtonState();
                }
                
                function updateUndoButtonState() {
                    const undoButton = document.getElementById('undo-btn');
                    const toolbarUndoButton = document.getElementById('toolbar-undo-btn');
                    const utilityUndoButton = document.getElementById('utility-undo-btn');
                    
                    if (undoStack.length > 0) {
                        undoButton.style.opacity = '1';
                        undoButton.disabled = false;
                        toolbarUndoButton.style.opacity = '1';
                        toolbarUndoButton.disabled = false;
                        utilityUndoButton.style.opacity = '1';
                        utilityUndoButton.disabled = false;
                    } else {
                        undoButton.style.opacity = '0.5';
                        undoButton.disabled = true;
                        toolbarUndoButton.style.opacity = '0.5';
                        toolbarUndoButton.disabled = true;
                        utilityUndoButton.style.opacity = '0.5';
                        utilityUndoButton.disabled = true;
                    }
                }
                
                function undoLastAction() {
                    if (undoStack.length === 0) return;
                    
                    const action = undoStack.pop();
                    
                    if (action.type === 'line') {
                        // Remove arrow and label markers
                        if (action.element.arrowMarker) {
                            action.layer.removeLayer(action.element.arrowMarker);
                        }
                        if (action.element.labelMarker) {
                            action.layer.removeLayer(action.element.labelMarker);
                        }
                        
                        // Remove line
                        action.layer.removeLayer(action.element);
                        
                    } else if (action.type === 'marker') {
                        action.layer.removeLayer(action.element);
                    } else if (action.type === 'utility-main') {
                        // Remove from map
                        action.layer.removeLayer(action.element);
                        
                        // Remove from utility mains array
                        const mainIndex = utilityMains[action.utilityType].findIndex(main => main.id === action.mainId);
                        if (mainIndex !== -1) {
                            utilityMains[action.utilityType].splice(mainIndex, 1);
                        }
                    } else if (action.type === 'service') {
                        // Remove service connection
                        serviceConnectionsLayer.removeLayer(action.line);
                        action.markers.forEach(marker => {
                            serviceConnectionsLayer.removeLayer(marker);
                        });
                    } else if (action.type === 'guide') {
                        // Remove guide
                        customGuidesLayer.removeLayer(action.element);
                        
                        // Remove associated curb lines
                        const guideId = action.guideId;
                        
                        // Find and remove from custom guides array
                        const guideIndex = customGuides.findIndex(g => g.id === guideId);
                        if (guideIndex !== -1) {
                            customGuides.splice(guideIndex, 1);
                        }
                        
                        // Find and remove associated curbs
                        const curbsToRemove = curbs.filter(c => 
                            c.id === `${guideId}-left` || c.id === `${guideId}-right`);
                        
                        curbsToRemove.forEach(curb => {
                            const curbIndex = curbs.findIndex(c => c.id === curb.id);
                            if (curbIndex !== -1) {
                                curbs.splice(curbIndex, 1);
                            }
                        });
                        
                        // Need to rebuild curb guides layer
                        curbGuidesLayer.clearLayers();
                        curbs.forEach(curb => {
                            L.polyline(curb.latlngs, {
                                className: 'curb-guide',
                                interactive: true,
                                bubblingMouseEvents: false
                            }).addTo(curbGuidesLayer);
                        });
                    }
                    
                    // Check for trapped water if in drainage mode
                    if (currentMode === 'drainage') {
                        detectTrappedWater();
                    }
                    
                    // Update button state
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('Last action undone');
                }
                
                function clearDrainage() {
                    // Clear drainage elements
                    streetPitchesLayer.clearLayers();
                    curbPitchesLayer.clearLayers();
                    catchBasinsLayer.clearLayers();
                    trappedWaterLayer.clearLayers();
                    
                    // Clear drainage related undo actions
                    undoStack = undoStack.filter(action => 
                        !(action.type === 'line' || 
                        (action.type === 'marker' && action.markerType === 'catchBasin')));
                    
                    updateUndoButtonState();
                    
                    // Update status
                    updateStatus('Drainage elements cleared');
                    showNotification('All drainage elements cleared');
                }
                
                function clearUtilities() {
                    // Clear utility layers
                    waterLinesLayer.clearLayers();
                    gasLinesLayer.clearLayers();
                    electricLinesLayer.clearLayers();
                    sewerLinesLayer.clearLayers();
                    telecomLinesLayer.clearLayers();
                    serviceConnectionsLayer.clearLayers();
                    
                    // Clear utility mains data
                    utilityMains = {
                        water: [],
                        gas: [],
                        electric: [],
                        sewer: [],
                        telecom: []
                    };
                    
                    // Clear utility related undo actions
                    undoStack = undoStack.filter(action => 
                        !(action.type === 'utility-main' || action.type === 'service'));
                    
                    updateUndoButtonState();
                    
                    // Hide utility info if open
                    hideUtilityInfo();
                    
                    // Update status
                    updateStatus('Utility elements cleared');
                    showNotification('All utility elements cleared');
                }
                
                function switchMode(e) {
                    // Get the selected mode
                    const mode = e.target.getAttribute('data-mode');
                    
                    // Update current mode
                    currentMode = mode;
                    
                    // Update active tab
                    document.querySelectorAll('.mode-tab').forEach(tab => {
                        tab.classList.remove('active');
                    });
                    e.target.classList.add('active');
                    
                    // Reset active drawing mode
                    setActiveDrawingMode(null);
                    
                    // Show/hide appropriate toolbars
                    if (mode === 'drainage') {
                        document.getElementById('drainage-toolbar').style.display = 'flex';
                        document.getElementById('utilities-toolbar').style.display = 'none';
                    } else { // utilities mode
                        document.getElementById('drainage-toolbar').style.display = 'none';
                        document.getElementById('utilities-toolbar').style.display = 'flex';
                    }
                    
                    // Update status
                    updateStatus(`${mode.charAt(0).toUpperCase() + mode.slice(1)} mode active. Select a tool to begin.`);
                }
                
                function toggleLayerVisibility(layerType, visible) {
                    switch (layerType) {
                        case 'street':
                            if (visible) map.addLayer(streetPitchesLayer);
                            else map.removeLayer(streetPitchesLayer);
                            break;
                        case 'curb':
                            if (visible) map.addLayer(curbPitchesLayer);
                            else map.removeLayer(curbPitchesLayer);
                            break;
                        case 'basin':
                            if (visible) map.addLayer(catchBasinsLayer);
                            else map.removeLayer(catchBasinsLayer);
                            break;
                        case 'trapped':
                            if (visible) map.addLayer(trappedWaterLayer);
                            else map.removeLayer(trappedWaterLayer);
                            break;
                        case 'guide':
                            if (visible) {
                                map.addLayer(streetGuidesLayer);
                                map.addLayer(curbGuidesLayer);
                                map.addLayer(customGuidesLayer);
                            } else {
                                map.removeLayer(streetGuidesLayer);
                                map.removeLayer(curbGuidesLayer);
                                map.removeLayer(customGuidesLayer);
                            }
                            break;
                        case 'water':
                            if (visible) map.addLayer(waterLinesLayer);
                            else map.removeLayer(waterLinesLayer);
                            break;
                        case 'gas':
                            if (visible) map.addLayer(gasLinesLayer);
                            else map.removeLayer(gasLinesLayer);
                            break;
                        case 'electric':
                            if (visible) map.addLayer(electricLinesLayer);
                            else map.removeLayer(electricLinesLayer);
                            break;
                        case 'sewer':
                            if (visible) map.addLayer(sewerLinesLayer);
                            else map.removeLayer(sewerLinesLayer);
                            break;
                        case 'telecom':
                            if (visible) map.addLayer(telecomLinesLayer);
                            else map.removeLayer(telecomLinesLayer);
                            break;
                    }
                }
                
                function setActiveDrawingMode(mode) {
                    // Reset drawing state
                    cancelDrawing();
                    
                    // Remove active class from all tools
                    document.querySelectorAll('.tool-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    // Set new active mode
                    if (mode) {
                        document.getElementById(mode).classList.add('active');
                        activeDrawingMode = mode;
                        
                        // Show the cancel drawing button for drawing tools
                        if (mode === 'street-tool' || mode === 'curb-tool' || 
                            mode === 'draw-guide-tool' || mode.includes('main-tool') ||
                            mode === 'service-tool') {
                            document.getElementById('cancel-drawing-btn').style.display = 'block';
                        }
                        
                        // Update status based on tool
                        updateToolStatus(mode);
                    } else {
                        activeDrawingMode = null;
                        updateStatus(`${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)} mode active. Select a tool to begin.`);
                    }
                }
                
                function updateToolStatus(mode) {
                    switch (mode) {
                        case 'street-tool':
                            updateStatus('Click on a street to start drawing a pitch line');
                            break;
                        case 'curb-tool':
                            updateStatus('Click on a curb to start drawing a pitch line');
                            break;
                        case 'catch-basin-tool':
                            updateStatus('Click to place a catch basin');
                            break;
                        case 'draw-guide-tool':
                            updateStatus('Click to draw a custom street guide');
                            break;
                        case 'water-main-tool':
                            updateStatus('Click to start drawing a water main');
                            break;
                        case 'gas-main-tool':
                            updateStatus('Click to start drawing a gas main');
                            break;
                        case 'electric-main-tool':
                            updateStatus('Click to start drawing an electric main');
                            break;
                        case 'sewer-main-tool':
                            updateStatus('Click to start drawing a sewer main');
                            break;
                        case 'telecom-main-tool':
                            updateStatus('Click to start drawing a telecom main');
                            break;
                        case 'service-tool':
                            updateStatus('Click near a utility main to start a service connection');
                            break;
                        case 'analyze-tool':
                            analyzeWaterFlow();
                            break;
                        default:
                            updateStatus('Select a tool to begin');
                    }
                }
                
                function cancelDrawing() {
                    // Cancel any active drawing
                    if (isDrawing) {
                        if (tempLine) {
                            map.removeLayer(tempLine);
                            tempLine = null;
                        }
                        if (tempUtilityMarker) {
                            map.removeLayer(tempUtilityMarker);
                            tempUtilityMarker = null;
                        }
                        if (tempUtilityLine) {
                            map.removeLayer(tempUtilityLine);
                            tempUtilityLine = null;
                        }
                        isDrawing = false;
                        drawingPoints = [];
                        
                        // Reset service connection state
                        serviceConnectionStart = null;
                        serviceConnectionEnd = null;
                        
                        // Reset current utility type if in a utility mode
                        if (currentMode === 'utilities') {
                            currentUtilityType = null;
                        }
                        
                        // Hide finish guide button
                        finishGuideBtn.classList.remove('visible');
                    }
                    
                    // Hide any open modals
                    document.getElementById('utility-direction-modal').style.display = 'none';
                    document.getElementById('utility-details-modal').style.display = 'none';
                    document.getElementById('service-connection-modal').style.display = 'none';
                }
                
                function analyzeWaterFlow() {
                    // Start analysis animation
                    updateStatus('Analyzing drainage network...');
                    
                    // Short delay to show animation
                    setTimeout(() => {
                        // Build drainage network
                        const network = buildDrainageNetwork();
                        
                        // Find potential drainage problems
                        const problemAreas = findDrainageProblems(network);
                        
                        // Clear existing indicators
                        trappedWaterLayer.clearLayers();
                        
                        // Visualize problem areas
                        problemAreas.forEach(problem => {
                            addTrappedWaterIndicator(problem.center, problem.radius);
                        });
                        
                        // Update status with results
                        if (problemAreas.length > 0) {
                            updateStatus(`Analysis complete. Found ${problemAreas.length} potential drainage issue${problemAreas.length === 1 ? '' : 's'}.`);
                            showNotification(`Found ${problemAreas.length} drainage issue${problemAreas.length === 1 ? '' : 's'}`);
                        } else {
                            updateStatus('Analysis complete. No drainage issues found.');
                            showNotification('No drainage issues found');
                        }
                    }, 1000);
                }
                
                function exportAsImage() {
                    // Hide UI elements
                    toggleUIForExport(false);
                    
                    // Capture the map
                    html2canvas(document.querySelector('#map')).then(canvas => {
                        // Restore UI
                        toggleUIForExport(true);
                        
                        // Create download link
                        const link = document.createElement('a');
                        link.download = `CAC-Pocket-${currentMode}-plan.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        
                        showNotification('Image exported successfully');
                    }).catch(err => {
                        console.error('Error exporting image:', err);
                        toggleUIForExport(true);
                        showNotification('Error exporting image');
                    });
                }
                
                function toggleUIForExport(show) {
                    // Hide/show UI elements for clean export
                    const elements = [
                        '.mode-tabs', '.action-bar', '.drawing-toolbar', 
                        '.utilities-toolbar', '.always-visible-controls',
                        '.status-bar', '.context-menu', '.notification'
                    ];
                    
                    elements.forEach(selector => {
                        const elems = document.querySelectorAll(selector);
                        elems.forEach(elem => {
                            elem.style.display = show ? '' : 'none';
                        });
                    });
                }
                
                function initUIHandlers() {
                    // Mode tab selection
                    document.querySelectorAll('.mode-tab').forEach(tab => {
                        tab.addEventListener('click', switchMode);
                    });
                    
                    // Drainage tool button clicks
                    document.getElementById('street-tool').addEventListener('click', function() {
                        setActiveDrawingMode('street-tool');
                    });
                    
                    document.getElementById('curb-tool').addEventListener('click', function() {
                        setActiveDrawingMode('curb-tool');
                    });
                    
                    document.getElementById('catch-basin-tool').addEventListener('click', function() {
                        setActiveDrawingMode('catch-basin-tool');
                    });
                    
                    document.getElementById('draw-guide-tool').addEventListener('click', function() {
                        setActiveDrawingMode('draw-guide-tool');
                    });
                    
                    document.getElementById('analyze-tool').addEventListener('click', function() {
                        analyzeWaterFlow();
                    });
                    
                    document.getElementById('clear-drainage-tool').addEventListener('click', function() {
                        if (confirm('Are you sure you want to clear all drainage elements?')) {
                            clearDrainage();
                        }
                    });
                    
                    // Utility tool button clicks
                    document.getElementById('water-main-tool').addEventListener('click', function() {
                        setActiveDrawingMode('water-main-tool');
                        currentUtilityType = 'water';
                    });
                    
                    document.getElementById('gas-main-tool').addEventListener('click', function() {
                        setActiveDrawingMode('gas-main-tool');
                        currentUtilityType = 'gas';
                    });
                    
                    document.getElementById('electric-main-tool').addEventListener('click', function() {
                        setActiveDrawingMode('electric-main-tool');
                        currentUtilityType = 'electric';
                    });
                    
                    document.getElementById('sewer-main-tool').addEventListener('click', function() {
                        setActiveDrawingMode('sewer-main-tool');
                        currentUtilityType = 'sewer';
                    });
                    
                    document.getElementById('telecom-main-tool').addEventListener('click', function() {
                        setActiveDrawingMode('telecom-main-tool');
                        currentUtilityType = 'telecom';
                    });
                    
                    document.getElementById('service-tool').addEventListener('click', function() {
                        setActiveDrawingMode('service-tool');
                    });
                    
                    document.getElementById('clear-utility-tool').addEventListener('click', function() {
                        if (confirm('Are you sure you want to clear all utility elements?')) {
                            clearUtilities();
                        }
                    });
                    
                    // Always visible controls
                    document.getElementById('zoom-in-btn').addEventListener('click', function() {
                        map.zoomIn(1);
                    });
                    
                    document.getElementById('zoom-out-btn').addEventListener('click', function() {
                        map.zoomOut(1);
                    });
                    
                    document.getElementById('cancel-drawing-btn').addEventListener('click', function() {
                        cancelDrawing();
                        setActiveDrawingMode(null);
                        this.style.display = 'none';
                        updateStatus('Drawing canceled');
                    });
                    
                    // Action buttons
                    document.getElementById('locate-btn').addEventListener('click', function() {
                        if (currentPosition) {
                            map.setView(currentPosition, 19);
                        } else {
                            getUserLocation();
                        }
                    });
                    
                    document.getElementById('undo-btn').addEventListener('click', undoLastAction);
                    document.getElementById('toolbar-undo-btn').addEventListener('click', undoLastAction);
                    document.getElementById('utility-undo-btn').addEventListener('click', undoLastAction);
                    
                    document.getElementById('menu-btn').addEventListener('click', function() {
                        document.getElementById('menu-panel').classList.toggle('visible');
                    });
                    
                    document.getElementById('help-btn').addEventListener('click', function() {
                        document.getElementById('help-modal').style.display = 'flex';
                    });
                    
                    // Finish guide button
                    document.getElementById('finish-guide-btn').addEventListener('click', function() {
                        if (isDrawing && currentDrawingType === 'guide') {
                            completeCustomGuide();
                        }
                    });
                    
                    // Layer toggle handlers
                    document.getElementById('street-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('street', this.checked);
                    });
                    
                    document.getElementById('curb-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('curb', this.checked);
                    });
                    
                    document.getElementById('basin-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('basin', this.checked);
                    });
                    
                    document.getElementById('trapped-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('trapped', this.checked);
                    });
                    
                    document.getElementById('guide-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('guide', this.checked);
                    });
                    
                    // Utility layer toggles
                    document.getElementById('water-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('water', this.checked);
                    });
                    
                    document.getElementById('gas-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('gas', this.checked);
                    });
                    
                    document.getElementById('electric-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('electric', this.checked);
                    });
                    
                    document.getElementById('sewer-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('sewer', this.checked);
                    });
                    
                    document.getElementById('telecom-toggle').addEventListener('change', function() {
                        toggleLayerVisibility('telecom', this.checked);
                    });
                    
                    // Basemap selection
                    document.querySelectorAll('.basemap-option').forEach(option => {
                        option.addEventListener('click', function() {
                            const basemapId = this.getAttribute('data-basemap');
                            
                            // Update active state
                            document.querySelectorAll('.basemap-option').forEach(opt => {
                                opt.classList.remove('active');
                            });
                            this.classList.add('active');
                            
                            // Switch basemap
                            Object.values(basemaps).forEach(layer => {
                                if (map.hasLayer(layer)) {
                                    map.removeLayer(layer);
                                }
                            });
                            
                            basemaps[basemapId].addTo(map);
                        });
                    });
                    
                    // Snap toggle
                    document.getElementById('snap-toggle').addEventListener('change', function() {
                        snapEnabled = this.checked;
                    });
                    
                    // Highlight toggle
                    document.getElementById('highlight-toggle').addEventListener('change', function() {
                        highlightEnabled = this.checked;
                        if (!highlightEnabled) {
                            highlightArea.style.display = 'none';
                        }
                    });
                    
                    // Export buttons
                    document.getElementById('export-image-btn').addEventListener('click', exportAsImage);
                    
                    document.getElementById('export-pdf-btn').addEventListener('click', function() {
                        // Placeholder for PDF export
                        showNotification('PDF export coming soon');
                    });
                    
                    document.getElementById('save-project-btn').addEventListener('click', function() {
                        // Placeholder for save functionality
                        showNotification('Project saving coming soon');
                    });
                    
                    // Menu panel close
                    document.querySelector('.menu-panel-close').addEventListener('click', function() {
                        document.getElementById('menu-panel').classList.remove('visible');
                    });
                    
                    // Pitch modal handlers
                    document.getElementById('increase-pitch').addEventListener('click', function() {
                        pitchPercent = Math.min(10, pitchPercent + 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('decrease-pitch').addEventListener('click', function() {
                        pitchPercent = Math.max(0.1, pitchPercent - 0.1);
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    });
                    
                    document.getElementById('cancel-pitch').addEventListener('click', function() {
                        document.getElementById('pitch-modal').style.display = 'none';
                        drawingPoints = [];
                    });
                    
                    document.getElementById('confirm-pitch').addEventListener('click', function() {
                        document.getElementById('pitch-modal').style.display = 'none';
                        finalizeLineWithPitch(pitchPercent);
                    });
                    
                    // Utility direction modal handlers
                    document.getElementById('rotate-left').addEventListener('click', function() {
                        utilityAngle = (utilityAngle - 15) % 360;
                        if (utilityAngle < 0) utilityAngle += 360;
                        updateDirectionIndicator();
                    });
                    
                    document.getElementById('rotate-right').addEventListener('click', function() {
                        utilityAngle = (utilityAngle + 15) % 360;
                        updateDirectionIndicator();
                    });
                    
                    document.getElementById('cancel-direction').addEventListener('click', function() {
                        document.getElementById('utility-direction-modal').style.display = 'none';
                        if (tempUtilityMarker) {
                            map.removeLayer(tempUtilityMarker);
                            tempUtilityMarker = null;
                        }
                        if (tempUtilityLine) {
                            map.removeLayer(tempUtilityLine);
                            tempUtilityLine = null;
                        }
                    });
                    
                    document.getElementById('confirm-direction').addEventListener('click', function() {
                        document.getElementById('utility-direction-modal').style.display = 'none';
                        // This would lead to the next step in utility placement
                    });
                    
                    // Utility details modal handlers
                    document.getElementById('cancel-details').addEventListener('click', function() {
                        document.getElementById('utility-details-modal').style.display = 'none';
                        // Reset selected utility
                        selectedUtility = null;
                    });
                    
                    document.getElementById('confirm-details').addEventListener('click', function() {
                        document.getElementById('utility-details-modal').style.display = 'none';
                        
                        // Update utility data if editing an existing utility
                        if (selectedUtility) {
                            const utilityType = document.getElementById('utility-type').value;
                            const size = parseInt(document.getElementById('utility-size').value);
                            const depth = parseInt(document.getElementById('utility-depth').value);
                            
                            // Update the utility data
                            selectedUtility.utilityData.type = utilityType;
                            selectedUtility.utilityData.size = size;
                            selectedUtility.utilityData.depth = depth;
                            
                            // Also update in the utility mains array
                            const mainIndex = utilityMains[utilityType].findIndex(main => main.id === selectedUtility.utilityData.id);
                            if (mainIndex !== -1) {
                                utilityMains[utilityType][mainIndex].size = size;
                                utilityMains[utilityType][mainIndex].depth = depth;
                            }
                            
                            showNotification('Utility updated');
                        }
                        
                        // Reset selected utility
                        selectedUtility = null;
                    });
                    
                    // Context menu item handlers
                    document.getElementById('edit-item').addEventListener('click', editItem);
                    document.getElementById('reverse-direction').addEventListener('click', reversePitchDirection);
                    document.getElementById('delete-item').addEventListener('click', deleteItem);
                    
                    // Utility info card close button
                    document.querySelector('.utility-info-close').addEventListener('click', hideUtilityInfo);
                    
                    // Help modal close
                    document.querySelector('.help-close').addEventListener('click', function() {
                        document.getElementById('help-modal').style.display = 'none';
                    });
                    
                    // Location modal handlers
                    document.getElementById('location-current-btn').addEventListener('click', function() {
                        document.getElementById('location-modal').style.display = 'none';
                        getUserLocation();
                    });
                    
                    document.getElementById('location-search-btn').addEventListener('click', searchLocation);
                    
                    document.querySelector('.location-close').addEventListener('click', function() {
                        document.getElementById('location-modal').style.display = 'none';
                        
                        // If no location is set yet, use default NYC location
                        if (!currentPosition) {
                            map.setView([40.7128, -74.0060], 16);
                            loadRoadData();
                        }
                    });
                    
                    // Borough selection
                    document.querySelectorAll('.borough-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            // Toggle active state
                            if (this.classList.contains('active')) {
                                this.classList.remove('active');
                                selectedBorough = null;
                            } else {
                                // Remove active class from all borough buttons
                                document.querySelectorAll('.borough-btn').forEach(b => {
                                    b.classList.remove('active');
                                });
                                
                                // Set active class on clicked borough
                                this.classList.add('active');
                                selectedBorough = this.getAttribute('data-borough');
                            }
                        });
                    });
                    
                    // Keyboard event for Escape to cancel drawing
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape') {
                            if (isDrawing) {
                                cancelDrawing();
                                updateStatus('Drawing canceled. Select a tool to begin.');
                            }
                        }
                    });
                    
                    // Hide context menu on document click
                    document.addEventListener('click', hideContextMenu);
                    
                    // Initialize undo button state
                    updateUndoButtonState();
                }
                
                // Add html2canvas for image export
                function loadHtml2Canvas() {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                    document.head.appendChild(script);
                }
                
                // Load additional libraries
                loadHtml2Canvas();
            }
        });
    </script>
</body>
</html>
