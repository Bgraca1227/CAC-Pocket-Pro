<<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FlowMaster Pro</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Material Design Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/material-design-icons/4.0.0/font/MaterialIcons-Regular.min.css" />
    <!-- Google Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        :root {
            --primary-color: #2962ff;
            --street-color: #2962ff;
            --curb-color: #ffb300;
            --marker-color: #7c4dff;
            --error-color: #f44336;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --background-color: #f5f5f5;
            --card-color: #ffffff;
            --text-color: #212121;
            --text-light: #757575;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', 'Segoe UI', Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        /* Map */
        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        .app-container {
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        /* Action Bar */
        .action-bar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            background-color: var(--card-color);
            border-radius: 16px;
            box-shadow: var(--shadow);
            padding: 8px;
            gap: 12px;
            max-width: 95%;
        }

        .action-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--card-color);
            color: var(--text-color);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: none;
            position: relative;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button:focus {
            outline: none;
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: #ffffff;
        }

        .action-button.street-tool {
            background-color: var(--street-color);
            color: #ffffff;
        }

        .action-button.curb-tool {
            background-color: var(--curb-color);
            color: #212121;
        }

        .action-button.catchbasin-tool {
            background-color: var(--marker-color);
            color: #ffffff;
        }

        .action-button.highpoint-tool {
            background-color: var(--warning-color);
            color: #212121;
        }

        .action-button i {
            font-size: 24px;
        }

        .action-button-label {
            position: absolute;
            bottom: -24px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-color);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .action-button:hover .action-button-label {
            opacity: 1;
        }

        .main-action-button {
            width: 64px;
            height: 64px;
            transform: translateY(-10px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            background-color: var(--primary-color);
            color: white;
        }

        /* Location & Zoom Controls */
        .map-controls {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .map-control-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--card-color);
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--shadow);
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-color);
        }

        .map-control-button:active {
            transform: scale(0.95);
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            top: 16px;
            left: 16px;
            background-color: var(--card-color);
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            z-index: 1000;
            max-width: 70%;
        }

        .status-bar i {
            margin-right: 8px;
            color: var(--primary-color);
        }

        .status-text {
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Map Overlays */
        .pitch-label {
            background-color: var(--card-color);
            border: none;
            font-weight: bold;
            border-radius: 8px;
            padding: 4px 8px;
            box-shadow: var(--shadow);
            white-space: nowrap;
            color: var(--text-color);
            font-size: 12px;
        }

        .street-label {
            border-left: 4px solid var(--street-color);
        }

        .curb-label {
            border-left: 4px solid var(--curb-color);
        }

        .arrow-icon {
            background-color: var(--card-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: var(--shadow);
        }

        .street-arrow {
            color: var(--street-color);
        }

        .curb-arrow {
            color: var(--curb-color);
        }

        .high-point-icon, .catch-basin-icon {
            width: 32px;
            height: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            background-color: var(--card-color);
            box-shadow: var(--shadow);
        }

        .high-point-icon {
            color: var(--warning-color);
        }

        .catch-basin-icon {
            color: var(--marker-color);
        }

        .water-trap {
            background-color: rgba(244, 67, 54, 0.6);
            border: 2px solid var(--error-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
        }

        /* Dialogs and Modals */
        .dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 16px;
        }

        .dialog-card {
            background-color: var(--card-color);
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            width: 100%;
            max-width: 320px;
            overflow: hidden;
        }

        .dialog-header {
            padding: 16px;
            border-bottom: 1px solid #eee;
        }

        .dialog-title {
            font-size: 18px;
            font-weight: 500;
            margin: 0;
        }

        .dialog-content {
            padding: 16px;
        }

        .dialog-actions {
            padding: 8px 16px 16px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .button {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .button:active {
            transform: scale(0.98);
        }

        .button-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .button-secondary {
            background-color: transparent;
            color: var(--primary-color);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-light);
        }

        .form-control {
            width: 100%;
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 16px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--card-color);
            color: var(--text-color);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            pointer-events: none;
        }

        .toast.visible {
            opacity: 1;
        }

        /* Loading & Splash Screens */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #eee;
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }

        .loading-text {
            font-size: 16px;
            color: var(--text-color);
        }

        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 4000;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 48px;
            margin-bottom: 24px;
        }

        .splash-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.9;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Help Guide */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .help-overlay.visible {
            display: block;
            opacity: 1;
        }

        .help-card {
            position: absolute;
            background-color: white;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            max-width: 280px;
            z-index: 3001;
            animation: bounce 0.5s ease;
        }

        .help-title {
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .help-text {
            font-size: 14px;
            color: var(--text-light);
            margin-bottom: 16px;
        }

        .help-next {
            text-align: right;
        }

        .help-arrow {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            transform: rotate(45deg);
        }

        @keyframes bounce {
            0% { transform: scale(0.8); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Responsive Adjustments */
        @media (max-width: 480px) {
            .action-bar {
                gap: 8px;
                padding: 6px;
            }
            
            .action-button {
                width: 48px;
                height: 48px;
            }
            
            .main-action-button {
                width: 56px;
                height: 56px;
            }
            
            .status-bar {
                max-width: 60%;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-water"></i>
        </div>
        <div class="splash-title">FlowMaster Pro</div>
        <div class="splash-subtitle">Professional Drainage Planning Tool</div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Map Element -->
        <div id="map"></div>

        <!-- Status Bar -->
        <div class="status-bar">
            <i class="fas fa-map-marker-alt"></i>
            <div class="status-text">Loading map...</div>
        </div>

        <!-- Main Action Bar -->
        <div class="action-bar">
            <button class="action-button street-tool" id="street-btn">
                <i class="fas fa-road"></i>
                <span class="action-button-label">Street Pitch</span>
            </button>
            <button class="action-button curb-tool" id="curb-btn">
                <i class="fas fa-grip-lines"></i>
                <span class="action-button-label">Curb Pitch</span>
            </button>
            <button class="action-button main-action-button" id="locate-btn">
                <i class="fas fa-crosshairs"></i>
                <span class="action-button-label">My Location</span>
            </button>
            <button class="action-button catchbasin-tool" id="catchbasin-btn">
                <i class="fas fa-drain"></i>
                <span class="action-button-label">Catch Basin</span>
            </button>
            <button class="action-button highpoint-tool" id="highpoint-btn">
                <i class="fas fa-chevron-up"></i>
                <span class="action-button-label">High Point</span>
            </button>
        </div>

        <!-- Map Controls -->
        <div class="map-controls">
            <button class="map-control-button" id="zoom-in-btn">
                <i class="fas fa-plus"></i>
            </button>
            <button class="map-control-button" id="zoom-out-btn">
                <i class="fas fa-minus"></i>
            </button>
            <button class="map-control-button" id="help-btn">
                <i class="fas fa-question"></i>
            </button>
            <button class="map-control-button" id="save-btn">
                <i class="fas fa-save"></i>
            </button>
            <button class="map-control-button" id="clear-btn">
                <i class="fas fa-trash"></i>
            </button>
        </div>

        <!-- Pitch Input Dialog -->
        <div class="dialog" id="pitch-dialog">
            <div class="dialog-card">
                <div class="dialog-header">
                    <h3 class="dialog-title">Set Pitch Percentage</h3>
                </div>
                <div class="dialog-content">
                    <div class="form-group">
                        <label class="form-label" for="pitch-value">Pitch (%)</label>
                        <input type="number" class="form-control" id="pitch-value" min="0.1" max="20" step="0.1" value="2.0">
                    </div>
                </div>
                <div class="dialog-actions">
                    <button class="button button-secondary" id="cancel-pitch-btn">Cancel</button>
                    <button class="button button-primary" id="save-pitch-btn">Save</button>
                </div>
            </div>
        </div>

        <!-- Confirm Clear Dialog -->
        <div class="dialog" id="confirm-dialog">
            <div class="dialog-card">
                <div class="dialog-header">
                    <h3 class="dialog-title">Confirm Action</h3>
                </div>
                <div class="dialog-content">
                    <p id="confirm-message">Are you sure you want to clear all items?</p>
                </div>
                <div class="dialog-actions">
                    <button class="button button-secondary" id="cancel-confirm-btn">Cancel</button>
                    <button class="button button-primary" id="confirm-btn">Confirm</button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div class="toast" id="toast">
            <i class="fas fa-info-circle"></i>
            <span id="toast-message">Notification message</span>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-text">Loading map data...</div>
        </div>

        <!-- Help Overlay -->
        <div class="help-overlay" id="help-overlay">
            <!-- Help cards will be dynamically added here -->
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for splash screen
            setTimeout(() => {
                document.querySelector('.splash-screen').style.opacity = 0;
                setTimeout(() => {
                    document.querySelector('.splash-screen').style.display = 'none';
                    initApp();
                }, 500);
            }, 2000);

            function initApp() {
                // Initialize variables
                let map, userMarker, userLocation;
                let drawingMode = null;
                let streets = L.featureGroup();
                let curbs = L.featureGroup();
                let catchBasins = L.featureGroup();
                let highPoints = L.featureGroup();
                let waterTraps = L.featureGroup();
                let drawingLine = null;
                let drawingPoints = [];
                let pendingLine = null;
                let streetGuides = L.featureGroup();
                let curbGuides = L.featureGroup();
                
                // State variables
                const appState = {
                    loading: true,
                    currentAction: null,
                    confirmAction: null,
                    tempLine: null,
                    streetColor: '#2962ff',
                    curbColor: '#ffb300',
                    lastPitchValue: 2.0
                };

                // Initialize the map
                initMap();
                
                // Initialize all event handlers
                initEventHandlers();

                // Helper functions
                function initMap() {
                    // Create map
                    map = L.map('map', {
                        zoomControl: false,
                        attributionControl: false
                    }).setView([0, 0], 19);

                    // Add tile layer (OpenStreetMap)
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 22
                    }).addTo(map);

                    // Add layer groups to map
                    streets.addTo(map);
                    curbs.addTo(map);
                    catchBasins.addTo(map);
                    highPoints.addTo(map);
                    waterTraps.addTo(map);
                    streetGuides.addTo(map);
                    curbGuides.addTo(map);

                    // Map events
                    map.on('click', handleMapClick);
                    map.on('mousemove', handleMouseMove);

                    // Get user location
                    getUserLocation();
                }

                function getUserLocation() {
                    showLoading('Getting your location...');
                    
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            function(position) {
                                userLocation = [position.coords.latitude, position.coords.longitude];
                                
                                // Update map view
                                map.setView(userLocation, 19);
                                
                                // Create user marker
                                if (!userMarker) {
                                    userMarker = L.circleMarker(userLocation, {
                                        radius: 8,
                                        fillColor: '#2962ff',
                                        color: '#ffffff',
                                        weight: 2,
                                        opacity: 1,
                                        fillOpacity: 0.8
                                    }).addTo(map);
                                } else {
                                    userMarker.setLatLng(userLocation);
                                }
                                
                                updateStatus('Location found');
                                hideLoading();
                                
                                // Set up continuous location tracking
                                navigator.geolocation.watchPosition(function(position) {
                                    userLocation = [position.coords.latitude, position.coords.longitude];
                                    if (userMarker) {
                                        userMarker.setLatLng(userLocation);
                                    }
                                }, function(error) {
                                    console.error('Error watching position:', error);
                                }, {
                                    enableHighAccuracy: true,
                                    maximumAge: 0,
                                    timeout: 5000
                                });
                                
                                // Generate guides for streets and curbs based on map data
                                generateGuides(userLocation);
                                
                            },
                            function(error) {
                                console.error('Error getting location:', error);
                                updateStatus('Location access denied');
                                hideLoading();
                                map.setView([40.7128, -74.0060], 19);
                            },
                            {
                                enableHighAccuracy: true,
                                maximumAge: 0,
                                timeout: 5000
                            }
                        );
                    } else {
                        updateStatus('Geolocation not supported');
                        hideLoading();
                        map.setView([40.7128, -74.0060], 19);
                    }
                }

                // Generate guide lines for streets and curbs based on map data
                function generateGuides(centerLocation) {
                    // In a real app, this would use actual map data
                    // For our demo, we'll create artificial guides around the user's location
                    
                    // Clear existing guides
                    streetGuides.clearLayers();
                    curbGuides.clearLayers();
                    
                    const gridSize = 0.001; // Roughly 100 meters
                    const lat = centerLocation[0];
                    const lng = centerLocation[1];
                    
                    // Create a grid of streets
                    for (let i = -2; i <= 2; i++) {
                        // Horizontal streets
                        const hStreet = L.polyline([
                            [lat + (i * gridSize), lng - (2 * gridSize)],
                            [lat + (i * gridSize), lng + (2 * gridSize)]
                        ], {
                            color: '#2962ff',
                            weight: 6,
                            opacity: 0.3,
                            dashArray: '10, 10'
                        });
                        
                        // Horizontal curbs (top and bottom of street)
                        const hCurbTop = L.polyline([
                            [lat + (i * gridSize) + (gridSize * 0.05), lng - (2 * gridSize)],
                            [lat + (i * gridSize) + (gridSize * 0.05), lng + (2 * gridSize)]
                        ], {
                            color: '#ffb300',
                            weight: 4,
                            opacity: 0.3,
                            dashArray: '5, 5'
                        });
                        
                        const hCurbBottom = L.polyline([
                            [lat + (i * gridSize) - (gridSize * 0.05), lng - (2 * gridSize)],
                            [lat + (i * gridSize) - (gridSize * 0.05), lng + (2 * gridSize)]
                        ], {
                            color: '#ffb300',
                            weight: 4,
                            opacity: 0.3,
                            dashArray: '5, 5'
                        });
                        
                        // Vertical streets
                        const vStreet = L.polyline([
                            [lat - (2 * gridSize), lng + (i * gridSize)],
                            [lat + (2 * gridSize), lng + (i * gridSize)]
                        ], {
                            color: '#2962ff',
                            weight: 6,
                            opacity: 0.3,
                            dashArray: '10, 10'
                        });
                        
                        // Vertical curbs (left and right of street)
                        const vCurbLeft = L.polyline([
                            [lat - (2 * gridSize), lng + (i * gridSize) - (gridSize * 0.05)],
                            [lat + (2 * gridSize), lng + (i * gridSize) - (gridSize * 0.05)]
                        ], {
                            color: '#ffb300',
                            weight: 4,
                            opacity: 0.3,
                            dashArray: '5, 5'
                        });
                        
                        const vCurbRight = L.polyline([
                            [lat - (2 * gridSize), lng + (i * gridSize) + (gridSize * 0.05)],
                            [lat + (2 * gridSize), lng + (i * gridSize) + (gridSize * 0.05)]
                        ], {
                            color: '#ffb300',
                            weight: 4,
                            opacity: 0.3,
                            dashArray: '5, 5'
                        });
                        
                        // Add to guides
                        streetGuides.addLayer(hStreet);
                        streetGuides.addLayer(vStreet);
                        
                        curbGuides.addLayer(hCurbTop);
                        curbGuides.addLayer(hCurbBottom);
                        curbGuides.addLayer(vCurbLeft);
                        curbGuides.addLayer(vCurbRight);
                    }
                }

                function findClosestGuide(point, mode) {
                    // Get guides layer based on mode
                    const guides = mode === 'street' ? streetGuides : curbGuides;
                    
                    // Find closest guide and point on that guide
                    let minDistance = Infinity;
                    let closestPoint = null;
                    let closestGuide = null;
                    
                    guides.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline) {
                            const latLngs = layer.getLatLngs();
                            
                            for (let i = 0; i < latLngs.length - 1; i++) {
                                const start = latLngs[i];
                                const end = latLngs[i+1];
                                
                                const projectedPoint = projectPointOnLine(point, start, end);
                                const distance = map.distance(point, projectedPoint);
                                
                                if (distance < minDistance) {
                                    minDistance = distance;
                                    closestPoint = projectedPoint;
                                    closestGuide = layer;
                                }
                            }
                        }
                    });
                    
                    // Only snap if within 20 meters
                    return minDistance <= 20 ? { point: closestPoint, guide: closestGuide } : null;
                }

                function projectPointOnLine(point, lineStart, lineEnd) {
                    const x = point.lat;
                    const y = point.lng;
                    const x1 = lineStart.lat;
                    const y1 = lineStart.lng;
                    const x2 = lineEnd.lat;
                    const y2 = lineEnd.lng;
                    
                    // Calculate projection
                    const A = x - x1;
                    const B = y - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    
                    const dot = A * C + B * D;
                    const len_sq = C * C + D * D;
                    const param = len_sq !== 0 ? dot / len_sq : -1;
                    
                    let xx, yy;
                    
                    if (param < 0) {
                        xx = x1;
                        yy = y1;
                    } else if (param > 1) {
                        xx = x2;
                        yy = y2;
                    } else {
                        xx = x1 + param * C;
                        yy = y1 + param * D;
                    }
                    
                    return L.latLng(xx, yy);
                }

                function handleMapClick(e) {
                    const clickPoint = e.latlng;
                    
                    if (drawingMode === 'street' || drawingMode === 'curb') {
                        // Find closest guide for snapping
                        const closest = findClosestGuide(clickPoint, drawingMode);
                        
                        if (closest) {
                            // If we're not drawing yet, start a new line
                            if (drawingPoints.length === 0) {
                                drawingPoints.push(closest.point);
                                
                                // Show temporary line
                                drawingLine = L.polyline([closest.point], {
                                    color: drawingMode === 'street' ? appState.streetColor : appState.curbColor,
                                    weight: 5,
                                    opacity: 0.7,
                                    dashArray: '5, 5'
                                }).addTo(map);
                                
                                showToast(`Started drawing ${drawingMode} pitch line`);
                            } else {
                                // Add point to existing line
                                drawingPoints.push(closest.point);
                                drawingLine.setLatLngs(drawingPoints);
                                
                                // If user clicks near the first point, complete the line
                                if (drawingPoints.length > 1 && 
                                    map.distance(closest.point, drawingPoints[0]) < 20 && 
                                    drawingPoints.length > 2) {
                                    
                                    finishDrawing();
                                }
                            }
                        } else {
                            showToast(`Please draw along ${drawingMode} guides`);
                        }
                    } else if (drawingMode === 'catchbasin') {
                        addCatchBasin(clickPoint);
                    } else if (drawingMode === 'highpoint') {
                        addHighPoint(clickPoint);
                    }
                }

                function handleMouseMove(e) {
                    if (drawingLine && drawingPoints.length > 0) {
                        // Current mouse position
                        const mousePoint = e.latlng;
                        
                        // Find closest guide for snapping
                        const closest = findClosestGuide(mousePoint, drawingMode);
                        
                        if (closest) {
                            // Create temporary line showing from last point to current mouse
                            const tempPoints = [...drawingPoints, closest.point];
                            drawingLine.setLatLngs(tempPoints);
                        }
                    }
                }

                function finishDrawing() {
                    if (drawingPoints.length < 2) {
                        cancelDrawing();
                        return;
                    }
                    
                    // Store the points for when the dialog is confirmed
                    pendingLine = {
                        points: [...drawingPoints],
                        type: drawingMode
                    };
                    
                    // Remove temporary drawing line
                    if (drawingLine) {
                        map.removeLayer(drawingLine);
                        drawingLine = null;
                    }
                    
                    // Show pitch input dialog
                    showPitchDialog();
                    
                    // Reset drawing state
                    drawingPoints = [];
                }

                function cancelDrawing() {
                    // Clear drawing state
                    drawingPoints = [];
                    
                    // Remove temp line
                    if (drawingLine) {
                        map.removeLayer(drawingLine);
                        drawingLine = null;
                    }
                    
                    showToast('Drawing cancelled');
                }

                function addPitchLine(points, pitchValue, type) {
                    // Create final polyline
                    const line = L.polyline(points, {
                        color: type === 'street' ? appState.streetColor : appState.curbColor,
                        weight: 5,
                        opacity: 0.9,
                        pitchValue: pitchValue,
                        pitchType: type
                    });
                    
                    // Add to appropriate layer
                    if (type === 'street') {
                        streets.addLayer(line);
                    } else {
                        curbs.addLayer(line);
                    }
                    
                    // Add direction arrow
                    addDirectionArrow(line);
                    
                    // Add pitch label
                    addPitchLabel(line);
                    
                    // Check for water traps
                    checkWaterTraps();
                    
                    showToast(`Added ${pitchValue}% ${type} pitch line`);
                }

                function addDirectionArrow(line) {
                    const points = line.getLatLngs();
                    if (points.length < 2) return;
                    
                    // Get middle of line
                    const midIndex = Math.floor(points.length / 2);
                    const midPoint = points[midIndex];
                    const prevPoint = points[midIndex - 1];
                    
                    // Calculate arrow angle
                    const angle = getAngle(prevPoint, midPoint);
                    
                    // Create arrow icon
                    const arrowClass = line.options.pitchType === 'street' ? 'street-arrow' : 'curb-arrow';
                    const arrowIcon = L.divIcon({
                        html: `<div class="arrow-icon"><i class="fas fa-arrow-down" style="transform: rotate(${angle}deg);"></i></div>`,
                        className: arrowClass,
                        iconSize: [24, 24]
                    });
                    
                    // Create marker
                    const arrow = L.marker(midPoint, {
                        icon: arrowIcon,
                        interactive: false
                    }).addTo(map);
                    
                    // Store reference
                    line.arrow = arrow;
                }

                function addPitchLabel(line) {
                    const points = line.getLatLngs();
                    if (points.length < 2) return;
                    
                    // Get start of line
                    const startPoint = points[0];
                    
                    // Create label icon
                    const labelClass = line.options.pitchType === 'street' ? 'street-label' : 'curb-label';
                    const labelIcon = L.divIcon({
                        html: `<div class="pitch-label ${labelClass}">${line.options.pitchValue}%</div>`,
                        className: '',
                        iconSize: [40, 20]
                    });
                    
                    // Create marker
                    const label = L.marker(startPoint, {
                        icon: labelIcon,
                        interactive: false
                    }).addTo(map);
                    
                    // Store reference
                    line.label = label;
                }

                function getAngle(start, end) {
                    const lat1 = start.lat * Math.PI / 180;
                    const lat2 = end.lat * Math.PI / 180;
                    const lng1 = start.lng * Math.PI / 180;
                    const lng2 = end.lng * Math.PI / 180;
                    
                    const y = Math.sin(lng2 - lng1) * Math.cos(lat2);
                    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lng2 - lng1);
                    
                    let angle = Math.atan2(y, x) * 180 / Math.PI;
                    angle = (angle + 360) % 360;
                    
                    return angle;
                }

                function addCatchBasin(point) {
                    const catchBasinIcon = L.divIcon({
                        html: `<div class="catch-basin-icon"><i class="fas fa-drain"></i></div>`,
                        className: '',
                        iconSize: [32, 32]
                    });
                    
                    const basin = L.marker(point, {
                        icon: catchBasinIcon,
                        draggable: true
                    }).addTo(catchBasins);
                    
                    // On drag end, check for water traps
                    basin.on('dragend', function() {
                        checkWaterTraps();
                    });
                    
                    // Check for water traps
                    checkWaterTraps();
                    
                    showToast('Catch basin added');
                }

                function addHighPoint(point) {
                    const highPointIcon = L.divIcon({
                        html: `<div class="high-point-icon"><i class="fas fa-chevron-up"></i></div>`,
                        className: '',
                        iconSize: [32, 32]
                    });
                    
                    const highPoint = L.marker(point, {
                        icon: highPointIcon,
                        draggable: true
                    }).addTo(highPoints);
                    
                    // On drag end, check for water traps
                    highPoint.on('dragend', function() {
                        checkWaterTraps();
                    });
                    
                    // Check for water traps
                    checkWaterTraps();
                    
                    showToast('High point added');
                }

                function checkWaterTraps() {
                    // Clear existing water traps
                    waterTraps.clearLayers();
                    
                    // Get all pitch lines
                    const allLines = [];
                    streets.eachLayer(line => allLines.push(line));
                    curbs.eachLayer(line => allLines.push(line));
                    
                    // Check for intersecting pitch lines that don't have a catch basin nearby
                    const intersections = findIntersections(allLines);
                    
                    // For each intersection, check if there's a catch basin nearby
                    intersections.forEach(intersection => {
                        let hasCatchBasin = false;
                        
                        // Check distance to each catch basin
                        catchBasins.eachLayer(basin => {
                            const distance = map.distance(basin.getLatLng(), intersection.point);
                            if (distance < 20) {
                                hasCatchBasin = true;
                            }
                        });
                        
                        // If no catch basin found and there's a water trap (flow directions meet)
                        if (!hasCatchBasin && intersection.isWaterTrap) {
                            // Add water trap marker
                            const trapIcon = L.divIcon({
                                html: `<div class="water-trap"></div>`,
                                className: '',
                                iconSize: [20, 20]
                            });
                            
                            const trap = L.marker(intersection.point, {
                                icon: trapIcon,
                                interactive: false
                            }).addTo(waterTraps);
                        }
                    });
                }

                function findIntersections(lines) {
                    const intersections = [];
                    
                    // Check each pair of lines
                    for (let i = 0; i < lines.length; i++) {
                        for (let j = i + 1; j < lines.length; j++) {
                            const line1 = lines[i];
                            const line2 = lines[j];
                            
                            const points1 = line1.getLatLngs();
                            const points2 = line2.getLatLngs();
                            
                            // Check each segment against each segment
                            for (let a = 0; a < points1.length - 1; a++) {
                                for (let b = 0; b < points2.length - 1; b++) {
                                    const intersection = findSegmentIntersection(
                                        points1[a], points1[a+1], 
                                        points2[b], points2[b+1]
                                    );
                                    
                                    if (intersection) {
                                        // Determine if this is a water trap (flow directions meet)
                                        // Get flow directions for both lines at this point
                                        const flow1 = getFlowDirection(line1, intersection);
                                        const flow2 = getFlowDirection(line2, intersection);
                                        
                                        // If flows point toward each other, it's a water trap
                                        const dotProduct = flow1.lat * flow2.lat + flow1.lng * flow2.lng;
                                        const isWaterTrap = dotProduct < 0; // Negative dot product means opposite directions
                                        
                                        intersections.push({
                                            point: intersection,
                                            isWaterTrap: isWaterTrap
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    return intersections;
                }

                function findSegmentIntersection(p1, p2, p3, p4) {
                    // Convert to Cartesian coordinates for simplicity
                    const x1 = p1.lat, y1 = p1.lng;
                    const x2 = p2.lat, y2 = p2.lng;
                    const x3 = p3.lat, y3 = p3.lng;
                    const x4 = p4.lat, y4 = p4.lng;
                    
                    // Line segment intersection formula
                    const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                    
                    // Check if lines are parallel
                    if (denominator === 0) return null;
                    
                    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
                    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
                    
                    // Check if intersection is within both line segments
                    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) return null;
                    
                    // Calculate intersection point
                    const x = x1 + ua * (x2 - x1);
                    const y = y1 + ua * (y2 - y1);
                    
                    return L.latLng(x, y);
                }

                function getFlowDirection(line, point) {
                    // Get line points
                    const points = line.getLatLngs();
                    
                    // Find segment closest to the point
                    let closestSegmentIndex = -1;
                    let minDistance = Infinity;
                    
                    for (let i = 0; i < points.length - 1; i++) {
                        const projectedPoint = projectPointOnLine(point, points[i], points[i+1]);
                        const distance = map.distance(point, projectedPoint);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestSegmentIndex = i;
                        }
                    }
                    
                    if (closestSegmentIndex === -1) return { lat: 0, lng: 0 };
                    
                    // Get direction vector of the segment
                    const start = points[closestSegmentIndex];
                    const end = points[closestSegmentIndex + 1];
                    
                    // Calculate direction vector
                    const direction = {
                        lat: end.lat - start.lat,
                        lng: end.lng - start.lng
                    };
                    
                    // Normalize
                    const length = Math.sqrt(direction.lat * direction.lat + direction.lng * direction.lng);
                    
                    return {
                        lat: direction.lat / length,
                        lng: direction.lng / length
                    };
                }

                function clearAll() {
                    // Clear all layers
                    streets.clearLayers();
                    curbs.clearLayers();
                    catchBasins.clearLayers();
                    highPoints.clearLayers();
                    waterTraps.clearLayers();
                    
                    // Cancel any active drawing
                    cancelDrawing();
                    
                    showToast('All items cleared');
                }

                function saveProject() {
                    // Collect all data
                    const projectData = {
                        center: map.getCenter(),
                        zoom: map.getZoom(),
                        streets: [],
                        curbs: [],
                        catchBasins: [],
                        highPoints: []
                    };
                    
                    // Collect street lines
                    streets.eachLayer(function(layer) {
                        projectData.streets.push({
                            points: layer.getLatLngs(),
                            pitchValue: layer.options.pitchValue
                        });
                    });
                    
                    // Collect curb lines
                    curbs.eachLayer(function(layer) {
                        projectData.curbs.push({
                            points: layer.getLatLngs(),
                            pitchValue: layer.options.pitchValue
                        });
                    });
                    
                    // Collect catch basins
                    catchBasins.eachLayer(function(layer) {
                        projectData.catchBasins.push({
                            point: layer.getLatLng()
                        });
                    });
                    
                    // Collect high points
                    highPoints.eachLayer(function(layer) {
                        projectData.highPoints.push({
                            point: layer.getLatLng()
                        });
                    });
                    
                    // Convert to JSON
                    const jsonData = JSON.stringify(projectData);
                    
                    // Create and trigger download
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'flowmaster-project.json';
                    a.click();
                    
                    showToast('Project saved');
                }

                function loadProject() {
                    // Create file input
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = '.json';
                    
                    // Listen for file selection
                    input.onchange = function(e) {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                // Parse project data
                                const projectData = JSON.parse(e.target.result);
                                
                                // Clear current data
                                clearAll();
                                
                                // Set map view
                                if (projectData.center && projectData.zoom) {
                                    map.setView([projectData.center.lat, projectData.center.lng], projectData.zoom);
                                }
                                
                                // Load street lines
                                if (projectData.streets && Array.isArray(projectData.streets)) {
                                    projectData.streets.forEach(item => {
                                        addPitchLine(item.points, item.pitchValue, 'street');
                                    });
                                }
                                
                                // Load curb lines
                                if (projectData.curbs && Array.isArray(projectData.curbs)) {
                                    projectData.curbs.forEach(item => {
                                        addPitchLine(item.points, item.pitchValue, 'curb');
                                    });
                                }
                                
                                // Load catch basins
                                if (projectData.catchBasins && Array.isArray(projectData.catchBasins)) {
                                    projectData.catchBasins.forEach(item => {
                                        addCatchBasin(L.latLng(item.point.lat, item.point.lng));
                                    });
                                }
                                
                                // Load high points
                                if (projectData.highPoints && Array.isArray(projectData.highPoints)) {
                                    projectData.highPoints.forEach(item => {
                                        addHighPoint(L.latLng(item.point.lat, item.point.lng));
                                    });
                                }
                                
                                // Check for water traps
                                checkWaterTraps();
                                
                                showToast('Project loaded successfully');
                                
                            } catch (error) {
                                console.error('Error loading project:', error);
                                showToast('Error loading project file');
                            }
                        };
                        reader.readAsText(file);
                    };
                    
                    // Trigger file selection
                    input.click();
                }

                function showPitchDialog() {
                    // Set initial value
                    document.getElementById('pitch-value').value = appState.lastPitchValue;
                    
                    // Show dialog
                    document.getElementById('pitch-dialog').style.display = 'flex';
                }

                function showConfirmDialog(message, callback) {
                    // Set message
                    document.getElementById('confirm-message').textContent = message;
                    
                    // Set callback
                    appState.confirmAction = callback;
                    
                    // Show dialog
                    document.getElementById('confirm-dialog').style.display = 'flex';
                }

                function showToast(message) {
                    const toast = document.getElementById('toast');
                    document.getElementById('toast-message').textContent = message;
                    
                    // Show toast
                    toast.classList.add('visible');
                    
                    // Hide after 3 seconds
                    setTimeout(() => {
                        toast.classList.remove('visible');
                    }, 3000);
                }

                function showLoading(message) {
                    document.querySelector('.loading-text').textContent = message;
                    document.querySelector('.loading-overlay').style.display = 'flex';
                    appState.loading = true;
                }

                function hideLoading() {
                    document.querySelector('.loading-overlay').style.display = 'none';
                    appState.loading = false;
                }

                function updateStatus(message) {
                    document.querySelector('.status-text').textContent = message;
                }

                function showHelp() {
                    const helpSteps = [
                        {
                            target: document.getElementById('street-btn'),
                            title: 'Draw Street Pitch Lines',
                            text: 'Tap to draw blue pitch lines for streets. The water flows along the direction of the arrow.',
                            position: 'top'
                        },
                        {
                            target: document.getElementById('curb-btn'),
                            title: 'Draw Curb Pitch Lines',
                            text: 'Tap to draw yellow pitch lines for curbs. These typically run along the sides of streets.',
                            position: 'top'
                        },
                        {
                            target: document.getElementById('locate-btn'),
                            title: 'Center on Your Location',
                            text: 'Tap to go to your current GPS location on the site.',
                            position: 'top'
                        },
                        {
                            target: document.getElementById('catchbasin-btn'),
                            title: 'Add Catch Basins',
                            text: 'Tap to place catch basins where water should drain.',
                            position: 'top'
                        },
                        {
                            target: document.getElementById('highpoint-btn'),
                            title: 'Add High Points',
                            text: 'Tap to mark high points where water will flow away from.',
                            position: 'top'
                        },
                        {
                            target: document.getElementById('clear-btn'),
                            title: 'Clear All Items',
                            text: 'Tap to clear everything from the map and start fresh.',
                            position: 'left'
                        },
                        {
                            target: document.getElementById('save-btn'),
                            title: 'Save Project',
                            text: 'Tap to save your current drainage plan for later use.',
                            position: 'left'
                        }
                    ];
                    
                    const helpOverlay = document.getElementById('help-overlay');
                    helpOverlay.innerHTML = '';
                    helpOverlay.classList.add('visible');
                    
                    // Create first help card
                    createHelpCard(helpSteps, 0);
                }

                function createHelpCard(steps, index) {
                    if (index >= steps.length) {
                        document.getElementById('help-overlay').classList.remove('visible');
                        return;
                    }
                    
                    const step = steps[index];
                    const target = step.target;
                    const targetRect = target.getBoundingClientRect();
                    
                    // Create card
                    const card = document.createElement('div');
                    card.className = 'help-card';
                    
                    // Position card based on target position
                    let cardLeft, cardTop, arrowLeft, arrowTop, arrowStyle;
                    
                    if (step.position === 'top') {
                        cardLeft = targetRect.left + (targetRect.width / 2) - 140;
                        cardTop = targetRect.top - 150;
                        arrowLeft = 140;
                        arrowTop = 145;
                        arrowStyle = 'bottom: -10px; left: 140px;';
                    } else if (step.position === 'bottom') {
                        cardLeft = targetRect.left + (targetRect.width / 2) - 140;
                        cardTop = targetRect.bottom + 20;
                        arrowLeft = 140;
                        arrowTop = -10;
                        arrowStyle = 'top: -10px; left: 140px;';
                    } else if (step.position === 'left') {
                        cardLeft = targetRect.left - 300;
                        cardTop = targetRect.top + (targetRect.height / 2) - 75;
                        arrowLeft = 290;
                        arrowTop = 75;
                        arrowStyle = 'right: -10px; top: 75px;';
                    } else {
                        cardLeft = targetRect.right + 20;
                        cardTop = targetRect.top + (targetRect.height / 2) - 75;
                        arrowLeft = -10;
                        arrowTop = 75;
                        arrowStyle = 'left: -10px; top: 75px;';
                    }
                    
                    // Adjust position if card would go off screen
                    if (cardLeft < 10) cardLeft = 10;
                    if (cardLeft + 280 > window.innerWidth) cardLeft = window.innerWidth - 290;
                    if (cardTop < 10) cardTop = 10;
                    if (cardTop + 150 > window.innerHeight) cardTop = window.innerHeight - 160;
                    
                    card.style.left = `${cardLeft}px`;
                    card.style.top = `${cardTop}px`;
                    
                    // Card content
                    card.innerHTML = `
                        <div class="help-arrow" style="${arrowStyle}"></div>
                        <div class="help-title">${step.title}</div>
                        <div class="help-text">${step.text}</div>
                        <div class="help-next">
                            <button class="button button-primary" id="help-next-btn">
                                ${index < steps.length - 1 ? 'Next' : 'Done'}
                            </button>
                        </div>
                    `;
                    
                    document.getElementById('help-overlay').appendChild(card);
                    
                    // Next button event
                    document.getElementById('help-next-btn').addEventListener('click', function() {
                        createHelpCard(steps, index + 1);
                    });
                }

                function initEventHandlers() {
                    // Action buttons
                    document.getElementById('street-btn').addEventListener('click', function() {
                        setDrawingMode('street');
                    });
                    
                    document.getElementById('curb-btn').addEventListener('click', function() {
                        setDrawingMode('curb');
                    });
                    
                    document.getElementById('locate-btn').addEventListener('click', function() {
                        if (userLocation) {
                            map.setView(userLocation, 19);
                            showToast('Centered on your location');
                        } else {
                            getUserLocation();
                        }
                    });
                    
                    document.getElementById('catchbasin-btn').addEventListener('click', function() {
                        setDrawingMode('catchbasin');
                    });
                    
                    document.getElementById('highpoint-btn').addEventListener('click', function() {
                        setDrawingMode('highpoint');
                    });
                    
                    // Map control buttons
                    document.getElementById('zoom-in-btn').addEventListener('click', function() {
                        map.zoomIn();
                    });
                    
                    document.getElementById('zoom-out-btn').addEventListener('click', function() {
                        map.zoomOut();
                    });
                    
                    document.getElementById('help-btn').addEventListener('click', function() {
                        showHelp();
                    });
                    
                    document.getElementById('save-btn').addEventListener('click', function() {
                        saveProject();
                    });
                    
                    document.getElementById('clear-btn').addEventListener('click', function() {
                        showConfirmDialog('Are you sure you want to clear all items?', clearAll);
                    });
                    
                    // Dialog buttons
                    document.getElementById('save-pitch-btn').addEventListener('click', function() {
                        const pitchValue = parseFloat(document.getElementById('pitch-value').value);
                        
                        if (isNaN(pitchValue) || pitchValue <= 0 || pitchValue > 20) {
                            showToast('Please enter a valid pitch percentage (0.1-20%)');
                            return;
                        }
                        
                        // Save for future use
                        appState.lastPitchValue = pitchValue;
                        
                        // Hide dialog
                        document.getElementById('pitch-dialog').style.display = 'none';
                        
                        // Add line with pitch value
                        if (pendingLine) {
                            addPitchLine(pendingLine.points, pitchValue, pendingLine.type);
                            pendingLine = null;
                        }
                    });
                    
                    document.getElementById('cancel-pitch-btn').addEventListener('click', function() {
                        // Hide dialog
                        document.getElementById('pitch-dialog').style.display = 'none';
                        
                        // Cancel line
                        pendingLine = null;
                        showToast('Line cancelled');
                    });
                    
                    document.getElementById('confirm-btn').addEventListener('click', function() {
                        // Hide dialog
                        document.getElementById('confirm-dialog').style.display = 'none';
                        
                        // Execute callback
                        if (typeof appState.confirmAction === 'function') {
                            appState.confirmAction();
                            appState.confirmAction = null;
                        }
                    });
                    
                    document.getElementById('cancel-confirm-btn').addEventListener('click', function() {
                        // Hide dialog
                        document.getElementById('confirm-dialog').style.display = 'none';
                        
                        // Clear callback
                        appState.confirmAction = null;
                    });
                    
                    // Close dialogs when clicking outside
                    document.getElementById('pitch-dialog').addEventListener('click', function(e) {
                        if (e.target === this) {
                            this.style.display = 'none';
                            pendingLine = null;
                        }
                    });
                    
                    document.getElementById('confirm-dialog').addEventListener('click', function(e) {
                        if (e.target === this) {
                            this.style.display = 'none';
                            appState.confirmAction = null;
                        }
                    });
                    
                    // Help overlay click
                    document.getElementById('help-overlay').addEventListener('click', function(e) {
                        if (e.target === this) {
                            this.classList.remove('visible');
                        }
                    });
                    
                    // Key events
                    document.addEventListener('keydown', function(e) {
                        // Escape key
                        if (e.key === 'Escape') {
                            // Cancel drawing
                            if (drawingLine) {
                                cancelDrawing();
                            }
                            
                            // Hide dialogs
                            document.getElementById('pitch-dialog').style.display = 'none';
                            document.getElementById('confirm-dialog').style.display = 'none';
                            document.getElementById('help-overlay').classList.remove('visible');
                            
                            pendingLine = null;
                            appState.confirmAction = null;
                        }
                    });
                }

                function setDrawingMode(mode) {
                    // Reset active state on all buttons
                    document.querySelectorAll('.action-button').forEach(button => {
                        button.classList.remove('active');
                    });
                    
                    // Cancel any current drawing
                    cancelDrawing();
                    
                    // Set mode
                    drawingMode = mode;
                    
                    // Update UI
                    if (mode === 'street') {
                        document.getElementById('street-btn').classList.add('active');
                        showToast('Drawing street pitch - tap along street guides');
                    } else if (mode === 'curb') {
                        document.getElementById('curb-btn').classList.add('active');
                        showToast('Drawing curb pitch - tap along curb guides');
                    } else if (mode === 'catchbasin') {
                        document.getElementById('catchbasin-btn').classList.add('active');
                        showToast('Adding catch basins - tap to place');
                    } else if (mode === 'highpoint') {
                        document.getElementById('highpoint-btn').classList.add('active');
                        showToast('Adding high points - tap to place');
                    }
                }
            }
        });
    </script>
</body>
</html>
