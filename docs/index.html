<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC Pocket 2.0</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Leaflet Heat -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
    
    <style>
        :root {
            --primary-color: #0075ff;
            --secondary-color: #ffcc00;
            --accent-color: #ff3e30;
            --success-color: #00c853;
            --dark-color: #263238;
            --light-color: #f5f5f5;
            --text-color: #212121;
            --gray-color: #757575;
            --panel-bg: rgba(255, 255, 255, 0.97);
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            --rounded: 12px;
            
            /* Utility colors */
            --water-color: #2196f3;
            --gas-color: #ff9800;
            --electric-color: #ffeb3b;
            --sewer-color: #795548;
            --telecom-color: #9c27b0;
            
            /* Mode colors */
            --drainage-primary: #0099cc;
            --drainage-secondary: #66ccff;
            --utility-primary: #7e57c2;
            --utility-secondary: #b39ddb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            color: var(--text-color);
            background-color: var(--light-color);
            overflow-x: hidden;
            overflow-y: auto;
        }

        .app-container {
            position: relative;
            height: 100dvh;
            width: 100vw;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        /* Mode Selector */
        .mode-selector {
            position: absolute;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            background-color: var(--panel-bg);
            border-radius: 24px;
            box-shadow: var(--shadow);
        }

        .mode-button {
            padding: 10px 20px;
            border: none;
            background: none;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 24px;
        }

        .mode-button.active.drainage {
            background-color: var(--drainage-primary);
            color: white;
        }

        .mode-button.active.utility {
            background-color: var(--utility-primary);
            color: white;
        }

        /* Top Action Bar */
        .action-bar {
            position: absolute;
            top: 12px;
            left: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 4px;
            pointer-events: none;
        }

        .action-group {
            display: flex;
            gap: 8px;
            pointer-events: auto;
        }

        .action-button {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
        }

        .action-button i {
            font-size: 20px;
        }

        .action-button:active {
            transform: scale(0.95);
        }

        .action-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        /* Drawing Toolbar - Drainage Mode */
        .drainage-toolbar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 8px;
            background-color: var(--panel-bg);
            border-radius: 24px;
            padding: 6px;
            box-shadow: var(--shadow);
            max-width: 95%;
            display: none;
        }

        .drainage-toolbar.visible {
            display: flex;
        }

        /* Drawing Toolbar - Utility Mode */
        .utility-toolbar {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 8px;
            background-color: var(--panel-bg);
            border-radius: 24px;
            padding: 6px;
            box-shadow: var(--shadow);
            max-width: 95%;
            display: none;
        }

        .utility-toolbar.visible {
            display: flex;
        }

        .tool-button {
            min-width: 48px;
            height: 48px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            border: 2px solid transparent;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            color: var(--dark-color);
            flex-shrink: 0;
        }

        .tool-button i {
            font-size: 20px;
        }

        .tool-button:active {
            transform: scale(0.95);
        }

        .tool-button.active {
            border-color: white;
        }

        .tool-button.drainage-active {
            background-color: var(--drainage-primary);
            color: white;
        }

        .tool-button.utility-active {
            background-color: var(--utility-primary);
            color: white;
        }

        /* Always visible controls */
        .always-visible-controls {
            position: fixed;
            bottom: 100px;
            right: 16px;
            z-index: 1500;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }
        
        .control-button {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background-color: var(--panel-bg);
            box-shadow: var(--shadow);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 18px;
            color: var(--dark-color);
            touch-action: none;
        }
        
        .control-button:active {
            transform: scale(0.95);
        }

        /* Menu Panel */
        .menu-panel {
            position: absolute;
            top: 70px;
            right: 10px;
            z-index: 1000;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 12px;
            box-shadow: var(--shadow);
            min-width: 280px;
            transform: translateX(290px);
            transition: transform 0.3s ease;
        }

        .menu-panel.visible {
            transform: translateX(0);
        }

        .menu-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .menu-panel-title {
            font-weight: 600;
            font-size: 16px;
        }

        .menu-panel-close {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--dark-color);
            font-size: 18px;
        }

        .menu-section {
            margin-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            padding-bottom: 16px;
        }

        .menu-section:last-child {
            margin-bottom: 0;
            border-bottom: none;
            padding-bottom: 0;
        }

        .menu-section-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
            color: var(--primary-color);
        }

        .menu-section-title.drainage {
            color: var(--drainage-primary);
        }

        .menu-section-title.utility {
            color: var(--utility-primary);
        }

        .layer-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .layer-toggle:last-child {
            margin-bottom: 0;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 42px;
            height: 22px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider.drainage {
            background-color: var(--drainage-primary);
        }

        input:checked + .toggle-slider.utility {
            background-color: var(--utility-primary);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .utility-filter-controls {
            margin-top: 15px;
        }

        .filter-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--gray-color);
        }

        .filter-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .filter-button {
            padding: 6px 12px;
            border: none;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            background-color: var(--light-color);
            color: var(--dark-color);
            transition: all 0.2s ease;
        }

        .filter-button.active {
            background-color: var(--utility-primary);
            color: white;
        }

        .filter-button.water {
            border: 1px solid var(--water-color);
        }
        
        .filter-button.gas {
            border: 1px solid var(--gas-color);
        }
        
        .filter-button.electric {
            border: 1px solid var(--electric-color);
        }
        
        .filter-button.sewer {
            border: 1px solid var(--sewer-color);
        }
        
        .filter-button.telecom {
            border: 1px solid var(--telecom-color);
        }

        .filter-button.water.active {
            background-color: var(--water-color);
        }
        
        .filter-button.gas.active {
            background-color: var(--gas-color);
        }
        
        .filter-button.electric.active {
            background-color: var(--electric-color);
            color: var(--dark-color);
        }
        
        .filter-button.sewer.active {
            background-color: var(--sewer-color);
        }
        
        .filter-button.telecom.active {
            background-color: var(--telecom-color);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-container {
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            width: 90%;
            max-width: 380px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .modal-header.drainage {
            background-color: var(--drainage-primary);
            color: white;
        }

        .modal-header.utility {
            background-color: var(--utility-primary);
            color: white;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: white;
        }

        .modal-content {
            padding: 20px;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 0 20px 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--rounded);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.cancel {
            background-color: var(--light-color);
            color: var(--dark-color);
        }

        .modal-btn.confirm.drainage {
            background-color: var(--drainage-primary);
            color: white;
        }

        .modal-btn.confirm.utility {
            background-color: var(--utility-primary);
            color: white;
        }

        /* Form Elements */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .form-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            background-color: white;
        }

        .form-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .option-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 20px;
            background: white;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option-btn.selected.drainage {
            border-color: var(--drainage-primary);
            background-color: var(--drainage-primary);
            color: white;
        }

        .option-btn.selected.utility {
            border-color: var(--utility-primary);
            background-color: var(--utility-primary);
            color: white;
        }

        /* Pitch Adjustment */
        .pitch-input-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .pitch-adjust-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--light-color);
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .pitch-adjust-btn:active {
            transform: scale(0.95);
        }

        .pitch-value {
            font-size: 24px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--dark-color);
            color: white;
            border-radius: var(--rounded);
            padding: 12px 20px;
            z-index: 2000;
            box-shadow: var(--shadow);
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            pointer-events: none;
            max-width: 90%;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        .notification.drainage {
            background-color: var(--drainage-primary);
        }

        .notification.utility {
            background-color: var(--utility-primary);
        }

        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--panel-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 999;
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-bar i {
            color: var(--primary-color);
            flex-shrink: 0;
        }

        .status-bar.drainage i {
            color: var(--drainage-primary);
        }

        .status-bar.utility i {
            color: var(--utility-primary);
        }

        /* Map Features */
        .drainage-heat-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            padding: 10px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            z-index: 999;
            display: none;
        }

        .drainage-heat-legend.visible {
            display: block;
        }

        .legend-title {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .legend-gradient {
            height: 10px;
            width: 100%;
            background: linear-gradient(to right, green, yellow, red);
            margin-bottom: 5px;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        /* Curb Styling */
        .curb-guide {
            stroke: rgba(255, 204, 0, 0.3);
            stroke-width: 6;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: auto;
        }

        .curb-line {
            stroke: var(--secondary-color);
            stroke-width: 5;
            stroke-dasharray: none;
        }

        .curb-gap {
            stroke: rgba(66, 165, 245, 0.8);
            stroke-width: 6;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            animation: pulse 2s infinite;
            pointer-events: auto;
        }

        @keyframes pulse {
            0% { stroke-opacity: 0.4; }
            50% { stroke-opacity: 0.8; }
            100% { stroke-opacity: 0.4; }
        }

        .catch-basin-icon {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            background-color: var(--drainage-primary);
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
        }

        /* Utility Styling */
        .utility-marker {
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 2px solid white;
            position: relative;
        }

        .utility-marker::after {
            content: attr(data-type);
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .utility-marker.main::before {
            content: "M";
            position: absolute;
            top: -3px;
            right: -3px;
            background-color: white;
            color: var(--dark-color);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .utility-line {
            stroke-width: 4;
            fill: none;
        }

        .utility-line.water {
            stroke: var(--water-color);
        }

        .utility-line.gas {
            stroke: var(--gas-color);
        }

        .utility-line.electric {
            stroke: var(--electric-color);
        }

        .utility-line.sewer {
            stroke: var(--sewer-color);
        }

        .utility-line.telecom {
            stroke: var(--telecom-color);
        }

        .utility-line.main {
            stroke-width: 5;
        }

        .utility-line.service {
            stroke-width: 3;
            stroke-dasharray: 5,3;
        }

        .utility-temp-line {
            stroke-width: 4;
            stroke-dasharray: 5,3;
            fill: none;
            stroke-opacity: 0.7;
        }

        /* Utility Info Card */
        .utility-info-card {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            padding: 15px;
            box-shadow: var(--shadow);
            z-index: 1500;
            width: 280px;
            max-width: 90vw;
            display: none;
        }
        
        .utility-info-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 8px;
        }
        
        .utility-info-title {
            font-weight: 600;
            font-size: 16px;
        }
        
        .utility-info-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
        }
        
        .utility-info-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .utility-info-row {
            display: flex;
            justify-content: space-between;
        }
        
        .utility-info-label {
            font-weight: 500;
            color: var(--gray-color);
        }
        
        .utility-info-value {
            font-weight: 500;
        }
        
        .utility-info-image {
            width: 100%;
            margin-top: 10px;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .utility-info-image img {
            width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
        }

        /* Context Menu */
        .context-menu {
            position: absolute;
            background-color: var(--panel-bg);
            border-radius: var(--rounded);
            box-shadow: var(--shadow);
            padding: 8px 0;
            z-index: 1500;
            min-width: 180px;
            display: none;
        }

        .context-menu-item {
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .context-menu-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .context-menu-item i {
            font-size: 16px;
            width: 20px;
            text-align: center;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid var(--light-color);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            animation: spin 1s ease-in-out infinite;
        }

        .spinner.drainage {
            border-top-color: var(--drainage-primary);
        }

        .spinner.utility {
            border-top-color: var(--utility-primary);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Splash Screen */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--drainage-primary), var(--utility-primary));
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            flex-direction: column;
            color: white;
            transition: opacity 0.5s ease;
        }

        .splash-logo {
            font-size: 56px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .splash-logo-icon {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .splash-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        /* iOS safe area support */
        @supports(padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: env(safe-area-inset-bottom);
            }
            .drainage-toolbar, .utility-toolbar {
                bottom: calc(16px + env(safe-area-inset-bottom));
            }
        }

        /* Style adjustments for smaller screens */
        @media (max-width: 480px) {
            .drainage-toolbar, .utility-toolbar {
                padding: 4px;
                gap: 6px;
            }

            .tool-button {
                width: 44px;
                height: 44px;
            }

            .tool-button i {
                font-size: 18px;
            }

            .action-button {
                width: 40px;
                height: 40px;
            }

            .action-button i {
                font-size: 16px;
            }

            .mode-button {
                padding: 8px 16px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen">
        <div class="splash-logo">
            <div class="splash-logo-icon">
                <i class="fas fa-water"></i>
            </div>
        </div>
        <div class="splash-title">CAC Pocket 2.0</div>
        <div class="splash-subtitle">NYC Drainage & Utility Planning Tool</div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- Map Element -->
        <div id="map"></div>
        
        <!-- Mode Selector -->
        <div class="mode-selector">
            <button id="drainage-mode-btn" class="mode-button drainage active">
                <i class="fas fa-water"></i> Drainage Mode
            </button>
            <button id="utility-mode-btn" class="mode-button utility">
                <i class="fas fa-tools"></i> Utility Mode
            </button>
        </div>
        
        <!-- Always visible controls -->
        <div class="always-visible-controls">
            <button class="control-button" id="zoom-in-btn" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="control-button" id="zoom-out-btn" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="control-button" id="cancel-action-btn" title="Cancel Action" style="display: none;">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <!-- Top Action Bar -->
        <div class="action-bar">
            <div class="action-group">
                <button class="action-button" id="locate-btn" title="My Location">
                    <i class="fas fa-crosshairs"></i>
                </button>
                <button class="action-button" id="undo-btn" title="Undo">
                    <i class="fas fa-undo"></i>
                </button>
            </div>
            <div class="action-group">
                <button class="action-button" id="menu-btn" title="Menu">
                    <i class="fas fa-bars"></i>
                </button>
                <button class="action-button" id="help-btn" title="Help">
                    <i class="fas fa-question"></i>
                </button>
            </div>
        </div>

        <!-- Menu Panel -->
        <div class="menu-panel" id="menu-panel">
            <div class="menu-panel-header">
                <div class="menu-panel-title">Settings</div>
                <button class="menu-panel-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- Drainage Mode Layers -->
            <div class="menu-section drainage-section">
                <div class="menu-section-title drainage">Drainage Layers</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-water" style="color: var(--drainage-primary);"></i>
                        Drainage Heatmap
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="heatmap-toggle" checked>
                        <span class="toggle-slider drainage"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-grip-lines" style="color: var(--secondary-color);"></i>
                        Curb Pitches
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="curb-toggle" checked>
                        <span class="toggle-slider drainage"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-drain" style="color: var(--drainage-primary);"></i>
                        Catch Basins
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="basin-toggle" checked>
                        <span class="toggle-slider drainage"></span>
                    </label>
                </div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-route" style="color: var(--drainage-secondary);"></i>
                        Curb Guides
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="guide-toggle" checked>
                        <span class="toggle-slider drainage"></span>
                    </label>
                </div>
            </div>
            
            <!-- Utility Mode Layers -->
            <div class="menu-section utility-section" style="display: none;">
                <div class="menu-section-title utility">Utility Filters</div>
                <div class="utility-filter-controls">
                    <div class="filter-title">Utility Types</div>
                    <div class="filter-buttons" id="utility-type-filters">
                        <button class="filter-button water active" data-type="water">Water</button>
                        <button class="filter-button gas active" data-type="gas">Gas</button>
                        <button class="filter-button electric active" data-type="electric">Electric</button>
                        <button class="filter-button sewer active" data-type="sewer">Sewer</button>
                        <button class="filter-button telecom active" data-type="telecom">Telecom</button>
                    </div>
                    
                    <div class="filter-title">Category</div>
                    <div class="filter-buttons" id="utility-category-filters">
                        <button class="filter-button utility-active active" data-category="main">Mains</button>
                        <button class="filter-button utility-active active" data-category="service">Services</button>
                    </div>
                </div>
            </div>
            
            <!-- Common Options -->
            <div class="menu-section">
                <div class="menu-section-title" id="options-title">Options</div>
                <div class="layer-toggle">
                    <div class="toggle-label">
                        <i class="fas fa-magnet" style="color: var(--primary-color);"></i>
                        Snap to Features
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="snap-toggle" checked>
                        <span class="toggle-slider" id="snap-slider"></span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Drainage Mode Toolbar -->
        <div class="drainage-toolbar" id="drainage-toolbar">
            <button class="tool-button" id="curb-pitch-tool" title="Draw Curb Pitch">
                <i class="fas fa-grip-lines"></i>
            </button>
            <button class="tool-button" id="catch-basin-tool" title="Add Catch Basin">
                <i class="fas fa-water"></i>
            </button>
            <button class="tool-button" id="clear-drainage-tool" title="Clear All Drainage">
                <i class="fas fa-trash"></i>
            </button>
        </div>

        <!-- Utility Mode Toolbar -->
        <div class="utility-toolbar" id="utility-toolbar">
            <button class="tool-button" id="utility-found-tool" title="Utility Found">
                <i class="fas fa-exclamation-circle"></i>
            </button>
            <button class="tool-button" id="mapping-utility-tool" title="Map Utility">
                <i class="fas fa-route"></i>
            </button>
            <button class="tool-button" id="clear-utility-tool" title="Clear All Utilities">
                <i class="fas fa-trash"></i>
            </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar drainage" id="status-bar">
            <i class="fas fa-info-circle"></i>
            <span id="status-text">Select a tool to begin</span>
        </div>

        <!-- Drainage Heat Legend -->
        <div class="drainage-heat-legend" id="drainage-heat-legend">
            <div class="legend-title">Drainage Risk</div>
            <div class="legend-gradient"></div>
            <div class="legend-labels">
                <span>Low</span>
                <span>Medium</span>
                <span>High</span>
            </div>
        </div>

        <!-- MODALS -->
        
        <!-- Pitch Input Modal -->
        <div class="modal-overlay" id="pitch-modal">
            <div class="modal-container">
                <div class="modal-header drainage">
                    <div class="modal-title">Set Pitch Percentage</div>
                    <button class="modal-close" id="close-pitch-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-content">
                    <div class="pitch-input-container">
                        <button class="pitch-adjust-btn" id="decrease-pitch">
                            <i class="fas fa-minus"></i>
                        </button>
                        <div class="pitch-value" id="pitch-value">2.0%</div>
                        <button class="pitch-adjust-btn" id="increase-pitch">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn cancel" id="cancel-pitch">Cancel</button>
                    <button class="modal-btn confirm drainage" id="confirm-pitch">Confirm</button>
                </div>
            </div>
        </div>
        
        <!-- Gap Treatment Modal -->
        <div class="modal-overlay" id="gap-treatment-modal">
            <div class="modal-container">
                <div class="modal-header drainage">
                    <div class="modal-title">Curb Gap Treatment</div>
                    <button class="modal-close" id="close-gap-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-content">
                    <div class="form-group">
                        <div class="form-label">Choose how to treat this gap:</div>
                        <div class="form-options" id="gap-options">
                            <button class="option-btn drainage selected" data-option="pitch">Add Pitch</button>
                            <button class="option-btn" data-option="transition">Transition</button>
                            <button class="option-btn" data-option="highpoint">High Point</button>
                        </div>
                    </div>
                    
                    <!-- Pitch Option Controls -->
                    <div id="pitch-option-controls">
                        <div class="form-group">
                            <div class="form-label">Pitch Direction:</div>
                            <div class="form-options">
                                <button class="option-btn drainage selected" data-direction="forward">
                                    <i class="fas fa-arrow-right"></i> Forward
                                </button>
                                <button class="option-btn" data-direction="backward">
                                    <i class="fas fa-arrow-left"></i> Backward
                                </button>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="form-label">Pitch Percentage:</div>
                            <div class="pitch-input-container">
                                <button class="pitch-adjust-btn" id="decrease-gap-pitch">
                                    <i class="fas fa-minus"></i>
                                </button>
                                <div class="pitch-value" id="gap-pitch-value">2.0%</div>
                                <button class="pitch-adjust-btn" id="increase-gap-pitch">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn cancel" id="cancel-gap-treatment">Cancel</button>
                    <button class="modal-btn confirm drainage" id="confirm-gap-treatment">Apply</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Found Modal -->
        <div class="modal-overlay" id="utility-found-modal">
            <div class="modal-container">
                <div class="modal-header utility">
                    <div class="modal-title">Utility Found</div>
                    <button class="modal-close" id="close-utility-found-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-content">
                    <div class="form-group">
                        <div class="form-label">Rotate Line:</div>
                        <div class="pitch-input-container">
                            <button class="pitch-adjust-btn" id="rotate-left">
                                <i class="fas fa-undo"></i>
                            </button>
                            <div style="display: flex; justify-content: center; align-items: center;">
                                <i class="fas fa-arrow-up" style="font-size: 24px; transform: rotate(0deg);" id="direction-indicator"></i>
                            </div>
                            <button class="pitch-adjust-btn" id="rotate-right">
                                <i class="fas fa-redo"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn cancel" id="cancel-utility-direction">Cancel</button>
                    <button class="modal-btn confirm utility" id="confirm-utility-direction">Next</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Details Modal -->
        <div class="modal-overlay" id="utility-details-modal">
            <div class="modal-container">
                <div class="modal-header utility">
                    <div class="modal-title">Utility Details</div>
                    <button class="modal-close" id="close-utility-details-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-content">
                    <div class="form-group">
                        <div class="form-label">Utility Type:</div>
                        <select class="form-select" id="utility-type">
                            <option value="water">Water</option>
                            <option value="gas">Gas</option>
                            <option value="electric">Electric</option>
                            <option value="sewer">Sewer</option>
                            <option value="telecom">Telecom</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div class="form-label">Category:</div>
                        <div class="form-options">
                            <button class="option-btn utility selected" data-category="main">Main</button>
                            <button class="option-btn" data-category="service">Service</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="form-label">Size (inches):</div>
                        <input type="number" class="form-input" id="utility-size" value="4">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Depth (feet):</div>
                        <input type="number" class="form-input" id="utility-depth" value="3">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Photo/Video (optional):</div>
                        <input type="file" id="utility-media" accept="image/*,video/*">
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn cancel" id="cancel-utility-details">Cancel</button>
                    <button class="modal-btn confirm utility" id="confirm-utility-details">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Connection Modal -->
        <div class="modal-overlay" id="utility-connection-modal">
            <div class="modal-container">
                <div class="modal-header utility">
                    <div class="modal-title">Connect Utilities</div>
                    <button class="modal-close" id="close-connection-modal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-content">
                    <div class="form-group">
                        <div class="form-label">How would you like to connect these utilities?</div>
                        <div class="form-options" id="connection-options">
                            <button class="option-btn utility selected" data-option="continuation">Continuation</button>
                            <button class="option-btn" data-option="offset">Offset</button>
                            <button class="option-btn" data-option="separate">Separate</button>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn cancel" id="cancel-connection">Cancel</button>
                    <button class="modal-btn confirm utility" id="confirm-connection">Apply</button>
                </div>
            </div>
        </div>
        
        <!-- Utility Info Card -->
        <div class="utility-info-card" id="utility-info-card">
            <div class="utility-info-header">
                <div class="utility-info-title">Utility Information</div>
                <button class="utility-info-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="utility-info-content">
                <div class="utility-info-row">
                    <div class="utility-info-label">Type:</div>
                    <div class="utility-info-value" id="info-type">Water</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Category:</div>
                    <div class="utility-info-value" id="info-category">Main</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Size:</div>
                    <div class="utility-info-value" id="info-size">4 inches</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Depth:</div>
                    <div class="utility-info-value" id="info-depth">3 feet</div>
                </div>
                <div class="utility-info-row">
                    <div class="utility-info-label">Direction:</div>
                    <div class="utility-info-value" id="info-direction">North</div>
                </div>
                <div class="utility-info-image" id="info-media-container">
                    <!-- Media will be inserted here if available -->
                </div>
            </div>
        </div>
        
        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <!-- Menu items will be dynamically added based on context -->
        </div>

        <!-- Notification -->
        <div class="notification drainage" id="notification">
            <i class="fas fa-info-circle"></i>
            <span id="notification-text">Notification message</span>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay">
            <div class="spinner drainage"></div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Wait for splash screen
        setTimeout(() => {
            document.querySelector('.splash-screen').style.opacity = 0;
            setTimeout(() => {
                document.querySelector('.splash-screen').style.display = 'none';
                initApp();
            }, 500);
        }, 2000);

        function initApp() {
            // Global variables
            let map, userMarker, currentPosition;
            let activeMode = 'drainage'; // Default mode
            let activeTool = null;
            let isDrawing = false;
            let tempLine = null;
            let drawingPoints = [];
            let drawingSegments = [];
            let undoStack = [];
            let selectedElement = null;
            let snapEnabled = true;
            let nearestValidPoint = null;
            let pitchPercent = 2.0;
            let selectedGap = null;
            let utilityAngle = 0;
            let tempUtilityMarker = null;
            let tempUtilityLine = null;
            let utilityPresets = {
                type: 'water',
                category: 'main',
                size: 4,
                depth: 3
            };
            let selectedUtility = null;
            let connectionStartUtility = null;
            let gapPitchPercent = 2.0;
            let gapPitchDirection = 'forward';
            let selectedGapOption = 'pitch';
            let selectedConnectionOption = 'continuation';
            
            // Feature layers
            let curbGuidesLayer = L.layerGroup();
            let curbPitchesLayer = L.layerGroup();
            let curbGapsLayer = L.layerGroup();
            let catchBasinsLayer = L.layerGroup();
            let drainageHeatLayer = null;
            let utilitiesLayer = L.layerGroup();
            
            // Road network data
            let curbs = [];
            let curbSegmentsWithPitch = [];
            
            // Utility filters
            let utilityFilters = {
                types: ['water', 'gas', 'electric', 'sewer', 'telecom'],
                categories: ['main', 'service']
            };
            
            // Initialize map
            initMap();
            
            // Initialize UI interactions
            initUIHandlers();
            
            // Get user location
            getUserLocation();
            
            function initMap() {
                // Create map
                map = L.map('map', {
                    zoomControl: false,
                    attributionControl: false
                }).setView([40.7128, -74.0060], 16); // Default to NYC
                
                // Add zoom control
                L.control.zoom({
                    position: 'bottomleft'
                }).addTo(map);
                
                // Add tile layer
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22
                }).addTo(map);
                
                // Add feature layers to map
                curbGuidesLayer.addTo(map);
                curbPitchesLayer.addTo(map);
                curbGapsLayer.addTo(map);
                catchBasinsLayer.addTo(map);
                
                // Initialize heatmap layer
                initHeatmapLayer();
                
                // Map event listeners
                map.on('click', handleMapClick);
                map.on('mousemove', handleMouseMove);
                map.on('touchmove', handleTouchMove);
                map.on('contextmenu', handleContextMenu);
                
                // Hide context menu on map move
                map.on('movestart', hideContextMenu);
                
                // Road data load on map movement
                map.on('moveend', loadRoadData);
            }
            
            function initHeatmapLayer() {
                // Remove existing heatmap layer if exists
                if (drainageHeatLayer) {
                    map.removeLayer(drainageHeatLayer);
                }
                
                // Initialize with empty data
                drainageHeatLayer = L.heatLayer([], {
                    radius: 25,
                    blur: 15,
                    maxZoom: 17,
                    gradient: {
                        0.0: 'green',
                        0.5: 'yellow',
                        1.0: 'red'
                    }
                }).addTo(map);
                
                // Show heat map legend
                document.getElementById('drainage-heat-legend').classList.add('visible');
            }
            
            function recalculateDrainageHeatmap() {
                // This function calculates drainage risk points based on catchbasins and curb pitches
                
                if (activeMode !== 'drainage') return;
                
                // Clear existing heatmap data
                if (drainageHeatLayer) {
                    map.removeLayer(drainageHeatLayer);
                }
                
                // Get current map bounds to limit calculation to visible area
                const bounds = map.getBounds();
                const points = [];
                
                // First get all curb segments with pitch
                const pitchedSegments = [];
                curbPitchesLayer.eachLayer(function(layer) {
                    if (layer instanceof L.Polyline) {
                        const latlngs = layer.getLatLngs();
                        if (latlngs.length >= 2) {
                            pitchedSegments.push({
                                start: latlngs[0],
                                end: latlngs[latlngs.length - 1],
                                pitchPercent: layer.options.pitchPercent || 2.0,
                                direction: layer.options.direction || 'forward'
                            });
                        }
                    }
                });
                
                // Get all catch basins
                const catchBasins = [];
                catchBasinsLayer.eachLayer(function(layer) {
                    catchBasins.push(layer.getLatLng());
                });
                
                // Calculate flooding risk
                // First, assign high risk to areas with no catch basins
                if (catchBasins.length === 0) {
                    // No catch basins, add high risk points across the visible map
                    const sw = bounds.getSouthWest();
                    const ne = bounds.getNorthEast();
                    const latStep = (ne.lat - sw.lat) / 10;
                    const lngStep = (ne.lng - sw.lng) / 10;
                    
                    for (let lat = sw.lat; lat <= ne.lat; lat += latStep) {
                        for (let lng = sw.lng; lng <= ne.lng; lng += lngStep) {
                            points.push([lat, lng, 1.0]); // High risk
                        }
                    }
                } else {
                    // With catch basins, calculate risk based on distance and pitch direction
                    
                    // Get all curb points
                    const allCurbPoints = [];
                    curbs.forEach(curb => {
                        curb.latlngs.forEach(point => {
                            // Add each point once, regardless of which curb it's on
                            const found = allCurbPoints.some(p => 
                                Math.abs(p.lat - point.lat) < 0.0001 && 
                                Math.abs(p.lng - point.lng) < 0.0001);
                            
                            if (!found) {
                                allCurbPoints.push(point);
                            }
                        });
                    });
                    
                    // For each curb point, calculate risk based on pitch and catch basin proximity
                    allCurbPoints.forEach(point => {
                        if (!bounds.contains(point)) return;
                        
                        // Find the closest catch basin
                        let minDistance = Infinity;
                        let closestBasin = null;
                        
                        catchBasins.forEach(basin => {
                            const distance = map.distance(point, basin);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestBasin = basin;
                            }
                        });
                        
                        // Find if this point is on a pitched segment
                        let isOnPitchedSegment = false;
                        let flowsToBasin = false;
                        
                        pitchedSegments.forEach(segment => {
                            const onLine = isPointOnLine(point, segment.start, segment.end);
                            if (onLine) {
                                isOnPitchedSegment = true;
                                
                                // Determine if water flows toward the catch basin
                                const basToStart = map.distance(closestBasin, segment.start);
                                const basToEnd = map.distance(closestBasin, segment.end);
                                
                                if (segment.direction === 'forward') {
                                    flowsToBasin = basToEnd < basToStart;
                                } else {
                                    flowsToBasin = basToStart < basToEnd;
                                }
                            }
                        });
                        
                        // Calculate risk
                        let risk = 0;
                        
                        // Base risk on distance to closest catch basin
                        if (minDistance === Infinity) {
                            risk = 1.0; // Max risk if no catch basin
                        } else {
                            // Normalize distance
                            const normalizedDist = Math.min(1.0, minDistance / 200); // 200m is considered max distance
                            risk = normalizedDist;
                            
                            // Reduce risk if the pitch flows toward a catch basin
                            if (isOnPitchedSegment && flowsToBasin) {
                                risk *= 0.3; // Significant reduction
                            } else if (isOnPitchedSegment && !flowsToBasin) {
                                risk *= 0.7; // Slight reduction
                            }
                        }
                        
                        // Add risk point
                        points.push([point.lat, point.lng, risk]);
                    });
                    
                    // Add extra high risk points for segments that don't flow to catch basins
                    pitchedSegments.forEach(segment => {
                        let flowsToBasin = false;
                        catchBasins.forEach(basin => {
                            const basToStart = map.distance(basin, segment.start);
                            const basToEnd = map.distance(basin, segment.end);
                            
                            if (segment.direction === 'forward') {
                                if (basToEnd < basToStart) flowsToBasin = true;
                            } else {
                                if (basToStart < basToEnd) flowsToBasin = true;
                            }
                        });
                        
                        if (!flowsToBasin) {
                            // Add more risk points along this segment
                            const midLat = (segment.start.lat + segment.end.lat) / 2;
                            const midLng = (segment.start.lng + segment.end.lng) / 2;
                            
                            // End point is high risk since water flows there with no catch basin
                            let riskPoint;
                            if (segment.direction === 'forward') {
                                riskPoint = segment.end;
                            } else {
                                riskPoint = segment.start;
                            }
                            
                            // Add high risk at the end where water accumulates
                            points.push([riskPoint.lat, riskPoint.lng, 1.0]);
                            
                            // Add medium risk at the middle
                            points.push([midLat, midLng, 0.7]);
                        }
                    });
                    
                    // Add risk points for gaps in curb pitches
                    curbGapsLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline) {
                            const latlngs = layer.getLatLngs();
                            if (latlngs.length >= 2) {
                                const midLat = (latlngs[0].lat + latlngs[1].lat) / 2;
                                const midLng = (latlngs[0].lng + latlngs[1].lng) / 2;
                                
                                // Gaps without defined drainage are high risk
                                points.push([midLat, midLng, 0.9]);
                            }
                        }
                    });
                }
                
                // Create new heatmap layer
                drainageHeatLayer = L.heatLayer(points, {
                    radius: 25,
                    blur: 15,
                    maxZoom: 17,
                    gradient: {
                        0.0: 'green',
                        0.5: 'yellow',
                        1.0: 'red'
                    }
                }).addTo(map);
            }
            
            function isPointOnLine(point, lineStart, lineEnd, tolerance = 0.0001) {
                // Check if a point lies on a line with some tolerance
                const dxLine = lineEnd.lng - lineStart.lng;
                const dyLine = lineEnd.lat - lineStart.lat;
                const dxPoint = point.lng - lineStart.lng;
                const dyPoint = point.lat - lineStart.lat;
                
                // Check if the point is collinear with the line
                const crossProduct = Math.abs(dxLine * dyPoint - dyLine * dxPoint);
                
                if (crossProduct > tolerance) return false;
                
                // Check if the point is within the line segment
                if (Math.abs(dxLine) >= Math.abs(dyLine)) {
                    return dxLine > 0 ? 
                        lineStart.lng <= point.lng && point.lng <= lineEnd.lng :
                        lineEnd.lng <= point.lng && point.lng <= lineStart.lng;
                } else {
                    return dyLine > 0 ? 
                        lineStart.lat <= point.lat && point.lat <= lineEnd.lat :
                        lineEnd.lat <= point.lat && point.lat <= lineStart.lat;
                }
            }
            
            function getUserLocation() {
                // Show loading overlay
                document.querySelector('.loading-overlay').style.display = 'flex';
                
                // Update status
                updateStatus('Finding your location...');
                
                // Check if geolocation is available
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(function(position) {
                        // Store position
                        currentPosition = [position.coords.latitude, position.coords.longitude];
                        
                        // Update map center
                        map.setView(currentPosition, 19);
                        
                        // Create user marker
                        if (!userMarker) {
                            userMarker = L.circleMarker(currentPosition, {
                                radius: 8,
                                fillColor: activeMode === 'drainage' ? '#0099cc' : '#7e57c2',
                                color: '#fff',
                                weight: 2,
                                opacity: 1,
                                fillOpacity: 0.8
                            }).addTo(map);
                        } else {
                            userMarker.setLatLng(currentPosition);
                        }
                        
                        // Load road data
                        loadRoadData();
                        
                        // Update status
                        updateStatus('Select a tool to begin');
                        
                        // Hide loading overlay
                        document.querySelector('.loading-overlay').style.display = 'none';
                        
                        // Watch position for updates
                        navigator.geolocation.watchPosition(function(position) {
                            // Update current position
                            currentPosition = [position.coords.latitude, position.coords.longitude];
                            
                            // Update user marker
                            if (userMarker) {
                                userMarker.setLatLng(currentPosition);
                            }
                        }, function(error) {
                            console.error('Error watching position:', error);
                        }, {
                            enableHighAccuracy: true,
                            maximumAge: 0,
                            timeout: 5000
                        });
                        
                    }, function(error) {
                        console.error('Error getting location:', error);
                        
                        // Update status
                        updateStatus('Location access denied. Please enable GPS.');
                        
                        // Hide loading overlay
                        document.querySelector('.loading-overlay').style.display = 'none';
                    }, {
                        enableHighAccuracy: true,
                        maximumAge: 0,
                        timeout: 5000
                    });
                } else {
                    // Update status
                    updateStatus('Geolocation not supported in this browser');
                    
                    // Hide loading overlay
                    document.querySelector('.loading-overlay').style.display = 'none';
                }
            }
            
            function loadRoadData() {
                // Show loading message
                updateStatus('Loading street data...');
                
                // Get current map bounds
                const bounds = map.getBounds();
                const south = bounds.getSouth();
                const west = bounds.getWest();
                const north = bounds.getNorth();
                const east = bounds.getEast();
                
                // Clear existing guides
                curbGuidesLayer.clearLayers();
                curbs = [];
                
                // Check if we're zoomed in enough
                if (map.getZoom() < 16) {
                    updateStatus('Zoom in closer to see street details');
                    return;
                }
                
                // Use Overpass API to get road data
                const overpassQuery = `
                    [out:json];
                    (
                      way["highway"](${south},${west},${north},${east});
                    );
                    out body geom;
                `;
                
                // Overpass API endpoint
                const overpassUrl = "https://overpass-api.de/api/interpreter";
                
                fetch(overpassUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
                    },
                    body: 'data=' + encodeURIComponent(overpassQuery.trim())
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data && data.elements) {
                        processRoadData(data.elements);
                    }
                })
                .catch(error => {
                    console.error('Error fetching road data:', error);
                    updateStatus('Failed to load street data.');
                });
            }
            
            function processRoadData(elements) {
                if (!elements || elements.length === 0) {
                    updateStatus('No street data found.');
                    return;
                }
                
                let validRoads = 0;
                
                // Filter walkable highway types
                const roadTypes = ['motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'residential', 'service', 'unclassified'];
                
                elements.forEach(element => {
                    if (element.type === 'way' && element.tags && element.tags.highway && roadTypes.includes(element.tags.highway)) {
                        if (element.geometry && element.geometry.length > 1) {
                            // Convert geometry to LatLng array
                            const latlngs = element.geometry.map(node => [node.lat, node.lon]);
                            
                            // Generate curb lines on both sides
                            createCurbLines(latlngs, element.id);
                            
                            validRoads++;
                        }
                    }
                });
                
                if (validRoads > 0) {
                    updateStatus(`Loaded ${validRoads} streets. Select a tool to begin.`);
                    
                    // If in drainage mode, find gaps between curb segments
                    if (activeMode === 'drainage') {
                        findCurbGaps();
                        recalculateDrainageHeatmap();
                    }
                } else {
                    updateStatus('No valid streets found.');
                }
            }
            
            function createCurbLines(streetPoints, streetId) {
                if (streetPoints.length < 2) return;
                
                // Calculate curb offsets
                const curbOffsets = curbOffsetPoints(streetPoints, 5); // 5 meters offset
                
                if (curbOffsets && curbOffsets.length > 0) {
                    // Create left and right curb polylines
                    const leftCurbPoints = curbOffsets.map(pair => pair[0]);
                    const rightCurbPoints = curbOffsets.map(pair => pair[1]);
                    
                    const leftCurb = L.polyline(leftCurbPoints, {
                        className: 'curb-guide',
                        interactive: true
                    }).addTo(curbGuidesLayer);
                    
                    const rightCurb = L.polyline(rightCurbPoints, {
                        className: 'curb-guide',
                        interactive: true
                    }).addTo(curbGuidesLayer);
                    
                    // Store curb data
                    curbs.push({
                        id: `${streetId}-left`,
                        latlngs: leftCurbPoints,
                        streetId: streetId
                    });
                    
                    curbs.push({
                        id: `${streetId}-right`,
                        latlngs: rightCurbPoints,
                        streetId: streetId
                    });
                }
            }
            
            function curbOffsetPoints(streetPts, meters) {
                return streetPts.map((p, i, arr) => {
                    if (i === arr.length - 1) return null;
                    
                    // Convert points to screen coordinates for better accuracy
                    const a = map.latLngToLayerPoint(L.latLng(arr[i]));
                    const b = map.latLngToLayerPoint(L.latLng(arr[i + 1]));
                    
                    // Calculate normalized direction vector
                    const dx = b.x - a.x;
                    const dy = b.y - a.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist === 0) return null;
                    
                    // Normalize direction vector
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    // Calculate perpendicular vector
                    const perpX = -ny;
                    const perpY = nx;
                    
                    // Calculate offset in pixels (approx. 3 pixels per meter at zoom level 19)
                    const pixelsPerMeter = 3;
                    const offsetPixels = meters * pixelsPerMeter;
                    
                    // Apply offset
                    const leftX = a.x + perpX * offsetPixels;
                    const leftY = a.y + perpY * offsetPixels;
                    const rightX = a.x - perpX * offsetPixels;
                    const rightY = a.y - perpY * offsetPixels;
                    
                    // Convert back to lat/lng
                    const leftLatLng = map.layerPointToLatLng(L.point(leftX, leftY));
                    const rightLatLng = map.layerPointToLatLng(L.point(rightX, rightY));
                    
                    return [leftLatLng, rightLatLng];
                }).filter(Boolean); // Remove null values
            }
            
            function findCurbGaps() {
                // Clear existing gaps
                curbGapsLayer.clearLayers();
                
                // For each curb, find segments without pitch
                curbs.forEach(curb => {
                    if (curb.latlngs.length < 2) return;
                    
                    // Create segments from each pair of adjacent points
                    for (let i = 0; i < curb.latlngs.length - 1; i++) {
                        const start = curb.latlngs[i];
                        const end = curb.latlngs[i + 1];
                        
                        // Check if this segment has a pitch
                        const hasPitch = curbSegmentsWithPitch.some(segment => 
                            (arePointsEqual(segment.start, start) && arePointsEqual(segment.end, end)) ||
                            (arePointsEqual(segment.start, end) && arePointsEqual(segment.end, start))
                        );
                        
                        if (!hasPitch) {
                            // If no pitch, add to gaps layer
                            L.polyline([start, end], {
                                className: 'curb-gap',
                                curbId: curb.id,
                                segmentIndex: i,
                                interactive: true
                            }).addTo(curbGapsLayer);
                        }
                    }
                });
            }
            
            function arePointsEqual(p1, p2, tolerance = 0.0001) {
                return Math.abs(p1.lat - p2.lat) < tolerance && Math.abs(p1.lng - p2.lng) < tolerance;
            }
            
            function handleMapClick(e) {
                // Hide context menu if open
                hideContextMenu();
                hideUtilityInfo();
                
                // Do nothing if no active tool
                if (!activeTool) return;
                
                if (activeMode === 'drainage') {
                    handleDrainageModeClick(e);
                } else {
                    handleUtilityModeClick(e);
                }
            }
            
            function handleDrainageModeClick(e) {
                // Handle clicks in drainage mode
                
                // Check if clicking on a curb gap
                let clickedGap = null;
                curbGapsLayer.eachLayer(function(layer) {
                    if (isClickNearPolyline(e.latlng, layer)) {
                        clickedGap = layer;
                    }
                });
                
                if (clickedGap) {
                    // User clicked on a curb gap
                    selectedGap = clickedGap;
                    gapPitchPercent = 2.0;
                    gapPitchDirection = 'forward';
                    selectedGapOption = 'pitch';
                    
                    // Update UI
                    document.getElementById('gap-pitch-value').textContent = gapPitchPercent.toFixed(1) + '%';
                    
                    // Reset option buttons
                    document.querySelectorAll('#gap-options .option-btn').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    document.querySelector('#gap-options [data-option="pitch"]').classList.add('selected');
                    
                    document.querySelectorAll('[data-direction]').forEach(btn => {
                        btn.classList.remove('selected');
                    });
                    document.querySelector('[data-direction="forward"]').classList.add('selected');
                    
                    // Show gap treatment modal
                    document.getElementById('gap-treatment-modal').style.display = 'flex';
                    
                    return;
                }
                
                // Handle other clicks based on active tool
                if (activeTool === 'curb-pitch-tool') {
                    handleCurbPitchClick(e);
                } else if (activeTool === 'catch-basin-tool') {
                    addCatchBasin(e.latlng);
                }
            }
            
            function handleCurbPitchClick(e) {
                let clickPoint = e.latlng;
                
                // Find nearest curb point if snapping enabled
                if (snapEnabled) {
                    const nearestResult = findNearestPointOnCurbs(clickPoint);
                    if (nearestResult && nearestResult.valid) {
                        clickPoint = nearestResult.point;
                    } else {
                        showNotification('Can only draw pitches on curbs');
                        return;
                    }
                }
                
                if (!isDrawing) {
                    // Start new pitch line
                    isDrawing = true;
                    drawingPoints = [clickPoint];
                    
                    // Create temporary line
                    tempLine = L.polyline([clickPoint, clickPoint], {
                        color: '#ffcc00',
                        weight: 5,
                        opacity: 0.7,
                        dashArray: '5,5'
                    }).addTo(map);
                    
                    // Show cancel button
                    document.getElementById('cancel-action-btn').style.display = 'block';
                    
                    updateStatus('Click on another point on the curb to complete the line');
                } else {
                    // Complete pitch line
                    drawingPoints.push(clickPoint);
                    
                    // Hide cancel button
                    document.getElementById('cancel-action-btn').style.display = 'none';
                    
                    // Validate the segment
                    if (isValidCurbSegment(drawingPoints[0], drawingPoints[1])) {
                        // Pitch is valid, show input modal
                        document.getElementById('pitch-modal').style.display = 'flex';
                        document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                    } else {
                        // Not valid, reset drawing
                        cancelDrawing();
                        showNotification('Invalid curb segment. Make sure the points are on the same curb.');
                    }
                }
            }
            
            function isValidCurbSegment(point1, point2) {
                // Check if both points are on the same curb
                for (const curb of curbs) {
                    let foundPoint1 = false;
                    let foundPoint2 = false;
                    
                    // Check if points are on this curb
                    for (const curbPoint of curb.latlngs) {
                        if (arePointsEqual(point1, curbPoint)) {
                            foundPoint1 = true;
                        }
                        if (arePointsEqual(point2, curbPoint)) {
                            foundPoint2 = true;
                        }
                    }
                    
                    if (foundPoint1 && foundPoint2) {
                        return true;
                    }
                }
                
                return false;
            }
            
            function findNearestPointOnCurbs(point) {
                // Maximum distance to consider valid
                const maxDistance = 20; // meters
                
                let minDistance = Infinity;
                let nearestPoint = null;
                
                // Check all curbs
                curbs.forEach(curb => {
                    for (let i = 0; i < curb.latlngs.length; i++) {
                        const distance = map.distance(point, curb.latlngs[i]);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestPoint = curb.latlngs[i];
                        }
                    }
                });
                
                return {
                    point: nearestPoint,
                    valid: minDistance <= maxDistance,
                    distance: minDistance
                };
            }
            
            function finalizeCurbPitch() {
                // Remove temp line
                if (tempLine) {
                    map.removeLayer(tempLine);
                    tempLine = null;
                }
                
                // Create final pitch polyline
                const direction = drawingPoints[0].lat < drawingPoints[1].lat ? 'forward' : 'backward';
                const line = L.polyline(drawingPoints, {
                    color: '#ffcc00',
                    weight: 5,
                    opacity: 1,
                    className: 'curb-line',
                    pitchPercent: pitchPercent,
                    direction: direction
                }).addTo(curbPitchesLayer);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'curbPitch',
                    element: line
                });
                
                // Store segment details
                curbSegmentsWithPitch.push({
                    start: drawingPoints[0],
                    end: drawingPoints[1],
                    pitchPercent: pitchPercent,
                    direction: direction
                });
                
                // Add direction arrow
                addDirectionArrow(line);
                
                // Add pitch label
                addPitchLabel(line);
                
                // Reset drawing state
                isDrawing = false;
                drawingPoints = [];
                
                // Update status
                updateStatus('Curb pitch added at ' + pitchPercent.toFixed(1) + '%');
                
                // Find gaps
                findCurbGaps();
                
                // Update heatmap
                recalculateDrainageHeatmap();
            }
            
            function handleGapTreatment() {
                if (!selectedGap) return;
                
                const curbId = selectedGap.options.curbId;
                const segmentIndex = selectedGap.options.segmentIndex;
                const latlngs = selectedGap.getLatLngs();
                
                // Get the curb this gap belongs to
                const curb = curbs.find(c => c.id === curbId);
                if (!curb) return;
                
                if (selectedGapOption === 'pitch') {
                    // Add a pitch to this gap
                    const direction = gapPitchDirection === 'forward' ? 'forward' : 'backward';
                    const points = direction === 'forward' ? [latlngs[0], latlngs[1]] : [latlngs[1], latlngs[0]];
                    
                    const line = L.polyline(points, {
                        color: '#ffcc00',
                        weight: 5,
                        opacity: 1,
                        className: 'curb-line',
                        pitchPercent: gapPitchPercent,
                        direction: direction
                    }).addTo(curbPitchesLayer);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'curbPitch',
                        element: line
                    });
                    
                    // Store segment details
                    curbSegmentsWithPitch.push({
                        start: points[0],
                        end: points[1],
                        pitchPercent: gapPitchPercent,
                        direction: direction
                    });
                    
                    // Add direction arrow
                    addDirectionArrow(line);
                    
                    // Add pitch label
                    addPitchLabel(line);
                    
                } else if (selectedGapOption === 'transition') {
                    // Create a transition pitch between adjacent segments
                    
                    // Find adjacent pitches
                    let prevPitch = null;
                    let nextPitch = null;
                    
                    curbPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline) {
                            const lineLatlngs = layer.getLatLngs();
                            
                            // Check if this line connects to our gap
                            if (arePointsEqual(lineLatlngs[0], latlngs[0]) || arePointsEqual(lineLatlngs[1], latlngs[0])) {
                                prevPitch = {
                                    line: layer,
                                    percent: layer.options.pitchPercent,
                                    direction: layer.options.direction
                                };
                            }
                            
                            if (arePointsEqual(lineLatlngs[0], latlngs[1]) || arePointsEqual(lineLatlngs[1], latlngs[1])) {
                                nextPitch = {
                                    line: layer,
                                    percent: layer.options.pitchPercent,
                                    direction: layer.options.direction
                                };
                            }
                        }
                    });
                    
                    if (prevPitch && nextPitch) {
                        // Create transition pitch
                        const avgPercent = (prevPitch.percent + nextPitch.percent) / 2;
                        
                        // Determine direction for smooth transition
                        let direction;
                        if (prevPitch.direction === nextPitch.direction) {
                            direction = prevPitch.direction;
                        } else {
                            // If adjacent pitches flow in opposite directions, 
                            // make water flow away from higher to lower
                            direction = prevPitch.percent >= nextPitch.percent ? prevPitch.direction : nextPitch.direction;
                        }
                        
                        const points = direction === 'forward' ? [latlngs[0], latlngs[1]] : [latlngs[1], latlngs[0]];
                        
                        const line = L.polyline(points, {
                            color: '#ffcc00',
                            weight: 5,
                            opacity: 1,
                            className: 'curb-line',
                            pitchPercent: avgPercent,
                            direction: direction
                        }).addTo(curbPitchesLayer);
                        
                        // Add to undo stack
                        addToUndoStack({
                            type: 'curbPitch',
                            element: line
                        });
                        
                        // Store segment details
                        curbSegmentsWithPitch.push({
                            start: points[0],
                            end: points[1],
                            pitchPercent: avgPercent,
                            direction: direction
                        });
                        
                        // Add direction arrow
                        addDirectionArrow(line);
                        
                        // Add pitch label
                        addPitchLabel(line);
                        
                    } else {
                        showNotification('Cannot create transition. No adjacent pitch segments found.');
                    }
                } else if (selectedGapOption === 'highpoint') {
                    // Create a high point in the middle with pitches flowing outward
                    
                    // Create two segments with opposite flow direction
                    const midPoint = {
                        lat: (latlngs[0].lat + latlngs[1].lat) / 2,
                        lng: (latlngs[0].lng + latlngs[1].lng) / 2
                    };
                    
                    // First segment: start -> midpoint
                    const firstLine = L.polyline([latlngs[0], midPoint], {
                        color: '#ffcc00',
                        weight: 5,
                        opacity: 1,
                        className: 'curb-line',
                        pitchPercent: gapPitchPercent,
                        direction: 'backward' // away from high point
                    }).addTo(curbPitchesLayer);
                    
                    // Second segment: midpoint -> end
                    const secondLine = L.polyline([midPoint, latlngs[1]], {
                        color: '#ffcc00',
                        weight: 5,
                        opacity: 1,
                        className: 'curb-line',
                        pitchPercent: gapPitchPercent,
                        direction: 'forward' // away from high point
                    }).addTo(curbPitchesLayer);
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'curbPitch',
                        element: firstLine
                    });
                    
                    addToUndoStack({
                        type: 'curbPitch',
                        element: secondLine
                    });
                    
                    // Store segment details
                    curbSegmentsWithPitch.push({
                        start: latlngs[0],
                        end: midPoint,
                        pitchPercent: gapPitchPercent,
                        direction: 'backward'
                    });
                    
                    curbSegmentsWithPitch.push({
                        start: midPoint,
                        end: latlngs[1],
                        pitchPercent: gapPitchPercent,
                        direction: 'forward'
                    });
                    
                    // Add direction arrows
                    addDirectionArrow(firstLine);
                    addDirectionArrow(secondLine);
                    
                    // Add pitch labels
                    addPitchLabel(firstLine);
                    addPitchLabel(secondLine);
                    
                    // Add a high point marker
                    const highPointIcon = L.divIcon({
                        html: '<div style="background-color: #ff9800; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                        className: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    
                    const highPointMarker = L.marker(midPoint, {
                        icon: highPointIcon,
                        interactive: false
                    }).addTo(curbPitchesLayer);
                }
                
                // Remove the gap from gaps layer
                curbGapsLayer.removeLayer(selectedGap);
                
                // Update heatmap
                recalculateDrainageHeatmap();
                
                // Update status
                updateStatus('Curb gap filled successfully');
            }
            
            function handleUtilityModeClick(e) {
                // Handle clicks in utility mode
                if (activeTool === 'utility-found-tool') {
                    // Place utility at clicked point
                    const clickPoint = e.latlng;
                    
                    // Create temporary marker
                    tempUtilityMarker = L.marker(clickPoint, {
                        icon: createUtilityIcon('utility'),
                        draggable: false
                    }).addTo(map);
                    
                    // Reset utility angle
                    utilityAngle = 0;
                    
                    // Calculate end point for direction line
                    const endPoint = calculateEndPoint(clickPoint, utilityAngle, 30);
                    
                    // Create temporary direction line
                    tempUtilityLine = L.polyline([clickPoint, endPoint], {
                        color: '#7e57c2',
                        className: 'utility-temp-line'
                    }).addTo(map);
                    
                    // Show direction modal
                    document.getElementById('utility-found-modal').style.display = 'flex';
                    
                    // Show cancel button
                    document.getElementById('cancel-action-btn').style.display = 'block';
                    
                    // Update direction indicator
                    updateDirectionIndicator();
                    
                } else if (activeTool === 'mapping-utility-tool') {
                    handleMappingUtilityClick(e);
                }
            }
            
            function handleMappingUtilityClick(e) {
                let clickPoint = e.latlng;
                
                if (!isDrawing) {
                    // Start new utility line
                    isDrawing = true;
                    drawingPoints = [clickPoint];
                    
                    // Create temporary line
                    const utilityColor = getUtilityColor(utilityPresets.type);
                    tempLine = L.polyline([clickPoint, clickPoint], {
                        color: utilityColor,
                        weight: utilityPresets.category === 'main' ? 5 : 3,
                        opacity: 0.7,
                        dashArray: utilityPresets.category === 'service' ? '5,3' : null
                    }).addTo(map);
                    
                    // Show cancel button
                    document.getElementById('cancel-action-btn').style.display = 'block';
                    
                    updateStatus('Click to add points to the utility line. Click on the last point to finish.');
                } else {
                    // Check if clicking near the first point to close the line
                    const firstPoint = drawingPoints[0];
                    const distance = map.distance(clickPoint, firstPoint);
                    
                    if (drawingPoints.length > 1 && distance < 15) {
                        // Complete the line
                        completeUtilityLine();
                    } else {
                        // Add point to line
                        drawingPoints.push(clickPoint);
                        tempLine.setLatLngs(drawingPoints);
                        
                        // Check if we need to connect to another utility of the same type
                        const nearbyUtility = findNearbyUtility(clickPoint, utilityPresets.type);
                        
                        if (nearbyUtility) {
                            // Store connection start
                            connectionStartUtility = nearbyUtility;
                            
                            // Complete the line
                            completeUtilityLine();
                        }
                    }
                }
            }
            
            function findNearbyUtility(point, type, maxDistance = 15) {
                let result = null;
                
                utilitiesLayer.eachLayer(function(layer) {
                    if (layer instanceof L.Polyline && layer.options.utilityType === type) {
                        // Check distance to line
                        const latlngs = layer.getLatLngs();
                        
                        // Check each segment
                        for (let i = 0; i < latlngs.length - 1; i++) {
                            const distance = distanceToSegment(point, latlngs[i], latlngs[i+1]);
                            if (distance < maxDistance) {
                                result = {
                                    line: layer,
                                    nearPoint: projectPointOnSegment(point, latlngs[i], latlngs[i+1]),
                                    isService: layer.options.utilityCategory === 'service'
                                };
                                break;
                            }
                        }
                        
                        // For service connections to mains
                        if (result === null && utilityPresets.category === 'service' && layer.options.utilityCategory === 'main') {
                            // For service line to main, we can connect to any point on the main
                            latlngs.forEach(latlng => {
                                const distance = map.distance(point, latlng);
                                if (distance < maxDistance) {
                                    result = {
                                        line: layer,
                                        nearPoint: latlng,
                                        isService: false
                                    };
                                }
                            });
                        }
                    }
                });
                
                return result;
            }
            
            function distanceToSegment(point, segmentStart, segmentEnd) {
                const p = map.latLngToLayerPoint(point);
                const s = map.latLngToLayerPoint(segmentStart);
                const e = map.latLngToLayerPoint(segmentEnd);
                
                const l2 = (s.x - e.x) * (s.x - e.x) + (s.y - e.y) * (s.y - e.y);
                if (l2 === 0) return p.distanceTo(s);
                
                let t = ((p.x - s.x) * (e.x - s.x) + (p.y - s.y) * (e.y - s.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                
                const proj = {
                    x: s.x + t * (e.x - s.x),
                    y: s.y + t * (e.y - s.y)
                };
                
                return Math.sqrt((p.x - proj.x) * (p.x - proj.x) + (p.y - proj.y) * (p.y - proj.y));
            }
            
            function projectPointOnSegment(point, segmentStart, segmentEnd) {
                const p = map.latLngToLayerPoint(point);
                const s = map.latLngToLayerPoint(segmentStart);
                const e = map.latLngToLayerPoint(segmentEnd);
                
                const l2 = (s.x - e.x) * (s.x - e.x) + (s.y - e.y) * (s.y - e.y);
                if (l2 === 0) return segmentStart;
                
                let t = ((p.x - s.x) * (e.x - s.x) + (p.y - s.y) * (e.y - s.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                
                const proj = {
                    x: s.x + t * (e.x - s.x),
                    y: s.y + t * (e.y - s.y)
                };
                
                return map.layerPointToLatLng(L.point(proj.x, proj.y));
            }
            
            function completeUtilityLine() {
                // Hide cancel button
                document.getElementById('cancel-action-btn').style.display = 'none';
                
                // Reset drawing state
                isDrawing = false;
                
                if (drawingPoints.length < 2) {
                    // Not enough points
                    if (tempLine) {
                        map.removeLayer(tempLine);
                        tempLine = null;
                    }
                    drawingPoints = [];
                    return;
                }
                
                // Check if we need to show connection modal
                if (connectionStartUtility) {
                    // Show connection options modal
                    document.getElementById('utility-connection-modal').style.display = 'flex';
                } else {
                    // Directly finalize the utility line
                    finalizeUtilityLine();
                }
            }
            
            function finalizeUtilityLine() {
                // Remove temp line
                if (tempLine) {
                    map.removeLayer(tempLine);
                    tempLine = null;
                }
                
                // Handle connection if needed
                if (connectionStartUtility) {
                    connectUtilityLines();
                    connectionStartUtility = null;
                    return;
                }
                
                // Create final utility line
                const line = L.polyline(drawingPoints, {
                    color: getUtilityColor(utilityPresets.type),
                    weight: utilityPresets.category === 'main' ? 5 : 3,
                    opacity: 1,
                    className: `utility-line ${utilityPresets.type} ${utilityPresets.category}`,
                    utilityType: utilityPresets.type,
                    utilityCategory: utilityPresets.category,
                    utilitySize: utilityPresets.size,
                    utilityDepth: utilityPresets.depth,
                    mediaData: null
                }).addTo(utilitiesLayer);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'utility',
                    element: line
                });
                
                // Create marker for line
                const markerPosition = drawingPoints[0];
                const utilityMarker = L.marker(markerPosition, {
                    icon: createUtilityIcon(utilityPresets.type, utilityPresets.category === 'main'),
                    draggable: true,
                    utilityType: utilityPresets.type,
                    utilityCategory: utilityPresets.category,
                    utilitySize: utilityPresets.size,
                    utilityDepth: utilityPresets.depth,
                    utilityDirection: 0,
                    mediaData: null
                }).addTo(utilitiesLayer);
                
                // Link marker and line
                line.utilityMarker = utilityMarker;
                utilityMarker.utilityLine = line;
                
                // Add event handlers
                utilityMarker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showUtilityInfo(utilityMarker);
                });
                
                utilityMarker.on('contextmenu', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showContextMenu(e, utilityMarker, 'utility');
                });
                
                line.on('contextmenu', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showContextMenu(e, line, 'utilityLine');
                });
                
                // Reset drawing points
                drawingPoints = [];
                
                // Update status
                updateStatus(`${utilityPresets.type.charAt(0).toUpperCase() + utilityPresets.type.slice(1)} ${utilityPresets.category} added`);
            }
            
            function connectUtilityLines() {
                // Get connection information
                const existingLine = connectionStartUtility.line;
                const newLinePoints = drawingPoints.slice();
                const connectionPoint = connectionStartUtility.nearPoint;
                
                // Connect based on selected option
                if (selectedConnectionOption === 'continuation') {
                    // Smooth continuation - connect the lines with a natural curve
                    const existingLatlngs = existingLine.getLatLngs();
                    
                    // Determine which end of the existing line to connect to
                    let isEndConnection = false;
                    
                    // Check if connection point is near the start or end of the existing line
                    const startDist = map.distance(connectionPoint, existingLatlngs[0]);
                    const endDist = map.distance(connectionPoint, existingLatlngs[existingLatlngs.length - 1]);
                    
                    if (endDist < startDist) {
                        isEndConnection = true;
                    }
                    
                    // Create a combined array of points
                    let combinedPoints = [];
                    if (isEndConnection) {
                        combinedPoints = existingLatlngs.concat(newLinePoints);
                    } else {
                        combinedPoints = newLinePoints.concat(existingLatlngs);
                    }
                    
                    // Remove the old line
                    utilitiesLayer.removeLayer(existingLine);
                    
                    // Create a new combined line
                    const newLine = L.polyline(combinedPoints, {
                        color: getUtilityColor(utilityPresets.type),
                        weight: utilityPresets.category === 'main' ? 5 : 3,
                        opacity: 1,
                        className: `utility-line ${utilityPresets.type} ${utilityPresets.category}`,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        mediaData: existingLine.options.mediaData
                    }).addTo(utilitiesLayer);
                    
                    // Update the utility marker reference
                    if (existingLine.utilityMarker) {
                        existingLine.utilityMarker.utilityLine = newLine;
                        newLine.utilityMarker = existingLine.utilityMarker;
                    }
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utilityConnection',
                        newElement: newLine,
                        oldElement: existingLine,
                        oldPoints: existingLatlngs,
                        newPoints: newLinePoints
                    });
                    
                } else if (selectedConnectionOption === 'offset') {
                    // Offset connection - connect with a straight line between the closest endpoints
                    const existingLatlngs = existingLine.getLatLngs();
                    
                    // Determine which endpoints to connect
                    const startNew = newLinePoints[0];
                    const endNew = newLinePoints[newLinePoints.length - 1];
                    const startExisting = existingLatlngs[0];
                    const endExisting = existingLatlngs[existingLatlngs.length - 1];
                    
                    // Find the closest pair of endpoints
                    const distances = [
                        { points: [startNew, startExisting], dist: map.distance(startNew, startExisting) },
                        { points: [startNew, endExisting], dist: map.distance(startNew, endExisting) },
                        { points: [endNew, startExisting], dist: map.distance(endNew, startExisting) },
                        { points: [endNew, endExisting], dist: map.distance(endNew, endExisting) }
                    ];
                    
                    distances.sort((a, b) => a.dist - b.dist);
                    const closestPair = distances[0].points;
                    
                    // Create connecting line
                    const connectorLine = L.polyline(closestPair, {
                        color: getUtilityColor(utilityPresets.type),
                        weight: utilityPresets.category === 'main' ? 5 : 3,
                        opacity: 1,
                        className: `utility-line ${utilityPresets.type} ${utilityPresets.category}`,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        mediaData: null
                    }).addTo(utilitiesLayer);
                    
                    // Create the new utility line
                    const newLine = L.polyline(newLinePoints, {
                        color: getUtilityColor(utilityPresets.type),
                        weight: utilityPresets.category === 'main' ? 5 : 3,
                        opacity: 1,
                        className: `utility-line ${utilityPresets.type} ${utilityPresets.category}`,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        mediaData: null
                    }).addTo(utilitiesLayer);
                    
                    // Create marker for the new line
                    const markerPosition = newLinePoints[0];
                    const utilityMarker = L.marker(markerPosition, {
                        icon: createUtilityIcon(utilityPresets.type, utilityPresets.category === 'main'),
                        draggable: true,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        utilityDirection: 0,
                        mediaData: null
                    }).addTo(utilitiesLayer);
                    
                    // Link marker and line
                    newLine.utilityMarker = utilityMarker;
                    utilityMarker.utilityLine = newLine;
                    
                    // Add event handlers
                    utilityMarker.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(utilityMarker);
                    });
                    
                    utilityMarker.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, utilityMarker, 'utility');
                    });
                    
                    newLine.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, newLine, 'utilityLine');
                    });
                    
                    connectorLine.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, connectorLine, 'utilityLine');
                    });
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utility',
                        element: newLine
                    });
                    
                    addToUndoStack({
                        type: 'utility',
                        element: connectorLine
                    });
                    
                } else if (selectedConnectionOption === 'separate') {
                    // Keep as separate lines - create new line without connecting
                    const newLine = L.polyline(newLinePoints, {
                        color: getUtilityColor(utilityPresets.type),
                        weight: utilityPresets.category === 'main' ? 5 : 3,
                        opacity: 1,
                        className: `utility-line ${utilityPresets.type} ${utilityPresets.category}`,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        mediaData: null
                    }).addTo(utilitiesLayer);
                    
                    // Create marker for the new line
                    const markerPosition = newLinePoints[0];
                    const utilityMarker = L.marker(markerPosition, {
                        icon: createUtilityIcon(utilityPresets.type, utilityPresets.category === 'main'),
                        draggable: true,
                        utilityType: utilityPresets.type,
                        utilityCategory: utilityPresets.category,
                        utilitySize: utilityPresets.size,
                        utilityDepth: utilityPresets.depth,
                        utilityDirection: 0,
                        mediaData: null
                    }).addTo(utilitiesLayer);
                    
                    // Link marker and line
                    newLine.utilityMarker = utilityMarker;
                    utilityMarker.utilityLine = newLine;
                    
                    // Add event handlers
                    utilityMarker.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showUtilityInfo(utilityMarker);
                    });
                    
                    utilityMarker.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, utilityMarker, 'utility');
                    });
                    
                    newLine.on('contextmenu', function(e) {
                        L.DomEvent.stopPropagation(e);
                        showContextMenu(e, newLine, 'utilityLine');
                    });
                    
                    // Add to undo stack
                    addToUndoStack({
                        type: 'utility',
                        element: newLine
                    });
                }
                
                // Update status
                updateStatus('Utility connection completed');
            }
            
            function handleMouseMove(e) {
                // Update temporary line during drawing
                if (isDrawing && tempLine) {
                    let movePoint = e.latlng;
                    
                    // Add snapping for curb pitches in drainage mode
                    if (activeMode === 'drainage' && activeTool === 'curb-pitch-tool' && snapEnabled) {
                        const nearestResult = findNearestPointOnCurbs(movePoint);
                        if (nearestResult && nearestResult.valid) {
                            movePoint = nearestResult.point;
                        }
                    }
                    
                    // Update temp line
                    const points = [...drawingPoints, movePoint];
                    tempLine.setLatLngs(points);
                }
            }
            
            function handleTouchMove(e) {
                // Get touch position
                if (e.touches && e.touches.length > 0) {
                    const touch = e.touches[0];
                    const containerPoint = L.point(touch.clientX, touch.clientY);
                    const latlng = map.containerPointToLatLng(containerPoint);
                    
                    // Update temporary line during drawing
                    if (isDrawing && tempLine) {
                        let movePoint = latlng;
                        
                        // Add snapping for curb pitches in drainage mode
                        if (activeMode === 'drainage' && activeTool === 'curb-pitch-tool' && snapEnabled) {
                            const nearestResult = findNearestPointOnCurbs(movePoint);
                            if (nearestResult && nearestResult.valid) {
                                movePoint = nearestResult.point;
                            }
                        }
                        
                        // Update temp line
                        const points = [...drawingPoints, movePoint];
                        tempLine.setLatLngs(points);
                    }
                }
            }
            
            function handleContextMenu(e) {
                // Get clicked element if any
                let clickedElement = null;
                let elementType = null;
                
                // Check drainage layers first
                if (activeMode === 'drainage') {
                    curbPitchesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Polyline && isClickNearPolyline(e.latlng, layer) && 
                            !layer.arrowMarker && !layer.labelMarker) {
                            clickedElement = layer;
                            elementType = 'curbPitch';
                        }
                    });
                    
                    catchBasinsLayer.eachLayer(function(layer) {
                        if (isClickNearMarker(e.latlng, layer)) {
                            clickedElement = layer;
                            elementType = 'catchBasin';
                        }
                    });
                } else if (activeMode === 'utility') {
                    // Check utility layers
                    utilitiesLayer.eachLayer(function(layer) {
                        if (layer instanceof L.Marker && isClickNearMarker(e.latlng, layer)) {
                            clickedElement = layer;
                            elementType = 'utility';
                        } else if (layer instanceof L.Polyline && isClickNearPolyline(e.latlng, layer)) {
                            clickedElement = layer;
                            elementType = 'utilityLine';
                        }
                    });
                }
                
                // If no element was clicked, return
                if (!clickedElement) return;
                
                // Show context menu
                showContextMenu(e, clickedElement, elementType);
            }
            
            function isClickNearPolyline(point, polyline, maxDistance = 15) {
                const latlngs = polyline.getLatLngs();
                
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const distance = distanceToSegment(point, latlngs[i], latlngs[i+1]);
                    if (distance < maxDistance) {
                        return true;
                    }
                }
                
                return false;
            }
            
            function isClickNearMarker(point, marker, maxDistance = 15) {
                const distance = map.distance(point, marker.getLatLng());
                return distance < maxDistance;
            }
            
            function showContextMenu(e, element, elementType) {
                // Set selected element
                selectedElement = {
                    element: element,
                    type: elementType
                };
                
                // Get container point
                let containerPoint;
                if (e.containerPoint) {
                    containerPoint = e.containerPoint;
                } else if (e.latlng) {
                    containerPoint = map.latLngToContainerPoint(e.latlng);
                } else if (e.touches && e.touches.length > 0) {
                    containerPoint = L.point(e.touches[0].clientX, e.touches[0].clientY);
                } else if (element.getLatLng) {
                    containerPoint = map.latLngToContainerPoint(element.getLatLng());
                } else {
                    containerPoint = map.latLngToContainerPoint(element.getLatLngs()[0]);
                }
                
                // Clear existing menu items
                const contextMenu = document.getElementById('context-menu');
                contextMenu.innerHTML = '';
                
                // Add appropriate menu items based on element type
                if (elementType === 'curbPitch') {
                    // Curb pitch context menu
                    addContextMenuItem(contextMenu, 'reverse-direction', 'fa-exchange-alt', 'Reverse Direction', reversePitchDirection);
                    addContextMenuItem(contextMenu, 'edit-pitch', 'fa-edit', 'Edit Pitch', editPitch);
                    addContextMenuItem(contextMenu, 'delete-item', 'fa-trash', 'Delete', deleteElement);
                } else if (elementType === 'catchBasin') {
                    // Catch basin context menu
                    addContextMenuItem(contextMenu, 'delete-item', 'fa-trash', 'Delete', deleteElement);
                } else if (elementType === 'utility' || elementType === 'utilityLine') {
                    // Utility context menu
                    addContextMenuItem(contextMenu, 'edit-utility', 'fa-edit', 'Edit Details', editUtility);
                    addContextMenuItem(contextMenu, 'delete-item', 'fa-trash', 'Delete', deleteElement);
                }
                
                // Position and show the context menu
                contextMenu.style.left = `${containerPoint.x}px`;
                contextMenu.style.top = `${containerPoint.y}px`;
                contextMenu.style.display = 'block';
            }
            
            function addContextMenuItem(menu, id, iconClass, text, clickHandler) {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.id = id;
                item.innerHTML = `<i class="fas ${iconClass}"></i><span>${text}</span>`;
                item.addEventListener('click', clickHandler);
                menu.appendChild(item);
            }
            
            function hideContextMenu() {
                document.getElementById('context-menu').style.display = 'none';
                selectedElement = null;
            }
            
            function reversePitchDirection() {
                if (!selectedElement || selectedElement.type !== 'curbPitch') {
                    return;
                }
                
                // Get the line
                const line = selectedElement.element;
                
                // Reverse points
                const latlngs = line.getLatLngs();
                line.setLatLngs(latlngs.reverse());
                
                // Update direction
                line.options.direction = line.options.direction === 'forward' ? 'backward' : 'forward';
                
                // Remove old markers
                if (line.arrowMarker) {
                    curbPitchesLayer.removeLayer(line.arrowMarker);
                }
                
                if (line.labelMarker) {
                    curbPitchesLayer.removeLayer(line.labelMarker);
                }
                
                // Add new arrow and label
                addDirectionArrow(line);
                addPitchLabel(line);
                
                // Update segment data
                const segment = curbSegmentsWithPitch.find(s => 
                    (arePointsEqual(s.start, latlngs[0]) && arePointsEqual(s.end, latlngs[1])) ||
                    (arePointsEqual(s.start, latlngs[1]) && arePointsEqual(s.end, latlngs[0]))
                );
                
                if (segment) {
                    segment.direction = line.options.direction;
                }
                
                // Hide context menu
                hideContextMenu();
                
                // Update heatmap
                recalculateDrainageHeatmap();
                
                // Update status
                updateStatus('Pitch direction reversed');
            }
            
            function editPitch() {
                if (!selectedElement || selectedElement.type !== 'curbPitch') {
                    return;
                }
                
                // Get current pitch
                const line = selectedElement.element;
                pitchPercent = line.options.pitchPercent || 2.0;
                
                // Update pitch modal
                document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                
                // Show pitch modal in edit mode
                document.getElementById('pitch-modal').style.display = 'flex';
                
                // Hide context menu
                hideContextMenu();
            }
            
            function editUtility() {
                if (!selectedElement || (selectedElement.type !== 'utility' && selectedElement.type !== 'utilityLine')) {
                    return;
                }
                
                // Get utility data
                const utility = selectedElement.type === 'utility' ? 
                    selectedElement.element : 
                    selectedElement.element.utilityMarker;
                
                if (!utility) return;
                
                // Populate utility details modal
                document.getElementById('utility-type').value = utility.options.utilityType || 'water';
                
                // Set category
                const mainBtn = document.querySelector('[data-category="main"]');
                const serviceBtn = document.querySelector('[data-category="service"]');
                mainBtn.classList.remove('selected');
                serviceBtn.classList.remove('selected');
                
                if (utility.options.utilityCategory === 'main') {
                    mainBtn.classList.add('selected');
                } else {
                    serviceBtn.classList.add('selected');
                }
                
                document.getElementById('utility-size').value = utility.options.utilitySize || 4;
                document.getElementById('utility-depth').value = utility.options.utilityDepth || 3;
                
                // Indicate we're editing an existing utility
                document.getElementById('utility-details-modal').dataset.mode = 'edit';
                document.getElementById('utility-details-modal').dataset.utilityId = utility._leaflet_id;
                
                // Show details modal
                document.getElementById('utility-details-modal').style.display = 'flex';
                
                // Hide context menu
                hideContextMenu();
            }
            
            function deleteElement() {
                if (!selectedElement) return;
                
                // Delete based on element type
                if (selectedElement.type === 'curbPitch') {
                    // Remove arrow and label markers
                    if (selectedElement.element.arrowMarker) {
                        curbPitchesLayer.removeLayer(selectedElement.element.arrowMarker);
                    }
                    if (selectedElement.element.labelMarker) {
                        curbPitchesLayer.removeLayer(selectedElement.element.labelMarker);
                    }
                    
                    // Remove line
                    curbPitchesLayer.removeLayer(selectedElement.element);
                    
                    // Remove from segments with pitch
                    const latlngs = selectedElement.element.getLatLngs();
                    const index = curbSegmentsWithPitch.findIndex(s => 
                        (arePointsEqual(s.start, latlngs[0]) && arePointsEqual(s.end, latlngs[1])) ||
                        (arePointsEqual(s.start, latlngs[1]) && arePointsEqual(s.end, latlngs[0]))
                    );
                    
                    if (index !== -1) {
                        curbSegmentsWithPitch.splice(index, 1);
                    }
                    
                    // Recalculate gaps
                    findCurbGaps();
                    
                    // Update heatmap
                    recalculateDrainageHeatmap();
                    
                } else if (selectedElement.type === 'catchBasin') {
                    catchBasinsLayer.removeLayer(selectedElement.element);
                    
                    // Update heatmap
                    recalculateDrainageHeatmap();
                    
                } else if (selectedElement.type === 'utility') {
                    // Remove associated line if it exists
                    if (selectedElement.element.utilityLine) {
                        utilitiesLayer.removeLayer(selectedElement.element.utilityLine);
                    }
                    
                    utilitiesLayer.removeLayer(selectedElement.element);
                    
                } else if (selectedElement.type === 'utilityLine') {
                    // Remove associated marker if it exists
                    if (selectedElement.element.utilityMarker) {
                        utilitiesLayer.removeLayer(selectedElement.element.utilityMarker);
                    }
                    
                    utilitiesLayer.removeLayer(selectedElement.element);
                }
                
                // Hide context menu
                hideContextMenu();
                
                // Update status
                updateStatus('Element deleted');
            }
            
            function addDirectionArrow(line) {
                // Get line midpoint
                const latlngs = line.getLatLngs();
                const midIndex = Math.floor(latlngs.length / 2);
                const point1 = latlngs[midIndex > 0 ? midIndex - 1 : 0];
                const point2 = latlngs[midIndex];
                
                // Calculate angle
                const p1 = map.latLngToLayerPoint(point1);
                const p2 = map.latLngToLayerPoint(point2);
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                // Create SVG arrow icon
                const arrowSvg = `
                    <div class="pitch-arrow">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,2L4,12h5v8h6v-8h5L12,2z" style="fill: #ffcc00; transform: rotate(${angle}deg); transform-origin: center;"/>
                        </svg>
                    </div>
                `;
                
                const arrowIcon = L.divIcon({
                    html: arrowSvg,
                    className: '',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                // Create marker at middle of line
                const arrowMarker = L.marker(point2, {
                    icon: arrowIcon,
                    interactive: false
                }).addTo(curbPitchesLayer);
                
                // Store reference
                line.arrowMarker = arrowMarker;
            }
            
            function addPitchLabel(line) {
                // Get first point of line
                const latlngs = line.getLatLngs();
                const point = latlngs[0];
                
                // Create label icon
                const labelHtml = `
                    <div style="background-color: white; padding: 2px 6px; border-radius: 10px; font-weight: bold; font-size: 12px; border: 2px solid #ffcc00;">
                        ${line.options.pitchPercent.toFixed(1)}%
                    </div>
                `;
                
                const labelIcon = L.divIcon({
                    html: labelHtml,
                    className: '',
                    iconSize: [40, 24],
                    iconAnchor: [0, 12]
                });
                
                // Create marker at start of line
                const labelMarker = L.marker(point, {
                    icon: labelIcon,
                    interactive: false
                }).addTo(curbPitchesLayer);
                
                // Store reference
                line.labelMarker = labelMarker;
            }
            
            function addCatchBasin(latlng) {
                // Create catch basin icon
                const catchBasinIcon = L.divIcon({
                    html: '<div class="catch-basin-icon"><i class="fas fa-water"></i></div>',
                    className: '',
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
                
                // Create marker
                const marker = L.marker(latlng, {
                    icon: catchBasinIcon,
                    draggable: true
                }).addTo(catchBasinsLayer);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'catchBasin',
                    element: marker
                });
                
                // Setup context menu for marker
                marker.on('contextmenu', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showContextMenu(e, marker, 'catchBasin');
                });
                
                // Update status
                updateStatus('Catch basin added');
                
                // Update heatmap
                recalculateDrainageHeatmap();
            }
            
            function calculateEndPoint(startLatLng, angleDegrees, lengthPixels) {
                // Convert angle to radians
                const angleRadians = (angleDegrees - 90) * Math.PI / 180; // -90 to make 0 degrees point North
                
                // Get current map zoom and pixel coordinates
                const startPoint = map.latLngToLayerPoint(startLatLng);
                
                // Calculate end point in pixels
                const endX = startPoint.x + lengthPixels * Math.cos(angleRadians);
                const endY = startPoint.y + lengthPixels * Math.sin(angleRadians);
                
                // Convert back to LatLng
                return map.layerPointToLatLng(L.point(endX, endY));
            }
            
            function updateDirectionIndicator() {
                // Update the direction arrow in the modal
                const indicator = document.getElementById('direction-indicator');
                indicator.style.transform = `rotate(${utilityAngle}deg)`;
                
                // Update the line on the map
                if (tempUtilityMarker && tempUtilityLine) {
                    const startPoint = tempUtilityMarker.getLatLng();
                    const endPoint = calculateEndPoint(startPoint, utilityAngle, 30);
                    tempUtilityLine.setLatLngs([startPoint, endPoint]);
                }
            }
            
            function createUtilityIcon(type, isMain = false) {
                const bgColor = getUtilityColor(type);
                const iconClass = getUtilityIcon(type);
                
                let html = `<div class="utility-marker ${isMain ? 'main' : ''}" style="background-color: ${bgColor};" data-type="${type}">
                             <i class="fas fa-${iconClass}"></i>
                           </div>`;
                
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
            }
            
            function getUtilityIcon(type) {
                // Return appropriate Font Awesome icon based on utility type
                switch (type) {
                    case 'water': return 'tint';
                    case 'gas': return 'fire';
                    case 'electric': return 'bolt';
                    case 'sewer': return 'toilet';
                    case 'telecom': return 'phone';
                    default: return 'tools';
                }
            }
            
            function getUtilityColor(type) {
                // Return appropriate color based on utility type
                switch (type) {
                    case 'water': return 'var(--water-color)';
                    case 'gas': return 'var(--gas-color)';
                    case 'electric': return 'var(--electric-color)';
                    case 'sewer': return 'var(--sewer-color)';
                    case 'telecom': return 'var(--telecom-color)';
                    default: return 'var(--utility-primary)';
                }
            }
            
            function showUtilityInfo(marker) {
                // Get the utility data
                const data = marker.options;
                
                // Update info card contents
                document.getElementById('info-type').textContent = data.utilityType.charAt(0).toUpperCase() + data.utilityType.slice(1);
                document.getElementById('info-category').textContent = data.utilityCategory.charAt(0).toUpperCase() + data.utilityCategory.slice(1);
                document.getElementById('info-size').textContent = `${data.utilitySize} inches`;
                document.getElementById('info-depth').textContent = `${data.utilityDepth} feet`;
                document.getElementById('info-direction').textContent = getDirectionName(data.utilityDirection || 0);
                
                // Handle media if present
                const mediaContainer = document.getElementById('info-media-container');
                if (data.mediaData) {
                    // Determine if it's an image or video
                    if (data.mediaData.startsWith('data:image')) {
                        mediaContainer.innerHTML = `<img src="${data.mediaData}" alt="Utility photo">`;
                    } else if (data.mediaData.startsWith('data:video')) {
                        mediaContainer.innerHTML = `<video controls src="${data.mediaData}" style="width:100%"></video>`;
                    }
                    mediaContainer.style.display = 'block';
                } else {
                    mediaContainer.innerHTML = '';
                    mediaContainer.style.display = 'none';
                }
                
                // Position the info card
                const markerPoint = map.latLngToContainerPoint(marker.getLatLng());
                const infoCard = document.getElementById('utility-info-card');
                infoCard.style.left = `${markerPoint.x + 20}px`;
                infoCard.style.top = `${markerPoint.y - 100}px`;
                
                // Show the card
                infoCard.style.display = 'block';
                
                // Store reference to the selected utility
                selectedUtility = marker;
            }
            
            function hideUtilityInfo() {
                document.getElementById('utility-info-card').style.display = 'none';
                selectedUtility = null;
            }
            
            function getDirectionName(angle) {
                // Convert angle to compass direction
                const directions = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest'];
                const index = Math.round(angle / 45) % 8;
                return directions[index];
            }
            
            function finalizeUtilityFound() {
                // Get position and angle
                const position = tempUtilityMarker.getLatLng();
                
                // Save utility details
                const utilityData = {
                    type: document.getElementById('utility-type').value,
                    category: document.querySelector('#utility-details-modal [data-category].selected').getAttribute('data-category'),
                    size: parseInt(document.getElementById('utility-size').value) || 4,
                    depth: parseInt(document.getElementById('utility-depth').value) || 3,
                    direction: utilityAngle,
                    mediaData: null
                };
                
                // Process media if uploaded
                const mediaInput = document.getElementById('utility-media');
                if (mediaInput.files && mediaInput.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        utilityData.mediaData = e.target.result;
                        createUtilityFoundMarker(position, utilityData);
                    };
                    reader.readAsDataURL(mediaInput.files[0]);
                } else {
                    createUtilityFoundMarker(position, utilityData);
                }
                
                // Clean up temporary elements
                if (tempUtilityMarker) {
                    map.removeLayer(tempUtilityMarker);
                    tempUtilityMarker = null;
                }
                
                if (tempUtilityLine) {
                    map.removeLayer(tempUtilityLine);
                    tempUtilityLine = null;
                }
                
                // Reset media input
                document.getElementById('utility-media').value = '';
            }
            
            function createUtilityFoundMarker(position, data) {
                // Create utility marker
                const utilityMarker = L.marker(position, {
                    icon: createUtilityIcon(data.type, data.category === 'main'),
                    draggable: true,
                    utilityType: data.type,
                    utilityCategory: data.category,
                    utilitySize: data.size,
                    utilityDepth: data.depth,
                    utilityDirection: data.direction,
                    mediaData: data.mediaData
                }).addTo(utilitiesLayer);
                
                // Create direction line
                const endPoint = calculateEndPoint(position, data.direction, 30);
                const utilityLine = L.polyline([position, endPoint], {
                    color: getUtilityColor(data.type),
                    weight: data.category === 'main' ? 5 : 3,
                    opacity: 1,
                    className: `utility-line ${data.type} ${data.category}`,
                    utilityType: data.type,
                    utilityCategory: data.category,
                    utilitySize: data.size,
                    utilityDepth: data.depth,
                    mediaData: data.mediaData
                }).addTo(utilitiesLayer);
                
                // Link marker and line
                utilityMarker.utilityLine = utilityLine;
                utilityLine.utilityMarker = utilityMarker;
                
                // Add event handlers
                utilityMarker.on('click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showUtilityInfo(utilityMarker);
                });
                
                utilityMarker.on('contextmenu', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showContextMenu(e, utilityMarker, 'utility');
                });
                
                utilityMarker.on('drag', function(e) {
                    // Update line when marker is dragged
                    const newPos = e.target.getLatLng();
                    const newEnd = calculateEndPoint(newPos, data.direction, 30);
                    utilityLine.setLatLngs([newPos, newEnd]);
                });
                
                utilityLine.on('contextmenu', function(e) {
                    L.DomEvent.stopPropagation(e);
                    showContextMenu(e, utilityLine, 'utilityLine');
                });
                
                // Add to undo stack
                addToUndoStack({
                    type: 'utilityFound',
                    marker: utilityMarker,
                    line: utilityLine
                });
                
                // Update status
                updateStatus(`${data.type.charAt(0).toUpperCase() + data.type.slice(1)} utility found and recorded`);
            }
            
            function updateUtilityFilters() {
                // Apply filters to utility layer
                utilitiesLayer.eachLayer(function(layer) {
                    // Skip non-utility elements
                    if (!layer.options || !layer.options.utilityType) return;
                    
                    // Check if this utility should be visible
                    const typeVisible = utilityFilters.types.includes(layer.options.utilityType);
                    const categoryVisible = utilityFilters.categories.includes(layer.options.utilityCategory);
                    
                    if (typeVisible && categoryVisible) {
                        if (!layer._map) {
                            utilitiesLayer.addLayer(layer);
                        }
                    } else {
                        if (layer._map) {
                            utilitiesLayer.removeLayer(layer);
                        }
                    }
                });
            }
            
            function addToUndoStack(action) {
                undoStack.push(action);
                updateUndoButtonState();
            }
            
            function updateUndoButtonState() {
                const undoButton = document.getElementById('undo-btn');
                
                if (undoStack.length > 0) {
                    undoButton.style.opacity = '1';
                    undoButton.disabled = false;
                } else {
                    undoButton.style.opacity = '0.5';
                    undoButton.disabled = true;
                }
            }
            
            function undoLastAction() {
                if (undoStack.length === 0) return;
                
                const action = undoStack.pop();
                
                if (action.type === 'curbPitch') {
                    // Remove arrow and label markers
                    if (action.element.arrowMarker) {
                        curbPitchesLayer.removeLayer(action.element.arrowMarker);
                    }
                    if (action.element.labelMarker) {
                        curbPitchesLayer.removeLayer(action.element.labelMarker);
                    }
                    
                    // Remove line
                    curbPitchesLayer.removeLayer(action.element);
                    
                    // Remove from segments with pitch
                    const latlngs = action.element.getLatLngs();
                    const index = curbSegmentsWithPitch.findIndex(s => 
                        (arePointsEqual(s.start, latlngs[0]) && arePointsEqual(s.end, latlngs[1])) ||
                        (arePointsEqual(s.start, latlngs[1]) && arePointsEqual(s.end, latlngs[0]))
                    );
                    
                    if (index !== -1) {
                        curbSegmentsWithPitch.splice(index, 1);
                    }
                    
                    // Recalculate gaps
                    findCurbGaps();
                    
                    // Update heatmap
                    recalculateDrainageHeatmap();
                    
                } else if (action.type === 'catchBasin') {
                    catchBasinsLayer.removeLayer(action.element);
                    
                    // Update heatmap
                    recalculateDrainageHeatmap();
                    
                } else if (action.type === 'utility') {
                    // Remove from utilities layer
                    utilitiesLayer.removeLayer(action.element);
                    
                } else if (action.type === 'utilityFound') {
                    // Remove marker and line
                    utilitiesLayer.removeLayer(action.marker);
                    utilitiesLayer.removeLayer(action.line);
                    
                } else if (action.type === 'utilityConnection') {
                    // Remove new combined line
                    utilitiesLayer.removeLayer(action.newElement);
                    
                    // Restore original line
                    utilitiesLayer.addLayer(action.oldElement);
                }
                
                // Update undo button state
                updateUndoButtonState();
                
                // Update status
                updateStatus('Last action undone');
            }
            
            function clearDrainageData() {
                // Confirm
                if (!confirm('Are you sure you want to clear all drainage data?')) {
                    return;
                }
                
                // Clear all drainage layers
                curbPitchesLayer.clearLayers();
                catchBasinsLayer.clearLayers();
                
                // Clear curb segments with pitch
                curbSegmentsWithPitch = [];
                
                // Find gaps
                findCurbGaps();
                
                // Update heatmap
                recalculateDrainageHeatmap();
                
                // Clear undo stack
                undoStack = [];
                updateUndoButtonState();
                
                // Update status
                updateStatus('All drainage data cleared');
            }
            
            function clearUtilityData() {
                // Confirm
                if (!confirm('Are you sure you want to clear all utility data?')) {
                    return;
                }
                
                // Clear utilities layer
                utilitiesLayer.clearLayers();
                
                // Clear undo stack
                undoStack = [];
                updateUndoButtonState();
                
                // Update status
                updateStatus('All utility data cleared');
            }
            
            function cancelDrawing() {
                // Reset drawing state
                isDrawing = false;
                drawingPoints = [];
                
                // Remove temporary elements
                if (tempLine) {
                    map.removeLayer(tempLine);
                    tempLine = null;
                }
                
                if (tempUtilityMarker) {
                    map.removeLayer(tempUtilityMarker);
                    tempUtilityMarker = null;
                }
                
                if (tempUtilityLine) {
                    map.removeLayer(tempUtilityLine);
                    tempUtilityLine = null;
                }
                
                // Hide cancel button
                document.getElementById('cancel-action-btn').style.display = 'none';
                
                // Update status
                updateStatus('Drawing canceled');
            }
            
            function showNotification(message) {
                const notification = document.getElementById('notification');
                document.getElementById('notification-text').textContent = message;
                
                // Apply appropriate styling based on active mode
                notification.className = 'notification';
                notification.classList.add(activeMode);
                
                // Show notification
                notification.classList.add('visible');
                
                // Hide after delay
                setTimeout(() => {
                    notification.classList.remove('visible');
                }, 3000);
            }
            
            function updateStatus(message) {
                const statusBar = document.getElementById('status-bar');
                document.getElementById('status-text').textContent = message;
                
                // Apply appropriate styling based on active mode
                statusBar.className = 'status-bar';
                statusBar.classList.add(activeMode);
            }
            
            function switchMode(mode) {
                // Set new active mode
                activeMode = mode;
                
                // Reset active tool
                setActiveTool(null);
                
                // Show/hide appropriate toolbars
                document.getElementById('drainage-toolbar').classList.toggle('visible', mode === 'drainage');
                document.getElementById('utility-toolbar').classList.toggle('visible', mode === 'utility');
                
                // Show/hide appropriate menu sections
                document.querySelector('.drainage-section').style.display = mode === 'drainage' ? 'block' : 'none';
                document.querySelector('.utility-section').style.display = mode === 'utility' ? 'block' : 'none';
                
                // Update mode selector buttons
                document.getElementById('drainage-mode-btn').classList.toggle('active', mode === 'drainage');
                document.getElementById('utility-mode-btn').classList.toggle('active', mode === 'utility');
                
                // Update options title color
                document.getElementById('options-title').className = 'menu-section-title ' + mode;
                
                // Update toggle slider colors
                document.getElementById('snap-slider').className = 'toggle-slider ' + mode;
                
                // Update user marker color
                if (userMarker) {
                    userMarker.setStyle({
                        fillColor: mode === 'drainage' ? '#0099cc' : '#7e57c2'
                    });
                }
                
                // Update loading spinner color
                document.querySelector('.spinner').className = 'spinner ' + mode;
                
                // Show/hide layers based on mode
                if (mode === 'drainage') {
                    // Show drainage layers
                    if (!map.hasLayer(curbGuidesLayer)) map.addLayer(curbGuidesLayer);
                    if (!map.hasLayer(curbPitchesLayer)) map.addLayer(curbPitchesLayer);
                    if (!map.hasLayer(curbGapsLayer)) map.addLayer(curbGapsLayer);
                    if (!map.hasLayer(catchBasinsLayer)) map.addLayer(catchBasinsLayer);
                    
                    // Show heatmap if enabled
                    if (document.getElementById('heatmap-toggle').checked) {
                        if (drainageHeatLayer && !map.hasLayer(drainageHeatLayer)) {
                            map.addLayer(drainageHeatLayer);
                        }
                        document.getElementById('drainage-heat-legend').classList.add('visible');
                    }
                    
                    // Hide utility layers
                    if (map.hasLayer(utilitiesLayer)) map.removeLayer(utilitiesLayer);
                    
                    // Recalculate drainage heatmap
                    recalculateDrainageHeatmap();
                    
                } else {
                    // Show utility layers
                    if (!map.hasLayer(utilitiesLayer)) map.addLayer(utilitiesLayer);
                    
                    // Hide drainage layers
                    if (map.hasLayer(curbPitchesLayer)) map.removeLayer(curbPitchesLayer);
                    if (map.hasLayer(curbGapsLayer)) map.removeLayer(curbGapsLayer);
                    if (map.hasLayer(catchBasinsLayer)) map.removeLayer(catchBasinsLayer);
                    if (drainageHeatLayer && map.hasLayer(drainageHeatLayer)) {
                        map.removeLayer(drainageHeatLayer);
                    }
                    
                    // Optionally keep curb guides for reference
                    if (!document.getElementById('guide-toggle').checked && map.hasLayer(curbGuidesLayer)) {
                        map.removeLayer(curbGuidesLayer);
                    }
                    
                    // Hide heatmap legend
                    document.getElementById('drainage-heat-legend').classList.remove('visible');
                    
                    // Apply utility filters
                    updateUtilityFilters();
                }
                
                // Update status
                updateStatus(mode === 'drainage' ? 'Switched to Drainage Mode' : 'Switched to Utility Mode');
            }
            
            function setActiveTool(tool) {
                // Reset drawing state
                cancelDrawing();
                
                // Remove active class from all tools
                if (activeMode === 'drainage') {
                    document.querySelectorAll('#drainage-toolbar .tool-button').forEach(btn => {
                        btn.classList.remove('drainage-active');
                        btn.classList.remove('active');
                    });
                } else {
                    document.querySelectorAll('#utility-toolbar .tool-button').forEach(btn => {
                        btn.classList.remove('utility-active');
                        btn.classList.remove('active');
                    });
                }
                
                // Set new active tool
                activeTool = tool;
                
                if (tool) {
                    // Add active class to selected tool
                    const toolButton = document.getElementById(tool);
                    if (toolButton) {
                        toolButton.classList.add('active');
                        toolButton.classList.add(activeMode === 'drainage' ? 'drainage-active' : 'utility-active');
                    }
                    
                    // Set appropriate status message
                    if (tool === 'curb-pitch-tool') {
                        updateStatus('Click on a curb to start drawing a pitch line');
                    } else if (tool === 'catch-basin-tool') {
                        updateStatus('Click to place a catch basin');
                    } else if (tool === 'utility-found-tool') {
                        updateStatus('Click to mark a utility that was found');
                    } else if (tool === 'mapping-utility-tool') {
                        updateStatus('Click to start mapping a utility line');
                    }
                } else {
                    updateStatus('Select a tool to begin');
                }
            }
            
            function initUIHandlers() {
                // Mode switcher
                document.getElementById('drainage-mode-btn').addEventListener('click', function() {
                    switchMode('drainage');
                });
                
                document.getElementById('utility-mode-btn').addEventListener('click', function() {
                    switchMode('utility');
                });
                
                // Drainage toolbar buttons
                document.getElementById('curb-pitch-tool').addEventListener('click', function() {
                    setActiveTool('curb-pitch-tool');
                });
                
                document.getElementById('catch-basin-tool').addEventListener('click', function() {
                    setActiveTool('catch-basin-tool');
                });
                
                document.getElementById('clear-drainage-tool').addEventListener('click', clearDrainageData);
                
                // Utility toolbar buttons
                document.getElementById('utility-found-tool').addEventListener('click', function() {
                    setActiveTool('utility-found-tool');
                });
                
                document.getElementById('mapping-utility-tool').addEventListener('click', function() {
                    // Show utility preset options first
                    setActiveTool('mapping-utility-tool');
                });
                
                document.getElementById('clear-utility-tool').addEventListener('click', clearUtilityData);
                
                // Action buttons
                document.getElementById('locate-btn').addEventListener('click', function() {
                    if (currentPosition) {
                        map.setView(currentPosition, 19);
                    } else {
                        getUserLocation();
                    }
                });
                
                document.getElementById('undo-btn').addEventListener('click', undoLastAction);
                
                document.getElementById('menu-btn').addEventListener('click', function() {
                    document.getElementById('menu-panel').classList.toggle('visible');
                });
                
                document.getElementById('help-btn').addEventListener('click', function() {
                    alert('Help functionality would be shown here.');
                });
                
                // Cancel button
                document.getElementById('cancel-action-btn').addEventListener('click', cancelDrawing);
                
                // Zoom controls
                document.getElementById('zoom-in-btn').addEventListener('click', function() {
                    map.zoomIn(1);
                });
                
                document.getElementById('zoom-out-btn').addEventListener('click', function() {
                    map.zoomOut(1);
                });
                
                // Menu panel close
                document.querySelector('.menu-panel-close').addEventListener('click', function() {
                    document.getElementById('menu-panel').classList.remove('visible');
                });
                
                // Layer toggles
                document.getElementById('heatmap-toggle').addEventListener('change', function() {
                    if (activeMode === 'drainage') {
                        if (this.checked) {
                            if (drainageHeatLayer && !map.hasLayer(drainageHeatLayer)) {
                                map.addLayer(drainageHeatLayer);
                            }
                            document.getElementById('drainage-heat-legend').classList.add('visible');
                        } else {
                            if (drainageHeatLayer && map.hasLayer(drainageHeatLayer)) {
                                map.removeLayer(drainageHeatLayer);
                            }
                            document.getElementById('drainage-heat-legend').classList.remove('visible');
                        }
                    }
                });
                
                document.getElementById('curb-toggle').addEventListener('change', function() {
                    if (this.checked) {
                        if (!map.hasLayer(curbPitchesLayer)) map.addLayer(curbPitchesLayer);
                    } else {
                        if (map.hasLayer(curbPitchesLayer)) map.removeLayer(curbPitchesLayer);
                    }
                });
                
                document.getElementById('basin-toggle').addEventListener('change', function() {
                    if (this.checked) {
                        if (!map.hasLayer(catchBasinsLayer)) map.addLayer(catchBasinsLayer);
                    } else {
                        if (map.hasLayer(catchBasinsLayer)) map.removeLayer(catchBasinsLayer);
                    }
                    
                    // Update heatmap
                    recalculateDrainageHeatmap();
                });
                
                document.getElementById('guide-toggle').addEventListener('change', function() {
                    if (this.checked) {
                        if (!map.hasLayer(curbGuidesLayer)) map.addLayer(curbGuidesLayer);
                        if (!map.hasLayer(curbGapsLayer) && activeMode === 'drainage') map.addLayer(curbGapsLayer);
                    } else {
                        if (map.hasLayer(curbGuidesLayer)) map.removeLayer(curbGuidesLayer);
                        if (map.hasLayer(curbGapsLayer)) map.removeLayer(curbGapsLayer);
                    }
                });
                
                // Snap toggle
                document.getElementById('snap-toggle').addEventListener('change', function() {
                    snapEnabled = this.checked;
                });
                
                // Utility filter buttons
                document.querySelectorAll('#utility-type-filters .filter-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const type = this.getAttribute('data-type');
                        this.classList.toggle('active');
                        
                        if (this.classList.contains('active')) {
                            // Add type to filters
                            if (!utilityFilters.types.includes(type)) {
                                utilityFilters.types.push(type);
                            }
                        } else {
                            // Remove type from filters
                            const index = utilityFilters.types.indexOf(type);
                            if (index !== -1) {
                                utilityFilters.types.splice(index, 1);
                            }
                        }
                        
                        // Update utility visibility
                        updateUtilityFilters();
                    });
                });
                
                document.querySelectorAll('#utility-category-filters .filter-button').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const category = this.getAttribute('data-category');
                        this.classList.toggle('active');
                        
                        if (this.classList.contains('active')) {
                            // Add category to filters
                            if (!utilityFilters.categories.includes(category)) {
                                utilityFilters.categories.push(category);
                            }
                        } else {
                            // Remove category from filters
                            const index = utilityFilters.categories.indexOf(category);
                            if (index !== -1) {
                                utilityFilters.categories.splice(index, 1);
                            }
                        }
                        
                        // Update utility visibility
                        updateUtilityFilters();
                    });
                });
                
                // Pitch Modal
                document.getElementById('increase-pitch').addEventListener('click', function() {
                    pitchPercent = Math.min(10, pitchPercent + 0.1);
                    document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                });
                
                document.getElementById('decrease-pitch').addEventListener('click', function() {
                    pitchPercent = Math.max(0.1, pitchPercent - 0.1);
                    document.getElementById('pitch-value').textContent = pitchPercent.toFixed(1) + '%';
                });
                
                document.getElementById('close-pitch-modal').addEventListener('click', function() {
                    document.getElementById('pitch-modal').style.display = 'none';
                    cancelDrawing();
                });
                
                document.getElementById('cancel-pitch').addEventListener('click', function() {
                    document.getElementById('pitch-modal').style.display = 'none';
                    cancelDrawing();
                });
                
                document.getElementById('confirm-pitch').addEventListener('click', function() {
                    document.getElementById('pitch-modal').style.display = 'none';
                    
                    // Check if we're in edit mode
                    if (selectedElement && selectedElement.type === 'curbPitch') {
                        // Update existing pitch
                        const line = selectedElement.element;
                        line.options.pitchPercent = pitchPercent;
                        
                        // Update label
                        if (line.labelMarker) {
                            curbPitchesLayer.removeLayer(line.labelMarker);
                        }
                        addPitchLabel(line);
                        
                        // Update segment data
                        const latlngs = line.getLatLngs();
                        const segment = curbSegmentsWithPitch.find(s => 
                            (arePointsEqual(s.start, latlngs[0]) && arePointsEqual(s.end, latlngs[1])) ||
                            (arePointsEqual(s.start, latlngs[1]) && arePointsEqual(s.end, latlngs[0]))
                        );
                        
                        if (segment) {
                            segment.pitchPercent = pitchPercent;
                        }
                        
                        // Update heatmap
                        recalculateDrainageHeatmap();
                        
                        updateStatus('Pitch updated to ' + pitchPercent.toFixed(1) + '%');
                        selectedElement = null;
                    } else {
                        // Finalize new pitch
                        finalizeCurbPitch();
                    }
                });
                
                // Gap Treatment Modal
                document.querySelectorAll('#gap-options .option-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        // Update selected option
                        document.querySelectorAll('#gap-options .option-btn').forEach(b => {
                            b.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        
                        // Get selected option
                        selectedGapOption = this.getAttribute('data-option');
                        
                        // Show/hide relevant controls
                        document.getElementById('pitch-option-controls').style.display = 
                            selectedGapOption === 'pitch' ? 'block' : 'none';
                    });
                });
                
                document.querySelectorAll('[data-direction]').forEach(btn => {
                    btn.addEventListener('click', function() {
                        // Update selected direction
                        document.querySelectorAll('[data-direction]').forEach(b => {
                            b.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        
                        // Get selected direction
                        gapPitchDirection = this.getAttribute('data-direction');
                    });
                });
                
                document.getElementById('increase-gap-pitch').addEventListener('click', function() {
                    gapPitchPercent = Math.min(10, gapPitchPercent + 0.1);
                    document.getElementById('gap-pitch-value').textContent = gapPitchPercent.toFixed(1) + '%';
                });
                
                document.getElementById('decrease-gap-pitch').addEventListener('click', function() {
                    gapPitchPercent = Math.max(0.1, gapPitchPercent - 0.1);
                    document.getElementById('gap-pitch-value').textContent = gapPitchPercent.toFixed(1) + '%';
                });
                
                document.getElementById('close-gap-modal').addEventListener('click', function() {
                    document.getElementById('gap-treatment-modal').style.display = 'none';
                    selectedGap = null;
                });
                
                document.getElementById('cancel-gap-treatment').addEventListener('click', function() {
                    document.getElementById('gap-treatment-modal').style.display = 'none';
                    selectedGap = null;
                });
                
                document.getElementById('confirm-gap-treatment').addEventListener('click', function() {
                    document.getElementById('gap-treatment-modal').style.display = 'none';
                    handleGapTreatment();
                });
                
                // Utility Direction Modal
                document.getElementById('rotate-left').addEventListener('click', function() {
                    utilityAngle = (utilityAngle - 15) % 360;
                    if (utilityAngle < 0) utilityAngle += 360;
                    updateDirectionIndicator();
                });
                
                document.getElementById('rotate-right').addEventListener('click', function() {
                    utilityAngle = (utilityAngle + 15) % 360;
                    updateDirectionIndicator();
                });
                
                document.getElementById('close-utility-found-modal').addEventListener('click', function() {
                    cancelUtilityDirection();
                });
                
                document.getElementById('cancel-utility-direction').addEventListener('click', function() {
                    cancelUtilityDirection();
                });
                
                document.getElementById('confirm-utility-direction').addEventListener('click', function() {
                    document.getElementById('utility-found-modal').style.display = 'none';
                    document.getElementById('utility-details-modal').style.display = 'flex';
                });
                
                function cancelUtilityDirection() {
                    // Hide modal
                    document.getElementById('utility-found-modal').style.display = 'none';
                    
                    // Cancel drawing
                    cancelDrawing();
                }
                
                // Utility Details Modal
                document.getElementById('close-utility-details-modal').addEventListener('click', function() {
                    document.getElementById('utility-details-modal').style.display = 'none';
                    cancelDrawing();
                });
                
                document.getElementById('cancel-utility-details').addEventListener('click', function() {
                    document.getElementById('utility-details-modal').style.display = 'none';
                    cancelDrawing();
                });
                
                document.getElementById('confirm-utility-details').addEventListener('click', function() {
                    document.getElementById('utility-details-modal').style.display = 'none';
                    
                    // Check if we're in edit mode
                    if (document.getElementById('utility-details-modal').dataset.mode === 'edit') {
                        // Get the utility ID
                        const utilityId = parseInt(document.getElementById('utility-details-modal').dataset.utilityId);
                        
                        // Find the utility
                        let utility = null;
                        utilitiesLayer.eachLayer(function(layer) {
                            if (layer._leaflet_id === utilityId) {
                                utility = layer;
                            }
                        });
                        
                        if (utility) {
                            // Update utility properties
                            updateUtilityProperties(utility);
                        }
                        
                        // Reset mode
                        document.getElementById('utility-details-modal').dataset.mode = '';
                        document.getElementById('utility-details-modal').dataset.utilityId = '';
                    } else {
                        // Save utility type and category as presets
                        utilityPresets.type = document.getElementById('utility-type').value;
                        utilityPresets.category = document.querySelector('[data-category].selected').getAttribute('data-category');
                        utilityPresets.size = parseInt(document.getElementById('utility-size').value) || 4;
                        utilityPresets.depth = parseInt(document.getElementById('utility-depth').value) || 3;
                        
                        // Complete utility found process
                        finalizeUtilityFound();
                    }
                });
                
                document.querySelectorAll('[data-category]').forEach(btn => {
                    btn.addEventListener('click', function() {
                        // Update selected category
                        document.querySelectorAll('[data-category]').forEach(b => {
                            b.classList.remove('selected');
                        });
                        this.classList.add('selected');
                    });
                });
                
                // Utility Connection Modal
                document.querySelectorAll('#connection-options .option-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        // Update selected option
                        document.querySelectorAll('#connection-options .option-btn').forEach(b => {
                            b.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        
                        // Get selected option
                        selectedConnectionOption = this.getAttribute('data-option');
                    });
                });
                
                document.getElementById('close-connection-modal').addEventListener('click', function() {
                    document.getElementById('utility-connection-modal').style.display = 'none';
                    connectionStartUtility = null;
                    cancelDrawing();
                });
                
                document.getElementById('cancel-connection').addEventListener('click', function() {
                    document.getElementById('utility-connection-modal').style.display = 'none';
                    connectionStartUtility = null;
                    cancelDrawing();
                });
                
                document.getElementById('confirm-connection').addEventListener('click', function() {
                    document.getElementById('utility-connection-modal').style.display = 'none';
                    finalizeUtilityLine();
                });
                
                // Utility Info Card
                document.querySelector('.utility-info-close').addEventListener('click', hideUtilityInfo);
                
                // Hide utility info card when map is clicked
                map.on('click', hideUtilityInfo);
                
                // Initialize undo button state
                updateUndoButtonState();
            }
            
            function updateUtilityProperties(utility) {
                // Get new properties
                const newType = document.getElementById('utility-type').value;
                const newCategory = document.querySelector('[data-category].selected').getAttribute('data-category');
                const newSize = parseInt(document.getElementById('utility-size').value) || 4;
                const newDepth = parseInt(document.getElementById('utility-depth').value) || 3;
                
                // Update utility options
                utility.options.utilityType = newType;
                utility.options.utilityCategory = newCategory;
                utility.options.utilitySize = newSize;
                utility.options.utilityDepth = newDepth;
                
                // Update icon if it's a marker
                if (utility instanceof L.Marker) {
                    utility.setIcon(createUtilityIcon(newType, newCategory === 'main'));
                    
                    // Update associated line if exists
                    if (utility.utilityLine) {
                        const line = utility.utilityLine;
                        line.options.utilityType = newType;
                        line.options.utilityCategory = newCategory;
                        line.options.utilitySize = newSize;
                        line.options.utilityDepth = newDepth;
                        
                        // Update line style
                        line.setStyle({
                            color: getUtilityColor(newType),
                            weight: newCategory === 'main' ? 5 : 3,
                            dashArray: newCategory === 'service' ? '5,3' : null
                        });
                        
                        // Update class name
                        const path = line._path;
                        if (path) {
                            path.classList.remove('water', 'gas', 'electric', 'sewer', 'telecom', 'main', 'service');
                            path.classList.add(newType, newCategory);
                        }
                    }
                } else if (utility instanceof L.Polyline) {
                    // Update line style
                    utility.setStyle({
                        color: getUtilityColor(newType),
                        weight: newCategory === 'main' ? 5 : 3,
                        dashArray: newCategory === 'service' ? '5,3' : null
                    });
                    
                    // Update class name
                    const path = utility._path;
                    if (path) {
                        path.classList.remove('water', 'gas', 'electric', 'sewer', 'telecom', 'main', 'service');
                        path.classList.add(newType, newCategory);
                    }
                    
                    // Update associated marker if exists
                    if (utility.utilityMarker) {
                        const marker = utility.utilityMarker;
                        marker.options.utilityType = newType;
                        marker.options.utilityCategory = newCategory;
                        marker.options.utilitySize = newSize;
                        marker.options.utilityDepth = newDepth;
                        
                        marker.setIcon(createUtilityIcon(newType, newCategory === 'main'));
                    }
                }
                
                // Update status
                updateStatus('Utility details updated');
                
                // Update info card if this utility is selected
                if (selectedUtility === utility || 
                    (selectedUtility && selectedUtility.utilityLine === utility) || 
                    (utility.utilityMarker === selectedUtility)) {
                    showUtilityInfo(utility instanceof L.Marker ? utility : utility.utilityMarker);
                }
            }
        }
    });
    </script>
</body>
</html>
