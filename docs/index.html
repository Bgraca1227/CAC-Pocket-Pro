<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC UtilityPro</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
    
    <style>
        /* ============ Root Variables ============ */
        :root {
            /* Primary Colors */
            --primary-color: #2196f3;
            --primary-light: #64b5f6;
            --primary-dark: #1976d2;
            --primary-gradient: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            
            /* Secondary Colors */
            --secondary-color: #673ab7;
            --secondary-light: #9575cd;
            --secondary-dark: #512da8;
            
            /* Accent Colors */
            --accent-color: #ff4081;
            --accent-light: #ff80ab;
            --accent-dark: #c51162;
            
            /* UI Colors */
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            --info-color: #2196f3;
            
            /* Utility type colors */
            --water-color: #03a9f4;
            --gas-color: #ff9800;
            --electric-color: #ffeb3b;
            --sewer-color: #795548;
            --telecom-color: #9c27b0;
            
            /* Grayscale */
            --white: #ffffff;
            --gray-50: #fafafa;
            --gray-100: #f5f5f5;
            --gray-200: #eeeeee;
            --gray-300: #e0e0e0;
            --gray-400: #bdbdbd;
            --gray-500: #9e9e9e;
            --gray-600: #757575;
            --gray-700: #616161;
            --gray-800: #424242;
            --gray-900: #212121;
            --black: #000000;
            
            /* Background and Text */
            --background-color: var(--white);
            --surface-color: var(--gray-50);
            --text-primary: var(--gray-900);
            --text-secondary: var(--gray-700);
            --text-disabled: var(--gray-500);
            
            /* Effects */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            
            /* Radii */
            --radius-sm: 0.25rem;
            --radius-md: 0.5rem;
            --radius-lg: 1rem;
            --radius-xl: 1.5rem;
            --radius-full: 9999px;
            
            /* Dimensions */
            --header-height: 60px;
            --toolbar-height: 64px;
            --bottom-bar-height: 72px;
            --action-button-size: 56px;
            --control-button-size: 48px;
            --icon-button-size: 40px;
            
            /* Animation */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.6s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* ============ Reset & Base Styles ============ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-primary);
            position: fixed;
        }

        button {
            cursor: pointer;
            border: none;
            outline: none;
            background: none;
            font: inherit;
            color: inherit;
        }

        input, select, textarea {
            font: inherit;
            border: none;
            outline: none;
            color: inherit;
        }

        ul, ol {
            list-style: none;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        /* ============ Layout ============ */
        .app-container {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        #map {
            flex: 1;
            width: 100%;
            position: relative;
            z-index: 1;
            background-color: var(--gray-100);
        }

        /* ============ Header ============ */
        .header {
            height: var(--header-height);
            width: 100%;
            background: var(--primary-gradient);
            color: var(--white);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            position: relative;
            z-index: 10;
            box-shadow: var(--shadow-md);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
            font-size: 20px;
        }

        .logo-icon {
            font-size: 24px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-button {
            width: var(--icon-button-size);
            height: var(--icon-button-size);
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            position: relative;
        }

        .header-button:active {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* ============ Mode Switcher ============ */
        .mode-switcher {
            position: absolute;
            top: calc(var(--header-height) + 12px);
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            display: flex;
            background-color: var(--white);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            padding: 2px;
        }

        .mode-button {
            padding: 8px 16px;
            font-weight: 600;
            font-size: 14px;
            border-radius: var(--radius-full);
            transition: var(--transition-normal);
            position: relative;
            z-index: 2;
            min-width: 100px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .mode-button.active {
            color: var(--white);
        }

        .mode-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            height: calc(100% - 4px);
            border-radius: var(--radius-full);
            background: var(--primary-gradient);
            transition: var(--transition-normal);
            z-index: 1;
        }

        /* ============ Bottom Action Bar ============ */
        .bottom-bar {
            height: var(--bottom-bar-height);
            background-color: var(--white);
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-around;
            position: relative;
            z-index: 10;
        }

        .utility-selector {
            position: absolute;
            bottom: var(--bottom-bar-height);
            left: 0;
            right: 0;
            background-color: var(--white);
            display: flex;
            justify-content: space-around;
            padding: 8px 0;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            transform: translateY(100%);
            transition: var(--transition-normal);
            z-index: 9;
        }

        .utility-selector.visible {
            transform: translateY(0);
        }

        .utility-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px;
            border-radius: var(--radius-md);
            transition: var(--transition-fast);
            position: relative;
            min-width: 64px;
        }

        .utility-button:active {
            background-color: var(--gray-100);
        }

        .utility-icon {
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .utility-label {
            font-size: 12px;
            font-weight: 500;
        }

        .utility-button.water .utility-icon {
            color: var(--water-color);
        }

        .utility-button.gas .utility-icon {
            color: var(--gas-color);
        }

        .utility-button.electric .utility-icon {
            color: var(--electric-color);
        }

        .utility-button.sewer .utility-icon {
            color: var(--sewer-color);
        }

        .utility-button.telecom .utility-icon {
            color: var(--telecom-color);
        }

        .utility-button.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 20%;
            right: 20%;
            height: 3px;
            background-color: currentColor;
            border-radius: var(--radius-full);
        }

        .action-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 4px 12px;
            border-radius: var(--radius-md);
            transition: var(--transition-fast);
            position: relative;
        }

        .action-button:active {
            background-color: var(--gray-100);
        }

        .action-button.active {
            color: var(--primary-color);
        }

        .action-icon {
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-label {
            font-size: 12px;
            font-weight: 500;
        }

        /* ============ FAB Button ============ */
        .fab {
            position: absolute;
            bottom: calc(var(--bottom-bar-height) + 16px);
            right: 16px;
            width: var(--action-button-size);
            height: var(--action-button-size);
            border-radius: var(--radius-full);
            background: var(--primary-gradient);
            color: var(--white);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-lg);
            z-index: 20;
            transition: var(--transition-normal);
        }

        .fab:active {
            transform: scale(0.95);
            box-shadow: var(--shadow-md);
        }

        .fab-icon {
            font-size: 24px;
            transition: var(--transition-normal);
        }

        .fab.editing {
            background: var(--success-color);
            transform: rotate(45deg);
        }

        .fab.editing .fab-icon {
            transform: rotate(-45deg);
        }

        /* ============ Status Bar ============ */
        .status-bar {
            position: absolute;
            bottom: calc(var(--bottom-bar-height) + 80px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--white);
            border-radius: var(--radius-full);
            padding: 8px 16px;
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            max-width: 80%;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-normal);
            z-index: 15;
        }

        .status-bar.visible {
            opacity: 1;
        }

        .status-icon {
            color: var(--primary-color);
            font-size: 16px;
        }

        /* ============ Side Controls ============ */
        .side-controls {
            position: absolute;
            right: 16px;
            top: calc(var(--header-height) + 120px);
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 12;
        }

        .control-button {
            width: var(--control-button-size);
            height: var(--control-button-size);
            border-radius: var(--radius-full);
            background-color: var(--white);
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
            transition: var(--transition-fast);
        }

        .control-button:active {
            transform: scale(0.95);
            box-shadow: var(--shadow-sm);
        }

        .control-button.active {
            background-color: var(--primary-color);
            color: var(--white);
        }

        /* ============ Dialog & Modals ============ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-normal);
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background-color: var(--white);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            transform: translateY(20px);
            transition: transform var(--transition-normal);
            overflow: hidden;
        }

        .modal-overlay.visible .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--gray-200);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-full);
            color: var(--text-secondary);
        }

        .modal-close:active {
            background-color: var(--gray-100);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--gray-200);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn {
            padding: 10px 16px;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 14px;
            transition: var(--transition-fast);
        }

        .btn-text {
            color: var(--primary-color);
        }

        .btn-text:active {
            background-color: var(--gray-100);
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--white);
        }

        .btn-primary:active {
            background-color: var(--primary-dark);
        }

        .btn-success {
            background-color: var(--success-color);
            color: var(--white);
        }

        .btn-success:active {
            background-color: var(--success-color);
            opacity: 0.9;
        }

        /* ============ Form Elements ============ */
        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-control {
            width: 100%;
            padding: 10px 16px;
            border: 1px solid var(--gray-300);
            border-radius: var(--radius-md);
            background-color: var(--white);
            font-size: 16px;
            transition: var(--transition-fast);
        }

        .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        .select-container {
            position: relative;
        }

        .select-container::after {
            content: '\f078';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text-secondary);
            font-size: 12px;
        }

        select.form-control {
            appearance: none;
            padding-right: 32px;
        }

        .radio-group, .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .radio-item, .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Custom radio and checkbox styling */
        .radio-item input[type="radio"],
        .checkbox-item input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .radio-control, .checkbox-control {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
            cursor: pointer;
            user-select: none;
            padding: 4px 0;
        }

        .radio-control:before, .checkbox-control:before {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--gray-400);
            transition: var(--transition-fast);
        }

        .radio-control:before {
            border-radius: 50%;
        }

        .checkbox-control:before {
            border-radius: var(--radius-sm);
        }

        .radio-item input[type="radio"]:checked + .radio-control:before {
            border-color: var(--primary-color);
            background-color: var(--white);
            box-shadow: inset 0 0 0 5px var(--primary-color);
        }

        .checkbox-item input[type="checkbox"]:checked + .checkbox-control:before {
            border-color: var(--primary-color);
            background-color: var(--primary-color);
        }

        .checkbox-item input[type="checkbox"]:checked + .checkbox-control:after {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            left: 5px;
            top: 4px;
            font-size: 12px;
            color: var(--white);
        }

        /* Slider/Range input */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--gray-300);
            border-radius: var(--radius-full);
            outline: none;
            margin: 12px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid var(--white);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: 2px solid var(--white);
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
        }

        .range-value {
            display: flex;
            justify-content: space-between;
            margin-top: -8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* File input */
        .file-input {
            display: none;
        }

        .file-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px dashed var(--gray-400);
            border-radius: var(--radius-md);
            background-color: var(--gray-50);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .file-control:hover, .file-control:focus {
            border-color: var(--primary-color);
            background-color: rgba(33, 150, 243, 0.05);
        }

        .file-control i {
            font-size: 24px;
            color: var(--gray-500);
        }

        .file-control-text {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .file-preview {
            margin-top: 8px;
            display: none;
        }

        .file-preview.visible {
            display: block;
        }

        .file-preview img {
            width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }

        /* ============ Option Selector ============ */
        .option-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .option-item {
            flex: 1;
            min-width: 100px;
            background-color: var(--gray-100);
            border-radius: var(--radius-md);
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition-fast);
            border: 2px solid transparent;
        }

        .option-item:active {
            transform: scale(0.98);
        }

        .option-item.selected {
            border-color: var(--primary-color);
            background-color: rgba(33, 150, 243, 0.05);
        }

        .option-icon {
            font-size: 24px;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .option-item.selected .option-icon {
            color: var(--primary-color);
        }

        .option-label {
            font-weight: 500;
            font-size: 14px;
        }

        /* ============ Map Elements ============ */
        .utility-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--white);
            box-shadow: var(--shadow-md);
            border: 3px solid;
            color: var(--white);
            font-size: 16px;
            position: relative;
            transition: transform 0.2s ease;
        }

        .utility-marker.water {
            border-color: var(--water-color);
            background-color: var(--water-color);
        }

        .utility-marker.gas {
            border-color: var(--gas-color);
            background-color: var(--gas-color);
        }

        .utility-marker.electric {
            border-color: var(--electric-color);
            background-color: var(--electric-color);
            color: var(--text-primary);
        }

        .utility-marker.sewer {
            border-color: var(--sewer-color);
            background-color: var(--sewer-color);
        }

        .utility-marker.telecom {
            border-color: var(--telecom-color);
            background-color: var(--telecom-color);
        }

        .utility-marker.main::after {
            content: 'M';
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            font-size: 10px;
            font-weight: bold;
            background-color: var(--white);
            color: var(--text-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
        }

        .structure-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 3px;
            background-color: var(--white);
            box-shadow: var(--shadow-md);
            border: 3px solid var(--gray-700);
            color: var(--gray-700);
            font-size: 16px;
            transition: transform 0.2s ease;
        }

        .structure-marker.manhole {
            border-color: var(--sewer-color);
            color: var(--sewer-color);
            border-radius: 50%;
        }

        .structure-marker.catch-basin {
            border-color: var(--sewer-color);
            color: var(--sewer-color);
            border-radius: 10%;
        }

        .structure-marker.electrical-box {
            border-color: var(--electric-color);
            color: var(--electric-color);
        }

        .structure-marker.valve {
            border-color: var(--water-color);
            color: var(--water-color);
            border-radius: 50%;
        }

        .control-point {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: var(--white);
            border: 2px solid var(--primary-color);
            box-shadow: var(--shadow-sm);
        }

        .utility-line {
            stroke-width: 4;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            transition: stroke-width 0.2s ease;
        }

        .utility-line.water {
            stroke: var(--water-color);
        }

        .utility-line.gas {
            stroke: var(--gas-color);
        }

        .utility-line.electric {
            stroke: var(--electric-color);
        }

        .utility-line.sewer {
            stroke: var(--sewer-color);
        }

        .utility-line.telecom {
            stroke: var(--telecom-color);
        }

        .utility-line.main {
            stroke-width: 6;
        }

        .utility-line.selected {
            stroke-dasharray: 8, 4;
            animation: dash 30s linear infinite;
        }

        .utility-line.temp {
            stroke-dasharray: 5, 5;
        }

        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }

        /* ============ Info Card ============ */
        .info-card {
            position: absolute;
            background-color: var(--white);
            border-radius: var(--radius-lg);
            padding: 16px;
            box-shadow: var(--shadow-lg);
            z-index: 30;
            max-width: 90%;
            width: 300px;
            transform-origin: top center;
            transition: all var(--transition-normal);
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            pointer-events: none;
        }

        .info-card.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
        }

        .info-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--gray-200);
        }

        .info-card-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-card-close {
            color: var(--text-secondary);
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius-full);
            background-color: var(--gray-100);
        }

        .info-card-body {
            margin-bottom: 12px;
        }

        .info-data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .info-label {
            font-size: 14px;
            color: var(--text-secondary);
            flex: 1;
        }

        .info-value {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            flex: 2;
            text-align: right;
        }

        .info-card-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .info-btn {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: var(--radius-md);
            background-color: var(--gray-100);
            color: var(--text-primary);
        }

        .info-btn-primary {
            background-color: var(--primary-color);
            color: var(--white);
        }

        .info-image {
            margin-top: 12px;
            width: 100%;
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .info-image img {
            width: 100%;
            height: auto;
            display: block;
        }

        /* ============ Toolbar ============ */
        .toolbar {
            position: absolute;
            bottom: calc(var(--bottom-bar-height) + 16px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--white);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 8px;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: all var(--transition-normal);
        }

        .toolbar.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .toolbar-button {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-full);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            position: relative;
        }

        .toolbar-button:active {
            background-color: var(--gray-100);
        }

        .toolbar-button.active {
            color: var(--primary-color);
            background-color: var(--gray-100);
        }

        /* ============ Measurements ============ */
        .measurement-line {
            stroke: var(--primary-color);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
        }

        .measurement-tooltip {
            background-color: var(--white);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: 4px 8px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--gray-200);
        }

        .measurement-point {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--primary-color);
            border: 2px solid var(--white);
            box-shadow: var(--shadow-sm);
        }

        /* ============ Annotation ============ */
        .annotation-label {
            background-color: var(--white);
            color: var(--text-primary);
            border-radius: var(--radius-md);
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--gray-200);
            display: flex;
            align-items: center;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .annotation-icon {
            margin-right: 4px;
            font-size: 10px;
            color: var(--primary-color);
        }

        /* ============ Notifications ============ */
        .notification {
            position: fixed;
            top: calc(var(--header-height) + 16px);
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background-color: var(--gray-900);
            color: var(--white);
            border-radius: var(--radius-md);
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            z-index: 90;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 90%;
        }

        .notification.visible {
            transform: translateX(-50%) translateY(0);
        }

        .notification i {
            font-size: 16px;
        }

        .notification.info i {
            color: var(--info-color);
        }

        .notification.success i {
            color: var(--success-color);
        }

        .notification.warning i {
            color: var(--warning-color);
        }

        .notification.error i {
            color: var(--error-color);
        }

        /* ============ Loading Spinner ============ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-normal);
        }

        .loading-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(33, 150, 243, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ============ Context Menu ============ */
        .context-menu {
            position: absolute;
            background-color: var(--white);
            border-radius: var(--radius-md);
            min-width: 160px;
            box-shadow: var(--shadow-lg);
            padding: 8px 0;
            z-index: 40;
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
            transition: all var(--transition-fast);
            transform-origin: top left;
        }

        .context-menu.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            font-size: 14px;
            color: var(--text-primary);
            gap: 12px;
            transition: var(--transition-fast);
        }

        .context-menu-item:active {
            background-color: var(--gray-100);
        }

        .context-menu-item i {
            width: 16px;
            color: var(--text-secondary);
        }

        .context-menu-divider {
            height: 1px;
            background-color: var(--gray-200);
            margin: 6px 0;
        }

        .context-menu-item.danger {
            color: var(--error-color);
        }

        .context-menu-item.danger i {
            color: var(--error-color);
        }

        /* ============ High Precision Editor ============ */
        .precision-editor {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.4);
            z-index: 25;
            display: none;
        }

        .precision-editor.active {
            display: block;
        }

        .precision-editor-controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 16px;
            z-index: 26;
        }

        .precision-editor-button {
            padding: 12px 20px;
            border-radius: var(--radius-full);
            background-color: var(--white);
            color: var(--text-primary);
            font-weight: 600;
            box-shadow: var(--shadow-lg);
            transition: var(--transition-fast);
        }

        .precision-editor-button:active {
            transform: scale(0.98);
        }

        .precision-editor-button.confirm {
            background-color: var(--success-color);
            color: var(--white);
        }

        .precision-editor-button.cancel {
            background-color: var(--error-color);
            color: var(--white);
        }

        /* Control point for precision editing */
        .control-handle {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: var(--white);
            border: 3px solid var(--primary-color);
            box-shadow: var(--shadow-md);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            touch-action: none;
            z-index: 27;
        }

        .control-handle::after {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
        }

        /* ============ Splash Screen ============ */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--primary-gradient);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.6s ease-out;
            color: var(--white);
            text-align: center;
        }

        .splash-logo {
            font-size: 48px;
            margin-bottom: 16px;
            animation: pulse 2s infinite;
        }

        .splash-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .splash-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        .splash-loading {
            margin-top: 32px;
            width: 48px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
        }

        .splash-loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 30%;
            background-color: var(--white);
            border-radius: var(--radius-full);
            animation: loading 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes loading {
            0% { left: -30%; }
            100% { left: 100%; }
        }

        /* ============ Responsive Adjustments ============ */
        @media (max-width: 576px) {
            .header-title {
                font-size: 18px;
            }
            
            .mode-button {
                min-width: 80px;
                font-size: 13px;
                padding: 6px 12px;
            }
            
            .action-icon {
                font-size: 20px;
            }
            
            .action-label {
                font-size: 11px;
            }
            
            .utility-icon {
                font-size: 20px;
            }
            
            .utility-label {
                font-size: 11px;
            }
        }

        /* ============ Accessibility ============ */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* iOS safe area support */
        @supports(padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            .bottom-bar {
                height: calc(var(--bottom-bar-height) + env(safe-area-inset-bottom));
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            .fab {
                bottom: calc(var(--bottom-bar-height) + 16px + env(safe-area-inset-bottom));
            }
            
            .toolbar {
                bottom: calc(var(--bottom-bar-height) + 16px + env(safe-area-inset-bottom));
            }
            
            .status-bar {
                bottom: calc(var(--bottom-bar-height) + 80px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div class="splash-screen" id="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-layer-group"></i>
        </div>
        <div class="splash-title">CAC UtilityPro</div>
        <div class="splash-subtitle">Professional Utility Tracking</div>
        <div class="splash-loading"></div>
    </div>

    <!-- Main Application Container -->
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <i class="fas fa-layer-group logo-icon"></i>
                <span>CAC UtilityPro</span>
            </div>
            <div class="header-actions">
                <button class="header-button" id="save-button" title="Save">
                    <i class="fas fa-save"></i>
                </button>
                <button class="header-button" id="menu-button" title="Menu">
                    <i class="fas fa-ellipsis-vertical"></i>
                </button>
            </div>
        </header>

        <!-- Mode Switcher -->
        <div class="mode-switcher">
            <button class="mode-button active" id="discovery-mode">
                <i class="fas fa-search"></i> Discovery
            </button>
            <button class="mode-button" id="mapping-mode">
                <i class="fas fa-map"></i> Mapping
            </button>
            <div class="mode-indicator"></div>
        </div>

        <!-- Map Container -->
        <div id="map"></div>

        <!-- Side Controls -->
        <div class="side-controls">
            <button class="control-button" id="locate-button" title="My Location">
                <i class="fas fa-crosshairs"></i>
            </button>
            <button class="control-button" id="zoom-in-button" title="Zoom In">
                <i class="fas fa-plus"></i>
            </button>
            <button class="control-button" id="zoom-out-button" title="Zoom Out">
                <i class="fas fa-minus"></i>
            </button>
            <button class="control-button" id="measure-button" title="Measure">
                <i class="fas fa-ruler"></i>
            </button>
            <button class="control-button" id="annotate-button" title="Annotate">
                <i class="fas fa-tag"></i>
            </button>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="status-bar">
            <i class="fas fa-info-circle status-icon"></i>
            <span id="status-text">Ready to map utilities</span>
        </div>

        <!-- FAB Button -->
        <button class="fab" id="fab-button">
            <i class="fas fa-plus fab-icon"></i>
        </button>

        <!-- Bottom Action Bar -->
        <div class="bottom-bar">
            <button class="action-button" id="main-action">
                <div class="action-icon"><i class="fas fa-water"></i></div>
                <div class="action-label">Main</div>
            </button>
            <button class="action-button" id="service-action">
                <div class="action-icon"><i class="fas fa-home"></i></div>
                <div class="action-label">Service</div>
            </button>
            <button class="action-button" id="structure-action">
                <div class="action-icon"><i class="fas fa-cube"></i></div>
                <div class="action-label">Structure</div>
            </button>
            <button class="action-button" id="edit-action">
                <div class="action-icon"><i class="fas fa-edit"></i></div>
                <div class="action-label">Edit</div>
            </button>
            <button class="action-button" id="more-action">
                <div class="action-icon"><i class="fas fa-ellipsis-h"></i></div>
                <div class="action-label">More</div>
            </button>
        </div>

        <!-- Utility Type Selector -->
        <div class="utility-selector" id="utility-selector">
            <button class="utility-button water" id="water-button">
                <div class="utility-icon"><i class="fas fa-tint"></i></div>
                <div class="utility-label">Water</div>
            </button>
            <button class="utility-button gas" id="gas-button">
                <div class="utility-icon"><i class="fas fa-fire"></i></div>
                <div class="utility-label">Gas</div>
            </button>
            <button class="utility-button electric" id="electric-button">
                <div class="utility-icon"><i class="fas fa-bolt"></i></div>
                <div class="utility-label">Electric</div>
            </button>
            <button class="utility-button sewer" id="sewer-button">
                <div class="utility-icon"><i class="fas fa-toilet"></i></div>
                <div class="utility-label">Sewer</div>
            </button>
            <button class="utility-button telecom" id="telecom-button">
                <div class="utility-icon"><i class="fas fa-phone"></i></div>
                <div class="utility-label">Telecom</div>
            </button>
        </div>

        <!-- Editing Toolbar -->
        <div class="toolbar" id="edit-toolbar">
            <button class="toolbar-button" id="select-button" title="Select">
                <i class="fas fa-mouse-pointer"></i>
            </button>
            <button class="toolbar-button" id="move-button" title="Move">
                <i class="fas fa-arrows-alt"></i>
            </button>
            <button class="toolbar-button" id="precision-button" title="Precision Edit">
                <i class="fas fa-crosshairs"></i>
            </button>
            <button class="toolbar-button" id="connect-button" title="Connect">
                <i class="fas fa-link"></i>
            </button>
            <button class="toolbar-button" id="delete-button" title="Delete">
                <i class="fas fa-trash"></i>
            </button>
        </div>

        <!-- Structure Toolbar -->
        <div class="toolbar" id="structure-toolbar">
            <button class="toolbar-button" id="manhole-button" title="Manhole">
                <i class="fas fa-circle"></i>
            </button>
            <button class="toolbar-button" id="catch-basin-button" title="Catch Basin">
                <i class="fas fa-drain"></i>
            </button>
            <button class="toolbar-button" id="electrical-box-button" title="Electrical Box">
                <i class="fas fa-box"></i>
            </button>
            <button class="toolbar-button" id="valve-button" title="Valve">
                <i class="fas fa-life-ring"></i>
            </button>
            <button class="toolbar-button" id="meter-button" title="Meter">
                <i class="fas fa-tachometer-alt"></i>
            </button>
        </div>

        <!-- More Actions Toolbar -->
        <div class="toolbar" id="more-toolbar">
            <button class="toolbar-button" id="undo-button" title="Undo">
                <i class="fas fa-undo"></i>
            </button>
            <button class="toolbar-button" id="clear-button" title="Clear All">
                <i class="fas fa-trash-alt"></i>
            </button>
            <button class="toolbar-button" id="export-button" title="Export Data">
                <i class="fas fa-file-export"></i>
            </button>
            <button class="toolbar-button" id="import-button" title="Import Data">
                <i class="fas fa-file-import"></i>
            </button>
            <button class="toolbar-button" id="help-button" title="Help">
                <i class="fas fa-question-circle"></i>
            </button>
        </div>

        <!-- Utility Info Card -->
        <div class="info-card" id="info-card">
            <div class="info-card-header">
                <div class="info-card-title">
                    <i class="fas fa-info-circle"></i>
                    <span id="info-title">Utility Information</span>
                </div>
                <button class="info-card-close" id="info-close">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="info-card-body">
                <div class="info-data-row">
                    <div class="info-label">Type:</div>
                    <div class="info-value" id="info-type">Water</div>
                </div>
                <div class="info-data-row">
                    <div class="info-label">Line Type:</div>
                    <div class="info-value" id="info-line-type">Main</div>
                </div>
                <div class="info-data-row">
                    <div class="info-label">Size:</div>
                    <div class="info-value" id="info-size">6 inches</div>
                </div>
                <div class="info-data-row">
                    <div class="info-label">Depth:</div>
                    <div class="info-value" id="info-depth">4 feet</div>
                </div>
                <div class="info-data-row">
                    <div class="info-label">Material:</div>
                    <div class="info-value" id="info-material">PVC</div>
                </div>
                <div class="info-data-row">
                    <div class="info-label">Direction:</div>
                    <div class="info-value" id="info-direction">Northeast</div>
                </div>
                <div class="info-image" id="info-image-container">
                    <!-- Image will be inserted here if available -->
                </div>
            </div>
            <div class="info-card-footer">
                <button class="info-btn" id="info-edit">Edit</button>
                <button class="info-btn info-btn-primary" id="info-connect">Connect</button>
            </div>
        </div>

        <!-- Context Menu -->
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="context-edit">
                <i class="fas fa-edit"></i>
                <span>Edit Properties</span>
            </div>
            <div class="context-menu-item" id="context-move">
                <i class="fas fa-arrows-alt"></i>
                <span>Move</span>
            </div>
            <div class="context-menu-item" id="context-precision">
                <i class="fas fa-crosshairs"></i>
                <span>Precision Edit</span>
            </div>
            <div class="context-menu-item" id="context-connect">
                <i class="fas fa-link"></i>
                <span>Connect</span>
            </div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item" id="context-measure">
                <i class="fas fa-ruler"></i>
                <span>Measure From Here</span>
            </div>
            <div class="context-menu-item" id="context-annotate">
                <i class="fas fa-tag"></i>
                <span>Add Annotation</span>
            </div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item danger" id="context-delete">
                <i class="fas fa-trash"></i>
                <span>Delete</span>
            </div>
        </div>

        <!-- High Precision Editor -->
        <div class="precision-editor" id="precision-editor">
            <div class="precision-editor-controls">
                <button class="precision-editor-button cancel" id="precision-cancel">
                    Cancel
                </button>
                <button class="precision-editor-button confirm" id="precision-confirm">
                    Confirm Changes
                </button>
            </div>
        </div>

        <!-- Notification -->
        <div class="notification" id="notification">
            <i class="fas fa-info-circle"></i>
            <span id="notification-text">Notification message</span>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay">
            <div class="spinner"></div>
        </div>

        <!-- MODALS -->
        
        <!-- Add Utility Modal -->
        <div class="modal-overlay" id="add-utility-modal">
            <div class="modal animate__animated animate__fadeInUp">
                <div class="modal-header">
                    <div class="modal-title" id="utility-modal-title">Add Utility</div>
                    <button class="modal-close" id="utility-modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Utility Type</label>
                        <div class="option-selector" id="modal-utility-type">
                            <div class="option-item water selected" data-value="water">
                                <div class="option-icon"><i class="fas fa-tint"></i></div>
                                <div class="option-label">Water</div>
                            </div>
                            <div class="option-item gas" data-value="gas">
                                <div class="option-icon"><i class="fas fa-fire"></i></div>
                                <div class="option-label">Gas</div>
                            </div>
                            <div class="option-item electric" data-value="electric">
                                <div class="option-icon"><i class="fas fa-bolt"></i></div>
                                <div class="option-label">Electric</div>
                            </div>
                            <div class="option-item sewer" data-value="sewer">
                                <div class="option-icon"><i class="fas fa-toilet"></i></div>
                                <div class="option-label">Sewer</div>
                            </div>
                            <div class="option-item telecom" data-value="telecom">
                                <div class="option-icon"><i class="fas fa-phone"></i></div>
                                <div class="option-label">Telecom</div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Line Type</label>
                        <div class="radio-group">
                            <div class="radio-item">
                                <input type="radio" id="main-type" name="line-type" value="main">
                                <label class="radio-control" for="main-type">Main</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="service-type" name="line-type" value="service" checked>
                                <label class="radio-control" for="service-type">Service</label>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utility-size">Size (inches)</label>
                        <input type="number" class="form-control" id="utility-size" value="4" min="0.5" max="48" step="0.5">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utility-depth">Depth (feet)</label>
                        <input type="number" class="form-control" id="utility-depth" value="3" min="0.5" max="20" step="0.5">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utility-material">Material</label>
                        <div class="select-container">
                            <select class="form-control" id="utility-material">
                                <option value="PVC">PVC</option>
                                <option value="Cast Iron">Cast Iron</option>
                                <option value="Ductile Iron">Ductile Iron</option>
                                <option value="Copper">Copper</option>
                                <option value="HDPE">HDPE</option>
                                <option value="Steel">Steel</option>
                                <option value="Concrete">Concrete</option>
                                <option value="Clay">Clay</option>
                                <option value="Unknown">Unknown</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utility-condition">Condition</label>
                        <div class="select-container">
                            <select class="form-control" id="utility-condition">
                                <option value="Excellent">Excellent</option>
                                <option value="Good">Good</option>
                                <option value="Fair" selected>Fair</option>
                                <option value="Poor">Poor</option>
                                <option value="Critical">Critical</option>
                                <option value="Unknown">Unknown</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Photo</label>
                        <input type="file" id="utility-photo" class="file-input" accept="image/*">
                        <label for="utility-photo" class="file-control">
                            <i class="fas fa-camera"></i>
                            <span class="file-control-text">Tap to add photo</span>
                        </label>
                        <div class="file-preview" id="photo-preview">
                            <img id="preview-image" src="" alt="Preview">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="utility-notes">Notes</label>
                        <textarea class="form-control" id="utility-notes" rows="3" placeholder="Add any additional information..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="utility-cancel">Cancel</button>
                    <button class="btn btn-primary" id="utility-confirm">Add Utility</button>
                </div>
            </div>
        </div>

        <!-- Add Structure Modal -->
        <div class="modal-overlay" id="add-structure-modal">
            <div class="modal animate__animated animate__fadeInUp">
                <div class="modal-header">
                    <div class="modal-title" id="structure-modal-title">Add Structure</div>
                    <button class="modal-close" id="structure-modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Structure Type</label>
                        <div class="option-selector" id="modal-structure-type">
                            <div class="option-item selected" data-value="manhole">
                                <div class="option-icon"><i class="fas fa-circle"></i></div>
                                <div class="option-label">Manhole</div>
                            </div>
                            <div class="option-item" data-value="catch-basin">
                                <div class="option-icon"><i class="fas fa-drain"></i></div>
                                <div class="option-label">Catch Basin</div>
                            </div>
                            <div class="option-item" data-value="electrical-box">
                                <div class="option-icon"><i class="fas fa-box"></i></div>
                                <div class="option-label">Electrical Box</div>
                            </div>
                            <div class="option-item" data-value="valve">
                                <div class="option-icon"><i class="fas fa-life-ring"></i></div>
                                <div class="option-label">Valve</div>
                            </div>
                            <div class="option-item" data-value="meter">
                                <div class="option-icon"><i class="fas fa-tachometer-alt"></i></div>
                                <div class="option-label">Meter</div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="structure-size">Size (inches)</label>
                        <input type="number" class="form-control" id="structure-size" value="24" min="4" max="72" step="1">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="structure-depth">Depth (feet)</label>
                        <input type="number" class="form-control" id="structure-depth" value="3" min="0.5" max="20" step="0.5">
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="structure-material">Material</label>
                        <div class="select-container">
                            <select class="form-control" id="structure-material">
                                <option value="Concrete">Concrete</option>
                                <option value="Brick">Brick</option>
                                <option value="Steel">Steel</option>
                                <option value="Cast Iron">Cast Iron</option>
                                <option value="Plastic">Plastic</option>
                                <option value="Unknown">Unknown</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="structure-condition">Condition</label>
                        <div class="select-container">
                            <select class="form-control" id="structure-condition">
                                <option value="Excellent">Excellent</option>
                                <option value="Good">Good</option>
                                <option value="Fair" selected>Fair</option>
                                <option value="Poor">Poor</option>
                                <option value="Critical">Critical</option>
                                <option value="Unknown">Unknown</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Photo</label>
                        <input type="file" id="structure-photo" class="file-input" accept="image/*">
                        <label for="structure-photo" class="file-control">
                            <i class="fas fa-camera"></i>
                            <span class="file-control-text">Tap to add photo</span>
                        </label>
                        <div class="file-preview" id="structure-photo-preview">
                            <img id="structure-preview-image" src="" alt="Preview">
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="structure-notes">Notes</label>
                        <textarea class="form-control" id="structure-notes" rows="3" placeholder="Add any additional information..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="structure-cancel">Cancel</button>
                    <button class="btn btn-primary" id="structure-confirm">Add Structure</button>
                </div>
            </div>
        </div>

        <!-- Add Annotation Modal -->
        <div class="modal-overlay" id="add-annotation-modal">
            <div class="modal animate__animated animate__fadeInUp">
                <div class="modal-header">
                    <div class="modal-title">Add Annotation</div>
                    <button class="modal-close" id="annotation-modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label" for="annotation-text">Annotation Text</label>
                        <input type="text" class="form-control" id="annotation-text" placeholder="e.g. 6' from curb">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Annotation Type</label>
                        <div class="radio-group">
                            <div class="radio-item">
                                <input type="radio" id="type-measurement" name="annotation-type" value="measurement" checked>
                                <label class="radio-control" for="type-measurement">Measurement</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="type-note" name="annotation-type" value="note">
                                <label class="radio-control" for="type-note">Note</label>
                            </div>
                            <div class="radio-item">
                                <input type="radio" id="type-warning" name="annotation-type" value="warning">
                                <label class="radio-control" for="type-warning">Warning</label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="annotation-cancel">Cancel</button>
                    <button class="btn btn-primary" id="annotation-confirm">Add Annotation</button>
                </div>
            </div>
        </div>

        <!-- Connect Utility Modal -->
        <div class="modal-overlay" id="connect-modal">
            <div class="modal animate__animated animate__fadeInUp">
                <div class="modal-header">
                    <div class="modal-title">Connect Utilities</div>
                    <button class="modal-close" id="connect-modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Connection Type</label>
                        <div class="option-selector">
                            <div class="option-item selected" data-value="direct">
                                <div class="option-icon"><i class="fas fa-link"></i></div>
                                <div class="option-label">Direct</div>
                            </div>
                            <div class="option-item" data-value="tap">
                                <div class="option-icon"><i class="fas fa-project-diagram"></i></div>
                                <div class="option-label">Tap</div>
                            </div>
                            <div class="option-item" data-value="offset">
                                <div class="option-icon"><i class="fas fa-exchange-alt"></i></div>
                                <div class="option-label">Offset</div>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label" for="connection-notes">Notes</label>
                        <textarea class="form-control" id="connection-notes" rows="2" placeholder="Optional connection details..."></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="connect-cancel">Cancel</button>
                    <button class="btn btn-primary" id="connect-confirm">Connect</button>
                </div>
            </div>
        </div>

        <!-- Clear Confirmation Modal -->
        <div class="modal-overlay" id="clear-confirm-modal">
            <div class="modal animate__animated animate__fadeInUp">
                <div class="modal-header">
                    <div class="modal-title">Clear All Data</div>
                    <button class="modal-close" id="clear-modal-close">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to clear all utility data? This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-text" id="clear-cancel">Cancel</button>
                    <button class="btn btn-primary" id="clear-confirm">Clear All</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <!-- Application JavaScript -->
    <script>
        /***************************************************
         * CAC UtilityPro - Main Application JavaScript
         * A professional utility tracking application
         ***************************************************/

        // ============ Application Initialization ============
        document.addEventListener('DOMContentLoaded', function() {
            // Show splash screen for a minimum time
            setTimeout(function() {
                const splashScreen = document.getElementById('splash-screen');
                splashScreen.style.opacity = '0';
                setTimeout(() => {
                    splashScreen.style.display = 'none';
                    initApp();
                }, 600);
            }, 1500);
        });

        function initApp() {
            // ============ Global Variables ============
            let map;
            let currentMode = 'discovery'; // 'discovery' or 'mapping'
            let currentAction = null;
            let selectedUtilityType = 'water'; // Default utility type
            let selectedStructureType = 'manhole'; // Default structure type
            let selectedLineType = 'service'; // Default line type
            let isDrawing = false;
            let drawingPoints = [];
            let tempLine = null;
            let userMarker = null;
            let currentPosition = null;
            let selectedElement = null;
            let isMeasuring = false;
            let measureStartPoint = null;
            let measureLine = null;
            let measureTooltip = null;
            let isPrecisionEditing = false;
            let controlHandles = [];
            let originalPoints = null;
            let isConnecting = false;
            let connectingSource = null;
            
            // Data storage
            const utilities = {
                water: [],
                gas: [],
                electric: [],
                sewer: [],
                telecom: []
            };
            
            const structures = [];
            const annotations = [];
            const measurements = [];
            const undoStack = [];
            
            // ============ Initialize Map ============
            function initMap() {
                // Create the map with default view
                map = L.map('map', {
                    center: [40.7128, -74.0060], // Default to NYC
                    zoom: 18,
                    zoomControl: false, // We'll add custom zoom controls
                    attributionControl: false,
                    maxZoom: 22 // Allow very high zoom levels
                });
                
                // Add tile layer (OpenStreetMap)
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 22,
                    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                }).addTo(map);
                
                // Create layers for different elements
                window.utilitiesLayer = L.layerGroup().addTo(map);
                window.structuresLayer = L.layerGroup().addTo(map);
                window.annotationsLayer = L.layerGroup().addTo(map);
                window.measurementsLayer = L.layerGroup().addTo(map);
                window.tempLayer = L.layerGroup().addTo(map);
                window.controlsLayer = L.layerGroup().addTo(map);
                
                // Map event listeners
                map.on('click', handleMapClick);
                map.on('contextmenu', handleContextMenu);
                map.on('mousemove', handleMouseMove);
                map.on('movestart', function() {
                    hideContextMenu();
                    hideInfoCard();
                });
            }
            
            // ============ UI Controls & Events ============
            function initUIControls() {
                // Mode switcher
                document.getElementById('discovery-mode').addEventListener('click', function() {
                    setActiveMode('discovery');
                });
                
                document.getElementById('mapping-mode').addEventListener('click', function() {
                    setActiveMode('mapping');
                });
                
                // Side controls
                document.getElementById('locate-button').addEventListener('click', getUserLocation);
                document.getElementById('zoom-in-button').addEventListener('click', function() {
                    map.zoomIn(1);
                });
                document.getElementById('zoom-out-button').addEventListener('click', function() {
                    map.zoomOut(1);
                });
                document.getElementById('measure-button').addEventListener('click', toggleMeasureMode);
                document.getElementById('annotate-button').addEventListener('click', startAnnotation);
                
                // FAB button
                document.getElementById('fab-button').addEventListener('click', handleFabClick);
                
                // Bottom action bar
                document.getElementById('main-action').addEventListener('click', function() {
                    setActiveAction('main');
                });
                
                document.getElementById('service-action').addEventListener('click', function() {
                    setActiveAction('service');
                });
                
                document.getElementById('structure-action').addEventListener('click', function() {
                    setActiveAction('structure');
                    showStructureToolbar();
                });
                
                document.getElementById('edit-action').addEventListener('click', function() {
                    setActiveAction('edit');
                    showEditToolbar();
                });
                
                document.getElementById('more-action').addEventListener('click', function() {
                    showMoreToolbar();
                });
                
                // Utility selector
                document.getElementById('water-button').addEventListener('click', function() {
                    setSelectedUtilityType('water');
                });
                
                document.getElementById('gas-button').addEventListener('click', function() {
                    setSelectedUtilityType('gas');
                });
                
                document.getElementById('electric-button').addEventListener('click', function() {
                    setSelectedUtilityType('electric');
                });
                
                document.getElementById('sewer-button').addEventListener('click', function() {
                    setSelectedUtilityType('sewer');
                });
                
                document.getElementById('telecom-button').addEventListener('click', function() {
                    setSelectedUtilityType('telecom');
                });
                
                // Edit toolbar
                document.getElementById('select-button').addEventListener('click', function() {
                    setEditMode('select');
                });
                
                document.getElementById('move-button').addEventListener('click', function() {
                    setEditMode('move');
                });
                
                document.getElementById('precision-button').addEventListener('click', function() {
                    setEditMode('precision');
                });
                
                document.getElementById('connect-button').addEventListener('click', function() {
                    setEditMode('connect');
                });
                
                document.getElementById('delete-button').addEventListener('click', function() {
                    setEditMode('delete');
                });
                
                // Structure toolbar
                document.getElementById('manhole-button').addEventListener('click', function() {
                    selectedStructureType = 'manhole';
                    setActiveAction('structure');
                    updateStatus('Tap on the map to place a manhole');
                });
                
                document.getElementById('catch-basin-button').addEventListener('click', function() {
                    selectedStructureType = 'catch-basin';
                    setActiveAction('structure');
                    updateStatus('Tap on the map to place a catch basin');
                });
                
                document.getElementById('electrical-box-button').addEventListener('click', function() {
                    selectedStructureType = 'electrical-box';
                    setActiveAction('structure');
                    updateStatus('Tap on the map to place an electrical box');
                });
                
                document.getElementById('valve-button').addEventListener('click', function() {
                    selectedStructureType = 'valve';
                    setActiveAction('structure');
                    updateStatus('Tap on the map to place a valve');
                });
                
                document.getElementById('meter-button').addEventListener('click', function() {
                    selectedStructureType = 'meter';
                    setActiveAction('structure');
                    updateStatus('Tap on the map to place a meter');
                });
                
                // More actions toolbar
                document.getElementById('undo-button').addEventListener('click', undoLastAction);
                document.getElementById('clear-button').addEventListener('click', confirmClearAll);
                document.getElementById('export-button').addEventListener('click', exportData);
                document.getElementById('import-button').addEventListener('click', importData);
                document.getElementById('help-button').addEventListener('click', showHelp);
                
                // Info card
                document.getElementById('info-close').addEventListener('click', hideInfoCard);
                document.getElementById('info-edit').addEventListener('click', editSelectedElement);
                document.getElementById('info-connect').addEventListener('click', startConnecting);
                
                // Context menu
                document.getElementById('context-edit').addEventListener('click', function() {
                    hideContextMenu();
                    editSelectedElement();
                });
                
                document.getElementById('context-move').addEventListener('click', function() {
                    hideContextMenu();
                    startMovingElement();
                });
                
                document.getElementById('context-precision').addEventListener('click', function() {
                    hideContextMenu();
                    startPrecisionEdit();
                });
                
                document.getElementById('context-connect').addEventListener('click', function() {
                    hideContextMenu();
                    startConnecting();
                });
                
                document.getElementById('context-measure').addEventListener('click', function() {
                    hideContextMenu();
                    startMeasureFromElement();
                });
                
                document.getElementById('context-annotate').addEventListener('click', function() {
                    hideContextMenu();
                    startAnnotationFromElement();
                });
                
                document.getElementById('context-delete').addEventListener('click', function() {
                    hideContextMenu();
                    deleteSelectedElement();
                });
                
                // Precision editor
                document.getElementById('precision-cancel').addEventListener('click', cancelPrecisionEdit);
                document.getElementById('precision-confirm').addEventListener('click', confirmPrecisionEdit);
                
                // Modal handlers
                setupModalHandlers();
                
                // Save button
                document.getElementById('save-button').addEventListener('click', saveData);
                
                // Menu button
                document.getElementById('menu-button').addEventListener('click', function() {
                    showMoreToolbar();
                });
                
                // Upload photo preview
                document.getElementById('utility-photo').addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const previewImage = document.getElementById('preview-image');
                            previewImage.src = e.target.result;
                            document.getElementById('photo-preview').classList.add('visible');
                        };
                        reader.readAsDataURL(file);
                    }
                });
                
                document.getElementById('structure-photo').addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const previewImage = document.getElementById('structure-preview-image');
                            previewImage.src = e.target.result;
                            document.getElementById('structure-photo-preview').classList.add('visible');
                        };
                        reader.readAsDataURL(file);
                    }
                });
                
                // Handle document clicks to close menus
                document.addEventListener('click', function(e) {
                    // Only close context menu if clicking outside
                    if (e.target.closest('#context-menu') === null && 
                        document.getElementById('context-menu').classList.contains('visible')) {
                        hideContextMenu();
                    }
                });
                
                // Handle keyboard events
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        // Cancel any active modes or close any open panels
                        if (isDrawing) {
                            cancelDrawing();
                        } else if (isPrecisionEditing) {
                            cancelPrecisionEdit();
                        } else if (isMeasuring) {
                            cancelMeasurement();
                        } else if (isConnecting) {
                            cancelConnecting();
                        } else {
                            hideContextMenu();
                            hideInfoCard();
                            hideAllToolbars();
                        }
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        // Delete selected element if any
                        if (selectedElement && !isDrawing && !isPrecisionEditing) {
                            deleteSelectedElement();
                        }
                    } else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                        // Undo
                        undoLastAction();
                        e.preventDefault();
                    }
                });
            }
            
            function setupModalHandlers() {
                // Add Utility Modal
                document.getElementById('utility-modal-close').addEventListener('click', function() {
                    hideModal('add-utility-modal');
                });
                
                document.getElementById('utility-cancel').addEventListener('click', function() {
                    hideModal('add-utility-modal');
                });
                
                document.getElementById('utility-confirm').addEventListener('click', function() {
                    confirmAddUtility();
                });
                
                // Setup utility type selection
                document.querySelectorAll('#modal-utility-type .option-item').forEach(item => {
                    item.addEventListener('click', function() {
                        document.querySelectorAll('#modal-utility-type .option-item').forEach(i => {
                            i.classList.remove('selected');
                        });
                        this.classList.add('selected');
                    });
                });
                
                // Add Structure Modal
                document.getElementById('structure-modal-close').addEventListener('click', function() {
                    hideModal('add-structure-modal');
                });
                
                document.getElementById('structure-cancel').addEventListener('click', function() {
                    hideModal('add-structure-modal');
                });
                
                document.getElementById('structure-confirm').addEventListener('click', function() {
                    confirmAddStructure();
                });
                
                // Setup structure type selection
                document.querySelectorAll('#modal-structure-type .option-item').forEach(item => {
                    item.addEventListener('click', function() {
                        document.querySelectorAll('#modal-structure-type .option-item').forEach(i => {
                            i.classList.remove('selected');
                        });
                        this.classList.add('selected');
                    });
                });
                
                // Add Annotation Modal
                document.getElementById('annotation-modal-close').addEventListener('click', function() {
                    hideModal('add-annotation-modal');
                });
                
                document.getElementById('annotation-cancel').addEventListener('click', function() {
                    hideModal('add-annotation-modal');
                });
                
                document.getElementById('annotation-confirm').addEventListener('click', function() {
                    confirmAddAnnotation();
                });
                
                // Connect Modal
                document.getElementById('connect-modal-close').addEventListener('click', function() {
                    hideModal('connect-modal');
                    cancelConnecting();
                });
                
                document.getElementById('connect-cancel').addEventListener('click', function() {
                    hideModal('connect-modal');
                    cancelConnecting();
                });
                
                document.getElementById('connect-confirm').addEventListener('click', function() {
                    confirmConnection();
                });
                
                // Setup connection type selection
                document.querySelectorAll('#connect-modal .option-item').forEach(item => {
                    item.addEventListener('click', function() {
                        document.querySelectorAll('#connect-modal .option-item').forEach(i => {
                            i.classList.remove('selected');
                        });
                        this.classList.add('selected');
                    });
                });
                
                // Clear Confirmation Modal
                document.getElementById('clear-modal-close').addEventListener('click', function() {
                    hideModal('clear-confirm-modal');
                });
                
                document.getElementById('clear-cancel').addEventListener('click', function() {
                    hideModal('clear-confirm-modal');
                });
                
                document.getElementById('clear-confirm').addEventListener('click', function() {
                    hideModal('clear-confirm-modal');
                    clearAllData();
                });
            }
            
            // ============ Mode & Action Management ============
            function setActiveMode(mode) {
                // Update UI
                document.querySelectorAll('.mode-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(mode + '-mode').classList.add('active');
                
                // Adjust the mode indicator position
                const modeIndicator = document.querySelector('.mode-indicator');
                const activeButton = document.getElementById(mode + '-mode');
                modeIndicator.style.width = activeButton.offsetWidth + 'px';
                modeIndicator.style.left = activeButton.offsetLeft + 'px';
                
                // Store current mode
                currentMode = mode;
                
                // Reset actions when changing modes
                currentAction = null;
                hideAllToolbars();
                resetActions();
                
                // Update status based on mode
                if (mode === 'discovery') {
                    updateStatus('Discovery Mode: Document utilities as you find them');
                } else {
                    updateStatus('Mapping Mode: Map complete utility systems');
                }
                
                // Apply animation to the mode switcher
                animateElement(document.querySelector('.mode-switcher'), 'pulse');
            }
            
            function setActiveAction(action) {
                // Reset previous states
                cancelDrawing();
                cancelMeasurement();
                cancelPrecisionEdit();
                cancelConnecting();
                
                // Update UI
                document.querySelectorAll('.action-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                if (action) {
                    document.getElementById(action + '-action').classList.add('active');
                    
                    // Show utility selector for main or service actions
                    if (action === 'main' || action === 'service') {
                        showUtilitySelector();
                        hideAllToolbars();
                        selectedLineType = action; // Set 'main' or 'service' as line type
                        updateStatus('Select utility type and tap on map to add a ' + action);
                    } else {
                        hideUtilitySelector();
                    }
                } else {
                    hideUtilitySelector();
                    hideAllToolbars();
                }
                
                // Store current action
                currentAction = action;
            }
            
            function setSelectedUtilityType(type) {
                // Update UI
                document.querySelectorAll('.utility-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById(type + '-button').classList.add('active');
                
                // Store selected utility type
                selectedUtilityType = type;
                
                // Update status
                updateStatus(`Selected ${type}. Tap on map to add a ${selectedLineType} line`);
                
                // Apply animation
                animateElement(document.getElementById(type + '-button'), 'pulse');
            }
            
            function setEditMode(mode) {
                // Reset existing edit mode
                document.querySelectorAll('#edit-toolbar .toolbar-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Activate the selected mode
                if (mode) {
                    document.getElementById(mode + '-button').classList.add('active');
                }
                
                // Handle specific edit modes
                switch(mode) {
                    case 'select':
                        updateStatus('Tap on a utility or structure to select it');
                        break;
                    case 'move':
                        updateStatus('Tap on a utility or structure to move it');
                        break;
                    case 'precision':
                        updateStatus('Tap on a utility line to edit with precision controls');
                        break;
                    case 'connect':
                        updateStatus('Tap on a utility to start connecting, then tap on another utility');
                        startConnecting();
                        break;
                    case 'delete':
                        updateStatus('Tap on a utility or structure to delete it');
                        break;
                }
            }
            
            function showUtilitySelector() {
                document.getElementById('utility-selector').classList.add('visible');
            }
            
            function hideUtilitySelector() {
                document.getElementById('utility-selector').classList.remove('visible');
            }
            
            function showEditToolbar() {
                hideAllToolbars();
                const toolbar = document.getElementById('edit-toolbar');
                toolbar.classList.add('visible');
                setEditMode('select'); // Default to select mode
            }
            
            function showStructureToolbar() {
                hideAllToolbars();
                const toolbar = document.getElementById('structure-toolbar');
                toolbar.classList.add('visible');
            }
            
            function showMoreToolbar() {
                hideAllToolbars();
                const toolbar = document.getElementById('more-toolbar');
                toolbar.classList.add('visible');
            }
            
            function hideAllToolbars() {
                document.querySelectorAll('.toolbar').forEach(toolbar => {
                    toolbar.classList.remove('visible');
                });
            }
            
            function resetActions() {
                document.querySelectorAll('.action-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                hideAllToolbars();
                cancelDrawing();
                cancelMeasurement();
                cancelPrecisionEdit();
                cancelConnecting();
            }
            
            // ============ Map Interaction Functions ============
            function handleMapClick(e) {
                // If context menu is open, close it
                hideContextMenu();
                hideInfoCard();
                
                // Get click location
                const latlng = e.latlng;
                
                // Handle different actions based on mode and current action
                if (currentMode === 'discovery') {
                    if (currentAction === 'main' || currentAction === 'service') {
                        // In discovery mode, clicking adds a single utility point
                        showAddUtilityModal(latlng);
                    } else if (currentAction === 'structure') {
                        showAddStructureModal(latlng);
                    } else if (currentAction === 'edit') {
                        // In edit mode, handle based on selected edit action
                        handleEditModeClick(latlng);
                    }
                } else if (currentMode === 'mapping') {
                    if (currentAction === 'main' || currentAction === 'service') {
                        // In mapping mode, clicks build up a line
                        handleMappingClick(latlng);
                    } else if (currentAction === 'structure') {
                        showAddStructureModal(latlng);
                    } else if (currentAction === 'edit') {
                        // In edit mode, handle based on selected edit action
                        handleEditModeClick(latlng);
                    }
                }
                
                // Handle measurement mode
                if (isMeasuring) {
                    handleMeasurementClick(latlng);
                }
                
                // Handle connecting mode
                if (isConnecting) {
                    handleConnectingClick(latlng);
                }
            }
            
            function handleMouseMove(e) {
                // Update temporary drawing line
                if (isDrawing && tempLine) {
                    const points = [...drawingPoints, e.latlng];
                    tempLine.setLatLngs(points);
                }
                
                // Update measurement line
                if (isMeasuring && measureStartPoint) {
                    updateMeasurementLine(measureStartPoint, e.latlng);
                }
            }
            
            function handleContextMenu(e) {
                // Prevent default browser context menu
                e.originalEvent.preventDefault();
                
                // Find if we clicked on a utility or structure
                const element = findElementAtPoint(e.latlng);
                
                if (element) {
                    // Store the selected element
                    selectedElement = element;
                    
                    // Position and show context menu
                    const menu = document.getElementById('context-menu');
                    const point = map.latLngToContainerPoint(e.latlng);
                    
                    // Position the menu
                    menu.style.left = point.x + 'px';
                    menu.style.top = point.y + 'px';
                    
                    // Show appropriate menu items based on element type
                    configureContextMenu(element);
                    
                    // Show the menu with animation
                    menu.classList.add('visible');
                }
            }
            
            function configureContextMenu(element) {
                // Hide or show specific menu items based on element type
                const isLine = element.type === 'utility' && element.geometry === 'line';
                const isPoint = element.type === 'utility' && element.geometry === 'point';
                const isStructure = element.type === 'structure';
                
                // Configure context menu items
                document.getElementById('context-precision').style.display = isLine ? 'flex' : 'none';
                document.getElementById('context-connect').style.display = (isLine || isPoint || isStructure) ? 'flex' : 'none';
            }
            
            function hideContextMenu() {
                document.getElementById('context-menu').classList.remove('visible');
            }
            
            function handleEditModeClick(latlng) {
                // Get the currently selected edit mode
                const activeButton = document.querySelector('#edit-toolbar .toolbar-button.active');
                if (!activeButton) return;
                
                const editMode = activeButton.id.replace('-button', '');
                
                // Find if we clicked on a utility or structure
                const element = findElementAtPoint(latlng);
                
                if (element) {
                    // Store the selected element
                    selectedElement = element;
                    
                    // Handle different edit modes
                    switch(editMode) {
                        case 'select':
                            showElementInfo(element);
                            break;
                        case 'move':
                            startMovingElement();
                            break;
                        case 'precision':
                            if (element.type === 'utility' && element.geometry === 'line') {
                                startPrecisionEdit();
                            } else {
                                showNotification('Only utility lines can be precision edited', 'info');
                            }
                            break;
                        case 'connect':
                            // Already handled by isConnecting flag
                            break;
                        case 'delete':
                            deleteSelectedElement();
                            break;
                    }
                }
            }
            
            function handleFabClick() {
                // Toggle editing mode
                const fab = document.getElementById('fab-button');
                
                if (fab.classList.contains('editing')) {
                    // Finish editing
                    fab.classList.remove('editing');
                    finishDrawing();
                } else {
                    // If we're in mapping mode and have a selected utility type
                    if (currentMode === 'mapping' && (currentAction === 'main' || currentAction === 'service')) {
                        // Start drawing
                        startDrawing();
                        fab.classList.add('editing');
                    } else {
                        // Fallback to showing utility selector
                        showUtilitySelector();
                    }
                }
            }
            
            // ============ Drawing Functions ============
            function handleMappingClick(latlng) {
                if (!isDrawing) {
                    // First click - start drawing
                    startDrawing();
                    addDrawingPoint(latlng);
                } else {
                    // Add point to drawing
                    addDrawingPoint(latlng);
                }
            }
            
            function startDrawing() {
                isDrawing = true;
                drawingPoints = [];
                
                // Show finish button (FAB)
                const fab = document.getElementById('fab-button');
                fab.classList.add('editing');
                
                // Update status
                updateStatus('Tap on map to add points, tap FAB button to finish');
                
                // Hide utility selector when drawing
                hideUtilitySelector();
            }
            
            function addDrawingPoint(latlng) {
                // Add point to the drawing
                drawingPoints.push(latlng);
                
                // Create or update temporary line
                if (drawingPoints.length === 1) {
                    // Create a marker for the first point
                    L.circleMarker(latlng, {
                        radius: 5,
                        color: getUtilityColor(selectedUtilityType),
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(window.tempLayer);
                    
                    // Create temporary line
                    tempLine = L.polyline([latlng, latlng], {
                        color: getUtilityColor(selectedUtilityType),
                        weight: selectedLineType === 'main' ? 6 : 4,
                        opacity: 0.7,
                        dashArray: '5,5',
                        className: 'utility-line temp'
                    }).addTo(window.tempLayer);
                    
                    updateStatus('Tap to add more points, tap FAB button to finish');
                } else {
                    // Add a marker for this point
                    L.circleMarker(latlng, {
                        radius: 5,
                        color: getUtilityColor(selectedUtilityType),
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(window.tempLayer);
                }
            }
            
            function finishDrawing() {
                // Need at least 2 points for a line
                if (drawingPoints.length < 2) {
                    cancelDrawing();
                    return;
                }
                
                // Cleanup temporary elements
                window.tempLayer.clearLayers();
                tempLine = null;
                
                // Create the final utility line
                const utilityId = 'utility-' + Date.now();
                const lineType = selectedLineType; // 'main' or 'service'
                
                // Add to utilities collection
                const utilityObj = {
                    id: utilityId,
                    type: selectedUtilityType,
                    lineType: lineType,
                    points: [...drawingPoints],
                    size: 4, // Default values, will be updated in modal
                    depth: 3,
                    material: 'PVC',
                    condition: 'Fair',
                    notes: '',
                    geometry: 'line'
                };
                
                // Show modal to collect additional info
                showAddUtilityModal(null, utilityObj);
                
                // Reset drawing state
                isDrawing = false;
                drawingPoints = [];
                
                // Update FAB button
                document.getElementById('fab-button').classList.remove('editing');
            }
            
            function cancelDrawing() {
                // Cleanup temporary elements
                if (window.tempLayer) {
                    window.tempLayer.clearLayers();
                }
                tempLine = null;
                
                // Reset drawing state
                isDrawing = false;
                drawingPoints = [];
                
                // Update FAB button
                document.getElementById('fab-button').classList.remove('editing');
                
                // Update status
                if (currentAction) {
                    updateStatus(`Select ${currentAction} and tap on map to add`);
                } else {
                    updateStatus('Select an action to begin');
                }
            }
            
            // ============ Element Creation & Management ============
            function showAddUtilityModal(latlng, utilityObj = null) {
                // Configure modal for add or edit
                const isEdit = utilityObj !== null;
                const modalTitle = document.getElementById('utility-modal-title');
                const confirmButton = document.getElementById('utility-confirm');
                
                modalTitle.textContent = isEdit ? 'Edit Utility' : 'Add Utility';
                confirmButton.textContent = isEdit ? 'Update Utility' : 'Add Utility';
                
                // Pre-fill form if editing
                if (isEdit) {
                    // Set utility type
                    document.querySelectorAll('#modal-utility-type .option-item').forEach(item => {
                        item.classList.remove('selected');
                        if (item.getAttribute('data-value') === utilityObj.type) {
                            item.classList.add('selected');
                        }
                    });
                    
                    // Set line type
                    if (utilityObj.lineType === 'main') {
                        document.getElementById('main-type').checked = true;
                    } else {
                        document.getElementById('service-type').checked = true;
                    }
                    
                    // Set other fields
                    document.getElementById('utility-size').value = utilityObj.size || 4;
                    document.getElementById('utility-depth').value = utilityObj.depth || 3;
                    document.getElementById('utility-material').value = utilityObj.material || 'PVC';
                    document.getElementById('utility-condition').value = utilityObj.condition || 'Fair';
                    document.getElementById('utility-notes').value = utilityObj.notes || '';
                    
                    // Show photo if available
                    if (utilityObj.photo) {
                        document.getElementById('preview-image').src = utilityObj.photo;
                        document.getElementById('photo-preview').classList.add('visible');
                    } else {
                        document.getElementById('photo-preview').classList.remove('visible');
                    }
                } else {
                    // Reset form for adding new utility
                    document.getElementById('utility-size').value = 4;
                    document.getElementById('utility-depth').value = 3;
                    document.getElementById('utility-material').value = 'PVC';
                    document.getElementById('utility-condition').value = 'Fair';
                    document.getElementById('utility-notes').value = '';
                    document.getElementById('photo-preview').classList.remove('visible');
                    
                    // Set utility type from selected type
                    document.querySelectorAll('#modal-utility-type .option-item').forEach(item => {
                        item.classList.remove('selected');
                        if (item.getAttribute('data-value') === selectedUtilityType) {
                            item.classList.add('selected');
                        }
                    });
                    
                    // Set line type from selected action
                    if (currentAction === 'main') {
                        document.getElementById('main-type').checked = true;
                    } else {
                        document.getElementById('service-type').checked = true;
                    }
                }
                
                // Utility object for storing in the form
                if (latlng) {
                    // For discovery mode, we'll store the point
                    document.getElementById('utility-modal').dataset.lat = latlng.lat;
                    document.getElementById('utility-modal').dataset.lng = latlng.lng;
                    document.getElementById('utility-modal').dataset.id = null;
                    document.getElementById('utility-modal').dataset.edit = 'false';
                } else if (utilityObj) {
                    // For editing, we'll store the ID
                    document.getElementById('utility-modal').dataset.id = utilityObj.id;
                    document.getElementById('utility-modal').dataset.edit = 'true';
                }
                
                // Show the modal
                showModal('add-utility-modal');
            }
            
            function confirmAddUtility() {
                // Get the form values
                const typeElement = document.querySelector('#modal-utility-type .option-item.selected');
                const utilityType = typeElement ? typeElement.getAttribute('data-value') : selectedUtilityType;
                
                const lineType = document.getElementById('main-type').checked ? 'main' : 'service';
                const size = parseFloat(document.getElementById('utility-size').value) || 4;
                const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                const material = document.getElementById('utility-material').value;
                const condition = document.getElementById('utility-condition').value;
                const notes = document.getElementById('utility-notes').value;
                
                // Get photo if available
                let photo = null;
                if (document.getElementById('photo-preview').classList.contains('visible')) {
                    photo = document.getElementById('preview-image').src;
                }
                
                // Check if we're editing or adding new
                const isEdit = document.getElementById('utility-modal').dataset.edit === 'true';
                
                if (isEdit) {
                    // Get the utility ID
                    const utilityId = document.getElementById('utility-modal').dataset.id;
                    
                    // Find and update the utility
                    const utility = findUtilityById(utilityId);
                    if (utility) {
                        // Update properties
                        utility.type = utilityType;
                        utility.lineType = lineType;
                        utility.size = size;
                        utility.depth = depth;
                        utility.material = material;
                        utility.condition = condition;
                        utility.notes = notes;
                        
                        if (photo) {
                            utility.photo = photo;
                        }
                        
                        // Redraw the utility
                        updateUtilityOnMap(utility);
                        
                        showNotification('Utility updated successfully', 'success');
                    }
                } else {
                    // Creating a new utility
                    const utilityId = 'utility-' + Date.now();
                    
                    // Check if we're in discovery or mapping mode
                    if (currentMode === 'discovery') {
                        // Get the lat/lng for discovery mode
                        const lat = parseFloat(document.getElementById('utility-modal').dataset.lat);
                        const lng = parseFloat(document.getElementById('utility-modal').dataset.lng);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            hideModal('add-utility-modal');
                            return;
                        }
                        
                        // Create utility object
                        const utilityObj = {
                            id: utilityId,
                            type: utilityType,
                            lineType: lineType,
                            points: [L.latLng(lat, lng)],
                            size: size,
                            depth: depth,
                            material: material,
                            condition: condition,
                            notes: notes,
                            photo: photo,
                            geometry: 'point'
                        };
                        
                        // Add to data
                        utilities[utilityType].push(utilityObj);
                        
                        // Add to map
                        addUtilityToMap(utilityObj);
                        
                        showNotification('Utility added successfully', 'success');
                    } else if (drawingPoints.length >= 2) {
                        // For mapping mode, use the drawing points
                        const utilityObj = {
                            id: utilityId,
                            type: utilityType,
                            lineType: lineType,
                            points: [...drawingPoints],
                            size: size,
                            depth: depth,
                            material: material,
                            condition: condition,
                            notes: notes,
                            photo: photo,
                            geometry: 'line'
                        };
                        
                        // Add to data
                        utilities[utilityType].push(utilityObj);
                        
                        // Add to map
                        addUtilityToMap(utilityObj);
                        
                        showNotification('Utility line added successfully', 'success');
                    }
                }
                
                // Clear drawing state
                drawingPoints = [];
                isDrawing = false;
                
                // Hide the modal
                hideModal('add-utility-modal');
                
                // Reset the form for next time
                document.getElementById('utility-notes').value = '';
                document.getElementById('photo-preview').classList.remove('visible');
                document.getElementById('utility-photo').value = '';
            }
            
            function showAddStructureModal(latlng, structureObj = null) {
                // Configure modal for add or edit
                const isEdit = structureObj !== null;
                const modalTitle = document.getElementById('structure-modal-title');
                const confirmButton = document.getElementById('structure-confirm');
                
                modalTitle.textContent = isEdit ? 'Edit Structure' : 'Add Structure';
                confirmButton.textContent = isEdit ? 'Update Structure' : 'Add Structure';
                
                // Pre-fill form if editing
                if (isEdit) {
                    // Set structure type
                    document.querySelectorAll('#modal-structure-type .option-item').forEach(item => {
                        item.classList.remove('selected');
                        if (item.getAttribute('data-value') === structureObj.structureType) {
                            item.classList.add('selected');
                        }
                    });
                    
                    // Set other fields
                    document.getElementById('structure-size').value = structureObj.size || 24;
                    document.getElementById('structure-depth').value = structureObj.depth || 3;
                    document.getElementById('structure-material').value = structureObj.material || 'Concrete';
                    document.getElementById('structure-condition').value = structureObj.condition || 'Fair';
                    document.getElementById('structure-notes').value = structureObj.notes || '';
                    
                    // Show photo if available
                    if (structureObj.photo) {
                        document.getElementById('structure-preview-image').src = structureObj.photo;
                        document.getElementById('structure-photo-preview').classList.add('visible');
                    } else {
                        document.getElementById('structure-photo-preview').classList.remove('visible');
                    }
                } else {
                    // Reset form for adding new structure
                    document.getElementById('structure-size').value = 24;
                    document.getElementById('structure-depth').value = 3;
                    document.getElementById('structure-material').value = 'Concrete';
                    document.getElementById('structure-condition').value = 'Fair';
                    document.getElementById('structure-notes').value = '';
                    document.getElementById('structure-photo-preview').classList.remove('visible');
                    
                    // Set structure type from selected type
                    document.querySelectorAll('#modal-structure-type .option-item').forEach(item => {
                        item.classList.remove('selected');
                        if (item.getAttribute('data-value') === selectedStructureType) {
                            item.classList.add('selected');
                        }
                    });
                }
                
                // Store location for adding
                if (latlng) {
                    document.getElementById('structure-modal').dataset.lat = latlng.lat;
                    document.getElementById('structure-modal').dataset.lng = latlng.lng;
                    document.getElementById('structure-modal').dataset.id = null;
                    document.getElementById('structure-modal').dataset.edit = 'false';
                } else if (structureObj) {
                    // For editing, we'll store the ID
                    document.getElementById('structure-modal').dataset.id = structureObj.id;
                    document.getElementById('structure-modal').dataset.edit = 'true';
                }
                
                // Show the modal
                showModal('add-structure-modal');
            }
            
            function confirmAddStructure() {
                // Get the form values
                const typeElement = document.querySelector('#modal-structure-type .option-item.selected');
                const structureType = typeElement ? typeElement.getAttribute('data-value') : selectedStructureType;
                
                const size = parseFloat(document.getElementById('structure-size').value) || 24;
                const depth = parseFloat(document.getElementById('structure-depth').value) || 3;
                const material = document.getElementById('structure-material').value;
                const condition = document.getElementById('structure-condition').value;
                const notes = document.getElementById('structure-notes').value;
                
                // Get photo if available
                let photo = null;
                if (document.getElementById('structure-photo-preview').classList.contains('visible')) {
                    photo = document.getElementById('structure-preview-image').src;
                }
                
                // Check if we're editing or adding new
                const isEdit = document.getElementById('structure-modal').dataset.edit === 'true';
                
                if (isEdit) {
                    // Get the structure ID
                    const structureId = document.getElementById('structure-modal').dataset.id;
                    
                    // Find and update the structure
                    const structureIndex = structures.findIndex(s => s.id === structureId);
                    if (structureIndex !== -1) {
                        // Update properties
                        structures[structureIndex].structureType = structureType;
                        structures[structureIndex].size = size;
                        structures[structureIndex].depth = depth;
                        structures[structureIndex].material = material;
                        structures[structureIndex].condition = condition;
                        structures[structureIndex].notes = notes;
                        
                        if (photo) {
                            structures[structureIndex].photo = photo;
                        }
                        
                        // Redraw the structure
                        updateStructureOnMap(structures[structureIndex]);
                        
                        showNotification('Structure updated successfully', 'success');
                    }
                } else {
                    // Get the lat/lng from the dataset
                    const lat = parseFloat(document.getElementById('structure-modal').dataset.lat);
                    const lng = parseFloat(document.getElementById('structure-modal').dataset.lng);
                    
                    if (isNaN(lat) || isNaN(lng)) {
                        hideModal('add-structure-modal');
                        return;
                    }
                    
                    // Create structure object
                    const structureId = 'structure-' + Date.now();
                    const structureObj = {
                        id: structureId,
                        structureType: structureType,
                        position: L.latLng(lat, lng),
                        size: size,
                        depth: depth,
                        material: material,
                        condition: condition,
                        notes: notes,
                        photo: photo,
                        connections: []
                    };
                    
                    // Add to data
                    structures.push(structureObj);
                    
                    // Add to map
                    addStructureToMap(structureObj);
                    
                    showNotification('Structure added successfully', 'success');
                }
                
                // Hide the modal
                hideModal('add-structure-modal');
                
                // Reset the form for next time
                document.getElementById('structure-notes').value = '';
                document.getElementById('structure-photo-preview').classList.remove('visible');
                document.getElementById('structure-photo').value = '';
            }
            
            function addUtilityToMap(utility) {
                const utilityColor = getUtilityColor(utility.type);
                
                if (utility.geometry === 'point') {
                    // Single point utility (discovery mode)
                    const point = utility.points[0];
                    
                    // Create marker with appropriate icon
                    const markerIcon = createUtilityMarkerIcon(utility.type, utility.lineType);
                    
                    const marker = L.marker(point, {
                        icon: markerIcon,
                        draggable: false
                    });
                    
                    // Store reference to the utility data
                    marker.utilityId = utility.id;
                    marker.utilityType = utility.type;
                    
                    // Add click handler
                    marker.on('click', function() {
                        const utilityObj = findUtilityById(this.utilityId);
                        if (utilityObj) {
                            selectedElement = {
                                type: 'utility',
                                id: utilityObj.id,
                                object: utilityObj,
                                element: marker,
                                geometry: 'point'
                            };
                            showElementInfo(selectedElement);
                        }
                    });
                    
                    // Add to the map
                    marker.addTo(window.utilitiesLayer);
                    
                    // Store marker reference in utility object
                    utility.marker = marker;
                    
                } else if (utility.geometry === 'line') {
                    // Line utility (mapping mode)
                    const weight = utility.lineType === 'main' ? 6 : 4;
                    
                    // Create the polyline
                    const polyline = L.polyline(utility.points, {
                        color: utilityColor,
                        weight: weight,
                        opacity: 1,
                        className: `utility-line ${utility.type} ${utility.lineType}`
                    });
                    
                    // Store reference to the utility data
                    polyline.utilityId = utility.id;
                    polyline.utilityType = utility.type;
                    
                    // Add click handler
                    polyline.on('click', function() {
                        const utilityObj = findUtilityById(this.utilityId);
                        if (utilityObj) {
                            selectedElement = {
                                type: 'utility',
                                id: utilityObj.id,
                                object: utilityObj,
                                element: polyline,
                                geometry: 'line'
                            };
                            showElementInfo(selectedElement);
                        }
                    });
                    
                    // Add to the map
                    polyline.addTo(window.utilitiesLayer);
                    
                    // Store polyline reference in utility object
                    utility.polyline = polyline;
                    
                    // Add markers at endpoints if it's a service line
                    if (utility.lineType === 'service') {
                        const startPoint = utility.points[0];
                        const markerIcon = createUtilityMarkerIcon(utility.type, utility.lineType);
                        
                        const marker = L.marker(startPoint, {
                            icon: markerIcon,
                            draggable: false
                        });
                        
                        // Store reference to the utility data
                        marker.utilityId = utility.id;
                        marker.utilityType = utility.type;
                        
                        // Add click handler
                        marker.on('click', function() {
                            const utilityObj = findUtilityById(this.utilityId);
                            if (utilityObj) {
                                selectedElement = {
                                    type: 'utility',
                                    id: utilityObj.id,
                                    object: utilityObj,
                                    element: marker,
                                    geometry: 'point'
                                };
                                showElementInfo(selectedElement);
                            }
                        });
                        
                        // Add to the map
                        marker.addTo(window.utilitiesLayer);
                        
                        // Store marker reference in utility object
                        utility.marker = marker;
                    }
                }
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-utility',
                    utility: utility
                });
            }
            
            function updateUtilityOnMap(utility) {
                // Remove existing elements
                if (utility.marker) {
                    window.utilitiesLayer.removeLayer(utility.marker);
                }
                
                if (utility.polyline) {
                    window.utilitiesLayer.removeLayer(utility.polyline);
                }
                
                // Re-add with updated properties
                addUtilityToMap(utility);
            }
            
            function addStructureToMap(structure) {
                // Create marker with appropriate icon
                const markerIcon = createStructureMarkerIcon(structure.structureType);
                
                const marker = L.marker(structure.position, {
                    icon: markerIcon,
                    draggable: false
                });
                
                // Store reference to the structure data
                marker.structureId = structure.id;
                
                // Add click handler
                marker.on('click', function() {
                    const structureIndex = structures.findIndex(s => s.id === this.structureId);
                    if (structureIndex !== -1) {
                        selectedElement = {
                            type: 'structure',
                            id: structure.id,
                            object: structures[structureIndex],
                            element: marker,
                            geometry: 'point'
                        };
                        showElementInfo(selectedElement);
                    }
                });
                
                // Add to the map
                marker.addTo(window.structuresLayer);
                
                // Store marker reference in structure object
                structure.marker = marker;
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-structure',
                    structure: structure
                });
            }
            
            function updateStructureOnMap(structure) {
                // Remove existing marker
                if (structure.marker) {
                    window.structuresLayer.removeLayer(structure.marker);
                }
                
                // Re-add with updated properties
                addStructureToMap(structure);
            }
            
            function findUtilityById(id) {
                let foundUtility = null;
                
                // Search in all utility types
                for (const type in utilities) {
                    const utility = utilities[type].find(u => u.id === id);
                    if (utility) {
                        foundUtility = utility;
                        break;
                    }
                }
                
                return foundUtility;
            }
            
            function findStructureById(id) {
                return structures.find(s => s.id === id);
            }
            
            function showElementInfo(element) {
                const infoCard = document.getElementById('info-card');
                
                // Configure info card based on element type
                if (element.type === 'utility') {
                    const utility = element.object;
                    
                    // Set title and icon based on utility type
                    document.getElementById('info-title').textContent = capitalize(utility.type) + ' ' + capitalize(utility.lineType);
                    
                    // Fill in the data
                    document.getElementById('info-type').textContent = capitalize(utility.type);
                    document.getElementById('info-line-type').textContent = capitalize(utility.lineType);
                    document.getElementById('info-size').textContent = utility.size + ' inches';
                    document.getElementById('info-depth').textContent = utility.depth + ' feet';
                    document.getElementById('info-material').textContent = utility.material || 'Unknown';
                    
                    // Calculate direction for line utilities
                    if (utility.geometry === 'line' && utility.points.length >= 2) {
                        const start = utility.points[0];
                        const end = utility.points[utility.points.length - 1];
                        const direction = calculateDirection(start, end);
                        document.getElementById('info-direction').textContent = direction;
                    } else {
                        document.getElementById('info-direction').textContent = 'N/A';
                    }
                    
                    // Show image if available
                    const imageContainer = document.getElementById('info-image-container');
                    if (utility.photo) {
                        imageContainer.innerHTML = `<img src="${utility.photo}" alt="Utility Photo">`;
                        imageContainer.style.display = 'block';
                    } else {
                        imageContainer.style.display = 'none';
                    }
                    
                } else if (element.type === 'structure') {
                    const structure = element.object;
                    
                    // Set title based on structure type
                    document.getElementById('info-title').textContent = formatStructureType(structure.structureType);
                    
                    // Fill in the data
                    document.getElementById('info-type').textContent = formatStructureType(structure.structureType);
                    document.getElementById('info-line-type').textContent = 'N/A';
                    document.getElementById('info-size').textContent = structure.size + ' inches';
                    document.getElementById('info-depth').textContent = structure.depth + ' feet';
                    document.getElementById('info-material').textContent = structure.material || 'Unknown';
                    document.getElementById('info-direction').textContent = 'N/A';
                    
                    // Show image if available
                    const imageContainer = document.getElementById('info-image-container');
                    if (structure.photo) {
                        imageContainer.innerHTML = `<img src="${structure.photo}" alt="Structure Photo">`;
                        imageContainer.style.display = 'block';
                    } else {
                        imageContainer.style.display = 'none';
                    }
                }
                
                // Position the card
                let position;
                if (element.geometry === 'point') {
                    position = element.element.getLatLng();
                } else if (element.geometry === 'line') {
                    // For lines, use the midpoint
                    const points = element.element.getLatLngs();
                    position = points[Math.floor(points.length / 2)];
                }
                
                const positionPx = map.latLngToContainerPoint(position);
                infoCard.style.left = (positionPx.x - 150) + 'px'; // Center the 300px wide card
                infoCard.style.top = (positionPx.y - 250) + 'px';  // Position above the element
                
                // Show the card
                infoCard.classList.add('visible');
            }
            
            function hideInfoCard() {
                document.getElementById('info-card').classList.remove('visible');
            }
            
            function findElementAtPoint(latlng) {
                let foundElement = null;
                let minDistance = 20; // Maximum distance in pixels
                
                // Check utilities
                for (const type in utilities) {
                    for (const utility of utilities[type]) {
                        // Check markers
                        if (utility.marker) {
                            const distance = map.distance(latlng, utility.marker.getLatLng());
                            if (distance < minDistance) {
                                foundElement = {
                                    type: 'utility',
                                    id: utility.id,
                                    object: utility,
                                    element: utility.marker,
                                    geometry: 'point'
                                };
                                minDistance = distance;
                            }
                        }
                        
                        // Check polylines
                        if (utility.polyline) {
                            const points = utility.polyline.getLatLngs();
                            for (let i = 0; i < points.length - 1; i++) {
                                const distance = distanceToLine(latlng, points[i], points[i + 1]);
                                if (distance < minDistance) {
                                    foundElement = {
                                        type: 'utility',
                                        id: utility.id,
                                        object: utility,
                                        element: utility.polyline,
                                        geometry: 'line'
                                    };
                                    minDistance = distance;
                                }
                            }
                        }
                    }
                }
                
                // Check structures
                for (const structure of structures) {
                    if (structure.marker) {
                        const distance = map.distance(latlng, structure.marker.getLatLng());
                        if (distance < minDistance) {
                            foundElement = {
                                type: 'structure',
                                id: structure.id,
                                object: structure,
                                element: structure.marker,
                                geometry: 'point'
                            };
                            minDistance = distance;
                        }
                    }
                }
                
                return foundElement;
            }
            
            function distanceToLine(point, lineStart, lineEnd) {
                const x = point.lng;
                const y = point.lat;
                const x1 = lineStart.lng;
                const y1 = lineStart.lat;
                const x2 = lineEnd.lng;
                const y2 = lineEnd.lat;
                
                // Calculate distance using the point-to-line formula
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                
                // If len_sq is 0, the line is just a point
                if (len_sq === 0) return map.distance(point, lineStart);
                
                // Calculate projection of point onto line
                let param = dot / len_sq;
                
                // Clamp to line segment
                if (param < 0) param = 0;
                if (param > 1) param = 1;
                
                // Calculate closest point on line
                const xx = x1 + param * C;
                const yy = y1 + param * D;
                
                // Calculate distance
                return map.distance(point, L.latLng(yy, xx));
            }
            
            function createUtilityMarkerIcon(utilityType, lineType) {
                // Create HTML for the icon with appropriate classes
                const html = `
                    <div class="utility-marker ${utilityType} ${lineType === 'main' ? 'main' : ''}">
                        <i class="${getUtilityIcon(utilityType)}"></i>
                    </div>
                `;
                
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
            }
            
            function createStructureMarkerIcon(structureType) {
                // Create HTML for the icon with appropriate classes
                const html = `
                    <div class="structure-marker ${structureType}">
                        <i class="${getStructureIcon(structureType)}"></i>
                    </div>
                `;
                
                return L.divIcon({
                    html: html,
                    className: '',
                    iconSize: [36, 36],
                    iconAnchor: [18, 18]
                });
            }
            
            // ============ Editing & Selection Functions ============
            function editSelectedElement() {
                if (!selectedElement) return;
                
                // Hide info card
                hideInfoCard();
                
                if (selectedElement.type === 'utility') {
                    showAddUtilityModal(null, selectedElement.object);
                } else if (selectedElement.type === 'structure') {
                    showAddStructureModal(null, selectedElement.object);
                }
            }
            
            function deleteSelectedElement() {
                if (!selectedElement) return;
                
                if (selectedElement.type === 'utility') {
                    const utilityId = selectedElement.id;
                    const utilityType = selectedElement.object.type;
                    
                    // Remove from map
                    if (selectedElement.object.marker) {
                        window.utilitiesLayer.removeLayer(selectedElement.object.marker);
                    }
                    
                    if (selectedElement.object.polyline) {
                        window.utilitiesLayer.removeLayer(selectedElement.object.polyline);
                    }
                    
                    // Remove from data
                    const index = utilities[utilityType].findIndex(u => u.id === utilityId);
                    if (index !== -1) {
                        // Add to undo stack before removing
                        addToUndoStack({
                            type: 'delete-utility',
                            utility: utilities[utilityType][index],
                            utilityType: utilityType
                        });
                        
                        utilities[utilityType].splice(index, 1);
                    }
                    
                    showNotification('Utility deleted', 'success');
                } else if (selectedElement.type === 'structure') {
                    const structureId = selectedElement.id;
                    
                    // Remove from map
                    if (selectedElement.object.marker) {
                        window.structuresLayer.removeLayer(selectedElement.object.marker);
                    }
                    
                    // Remove from data
                    const index = structures.findIndex(s => s.id === structureId);
                    if (index !== -1) {
                        // Add to undo stack before removing
                        addToUndoStack({
                            type: 'delete-structure',
                            structure: structures[index]
                        });
                        
                        structures.splice(index, 1);
                    }
                    
                    showNotification('Structure deleted', 'success');
                }
                
                // Clear selection
                selectedElement = null;
                hideInfoCard();
            }
            
            function startMovingElement() {
                if (!selectedElement) return;
                
                // Hide info card
                hideInfoCard();
                
                // Configure based on element type
                if (selectedElement.type === 'utility') {
                    if (selectedElement.geometry === 'point') {
                        // Make the marker draggable
                        selectedElement.element.dragging.enable();
                        
                        // Listen for dragend event
                        selectedElement.element.once('dragend', function(e) {
                            const newPos = e.target.getLatLng();
                            
                            // Update the utility data
                            if (selectedElement.object.geometry === 'point') {
                                selectedElement.object.points = [newPos];
                            } else if (selectedElement.object.geometry === 'line') {
                                // If it's a line, we're moving the first point
                                selectedElement.object.points[0] = newPos;
                                
                                // Update the polyline
                                selectedElement.object.polyline.setLatLngs(selectedElement.object.points);
                            }
                            
                            // Disable dragging again
                            selectedElement.element.dragging.disable();
                            
                            showNotification('Utility moved successfully', 'success');
                        });
                        
                        updateStatus('Drag to move the utility, then tap to confirm position');
                    } else if (selectedElement.geometry === 'line') {
                        // For line utilities, initiate precision edit
                        startPrecisionEdit();
                    }
                } else if (selectedElement.type === 'structure') {
                    // Make the marker draggable
                    selectedElement.element.dragging.enable();
                    
                    // Listen for dragend event
                    selectedElement.element.once('dragend', function(e) {
                        const newPos = e.target.getLatLng();
                        
                        // Update the structure data
                        selectedElement.object.position = newPos;
                        
                        // Disable dragging again
                        selectedElement.element.dragging.disable();
                        
                        showNotification('Structure moved successfully', 'success');
                    });
                    
                    updateStatus('Drag to move the structure, then tap to confirm position');
                }
            }
            
            function startPrecisionEdit() {
                // Only works for line utilities
                if (!selectedElement || selectedElement.type !== 'utility' || selectedElement.geometry !== 'line') {
                    showNotification('Only utility lines can be precision edited', 'info');
                    return;
                }
                
                // Hide any open panels
                hideInfoCard();
                hideContextMenu();
                
                // Enter precision editing mode
                isPrecisionEditing = true;
                
                // Store original points for undo
                originalPoints = [...selectedElement.object.points];
                
                // Get the utility polyline
                const polyline = selectedElement.object.polyline;
                
                // Highlight the line being edited
                polyline.setStyle({
                    dashArray: '5,5',
                    color: getUtilityColor(selectedElement.object.type),
                    opacity: 0.8
                });
                
                // Add control handles at each point
                controlHandles = [];
                selectedElement.object.points.forEach((point, index) => {
                    const handle = createControlHandle(point, index);
                    controlHandles.push(handle);
                });
                
                // Zoom to the utility
                map.fitBounds(polyline.getBounds(), {
                    padding: [50, 50],
                    maxZoom: 20
                });
                
                // Show the precision editor overlay
                document.getElementById('precision-editor').classList.add('active');
                
                updateStatus('Drag control points to reposition utility line');
            }
            
            function createControlHandle(point, index) {
                const handleIcon = L.divIcon({
                    className: 'control-handle',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                const handle = L.marker(point, {
                    icon: handleIcon,
                    draggable: true,
                    zIndexOffset: 1000
                }).addTo(window.controlsLayer);
                
                // Store index for reference
                handle._index = index;
                
                // Add drag handler
                handle.on('drag', function(e) {
                    const newPos = e.target.getLatLng();
                    
                    // Update the point in the utility object
                    selectedElement.object.points[index] = newPos;
                    
                    // Update the polyline
                    selectedElement.object.polyline.setLatLngs(selectedElement.object.points);
                });
                
                return handle;
            }
            
            function confirmPrecisionEdit() {
                if (!isPrecisionEditing || !selectedElement) return;
                
                // Cleanup
                cleanupPrecisionEditing();
                
                // Add to undo stack
                addToUndoStack({
                    type: 'edit-utility-points',
                    utilityId: selectedElement.id,
                    originalPoints: originalPoints,
                    newPoints: [...selectedElement.object.points]
                });
                
                showNotification('Utility position updated', 'success');
                
                // Reset state
                isPrecisionEditing = false;
                originalPoints = null;
                selectedElement = null;
            }
            
            function cancelPrecisionEdit() {
                if (!isPrecisionEditing || !selectedElement) return;
                
                // Restore original points
                selectedElement.object.points = [...originalPoints];
                selectedElement.object.polyline.setLatLngs(originalPoints);
                
                // Cleanup
                cleanupPrecisionEditing();
                
                // Reset state
                isPrecisionEditing = false;
                originalPoints = null;
                selectedElement = null;
                
                showNotification('Precision edit canceled', 'info');
            }
            
            function cleanupPrecisionEditing() {
                // Remove control handles
                controlHandles.forEach(handle => {
                    window.controlsLayer.removeLayer(handle);
                });
                controlHandles = [];
                
                // Reset polyline style
                if (selectedElement && selectedElement.object.polyline) {
                    const weight = selectedElement.object.lineType === 'main' ? 6 : 4;
                    selectedElement.object.polyline.setStyle({
                        dashArray: null,
                        color: getUtilityColor(selectedElement.object.type),
                        weight: weight,
                        opacity: 1
                    });
                }
                
                // Hide the precision editor overlay
                document.getElementById('precision-editor').classList.remove('active');
            }
            
            // ============ Connecting Functions ============
            function startConnecting() {
                if (!selectedElement) {
                    showNotification('Select an element to connect first', 'info');
                    return;
                }
                
                // Set connecting state
                isConnecting = true;
                connectingSource = selectedElement;
                
                // Hide info card
                hideInfoCard();
                
                // Update UI
                updateStatus('Now tap on another utility or structure to connect to');
                
                // Highlight the source
                highlightElement(connectingSource);
            }
            
            function handleConnectingClick(latlng) {
                if (!isConnecting || !connectingSource) return;
                
                // Find element at click point
                const targetElement = findElementAtPoint(latlng);
                
                if (targetElement) {
                    // Check if trying to connect to self
                    if (targetElement.id === connectingSource.id) {
                        showNotification('Cannot connect an element to itself', 'info');
                        return;
                    }
                    
                    // Store target and show connection modal
                    showConnectModal(connectingSource, targetElement);
                } else {
                    // If clicking on empty space, cancel connecting
                    cancelConnecting();
                }
            }
            
            function showConnectModal(source, target) {
                // Store the elements for later use
                document.getElementById('connect-modal').dataset.sourceId = source.id;
                document.getElementById('connect-modal').dataset.sourceType = source.type;
                document.getElementById('connect-modal').dataset.targetId = target.id;
                document.getElementById('connect-modal').dataset.targetType = target.type;
                
                // Show the modal
                showModal('connect-modal');
            }
            
            function confirmConnection() {
                // Get source and target from dataset
                const sourceId = document.getElementById('connect-modal').dataset.sourceId;
                const sourceType = document.getElementById('connect-modal').dataset.sourceType;
                const targetId = document.getElementById('connect-modal').dataset.targetId;
                const targetType = document.getElementById('connect-modal').dataset.targetType;
                
                // Get connection type from selected option
                const connectionType = document.querySelector('#connect-modal .option-item.selected').getAttribute('data-value');
                
                // Get notes
                const notes = document.getElementById('connection-notes').value;
                
                // Create connection based on element types
                if (sourceType === 'utility' && targetType === 'utility') {
                    connectUtilities(sourceId, targetId, connectionType, notes);
                } else if (sourceType === 'utility' && targetType === 'structure') {
                    connectUtilityToStructure(sourceId, targetId, connectionType, notes);
                } else if (sourceType === 'structure' && targetType === 'utility') {
                    connectUtilityToStructure(targetId, sourceId, connectionType, notes);
                } else if (sourceType === 'structure' && targetType === 'structure') {
                    connectStructures(sourceId, targetId, connectionType, notes);
                }
                
                // Clear state
                cancelConnecting();
                
                // Hide modal
                hideModal('connect-modal');
                
                showNotification('Connection created successfully', 'success');
            }
            
            function connectUtilities(sourceId, targetId, connectionType, notes) {
                const sourceUtility = findUtilityById(sourceId);
                const targetUtility = findUtilityById(targetId);
                
                if (!sourceUtility || !targetUtility) return;
                
                // Create connection data
                const connectionId = 'connection-' + Date.now();
                const connection = {
                    id: connectionId,
                    sourceId: sourceId,
                    targetId: targetId,
                    sourceType: 'utility',
                    targetType: 'utility',
                    connectionType: connectionType,
                    notes: notes
                };
                
                // Store connection in both utilities
                if (!sourceUtility.connections) sourceUtility.connections = [];
                if (!targetUtility.connections) targetUtility.connections = [];
                
                sourceUtility.connections.push(connection);
                targetUtility.connections.push(connection);
                
                // Visual connection based on type
                if (connectionType === 'direct') {
                    createDirectConnection(sourceUtility, targetUtility);
                } else if (connectionType === 'tap') {
                    createTapConnection(sourceUtility, targetUtility);
                } else if (connectionType === 'offset') {
                    createOffsetConnection(sourceUtility, targetUtility);
                }
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-connection',
                    connection: connection
                });
            }
            
            function connectUtilityToStructure(utilityId, structureId, connectionType, notes) {
                const utility = findUtilityById(utilityId);
                const structure = findStructureById(structureId);
                
                if (!utility || !structure) return;
                
                // Create connection data
                const connectionId = 'connection-' + Date.now();
                const connection = {
                    id: connectionId,
                    sourceId: utilityId,
                    targetId: structureId,
                    sourceType: 'utility',
                    targetType: 'structure',
                    connectionType: connectionType,
                    notes: notes
                };
                
                // Store connection in both objects
                if (!utility.connections) utility.connections = [];
                if (!structure.connections) structure.connections = [];
                
                utility.connections.push(connection);
                structure.connections.push(connection);
                
                // Visual connection
                createUtilityToStructureConnection(utility, structure, connectionType);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-connection',
                    connection: connection
                });
            }
            
            function connectStructures(sourceId, targetId, connectionType, notes) {
                const sourceStructure = findStructureById(sourceId);
                const targetStructure = findStructureById(targetId);
                
                if (!sourceStructure || !targetStructure) return;
                
                // Create connection data
                const connectionId = 'connection-' + Date.now();
                const connection = {
                    id: connectionId,
                    sourceId: sourceId,
                    targetId: targetId,
                    sourceType: 'structure',
                    targetType: 'structure',
                    connectionType: connectionType,
                    notes: notes
                };
                
                // Store connection in both structures
                if (!sourceStructure.connections) sourceStructure.connections = [];
                if (!targetStructure.connections) targetStructure.connections = [];
                
                sourceStructure.connections.push(connection);
                targetStructure.connections.push(connection);
                
                // Visual connection
                createStructureConnection(sourceStructure, targetStructure, connectionType);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-connection',
                    connection: connection
                });
            }
            
            function createDirectConnection(sourceUtility, targetUtility) {
                // Get endpoints for connection
                let sourcePoint, targetPoint;
                
                if (sourceUtility.geometry === 'point') {
                    sourcePoint = sourceUtility.points[0];
                } else {
                    // Use the endpoint closest to the target
                    const start = sourceUtility.points[0];
                    const end = sourceUtility.points[sourceUtility.points.length - 1];
                    
                    let targetRefPoint;
                    if (targetUtility.geometry === 'point') {
                        targetRefPoint = targetUtility.points[0];
                    } else {
                        targetRefPoint = getClosestEndpoint(targetUtility.points, start);
                    }
                    
                    sourcePoint = map.distance(start, targetRefPoint) < map.distance(end, targetRefPoint) ? start : end;
                }
                
                if (targetUtility.geometry === 'point') {
                    targetPoint = targetUtility.points[0];
                } else {
                    // Use the endpoint closest to the source
                    const start = targetUtility.points[0];
                    const end = targetUtility.points[targetUtility.points.length - 1];
                    
                    targetPoint = map.distance(sourcePoint, start) < map.distance(sourcePoint, end) ? start : end;
                }
                
                // Create a polyline connecting them
                const connectionLine = L.polyline([sourcePoint, targetPoint], {
                    color: getUtilityColor(sourceUtility.type),
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '5,5'
                }).addTo(window.utilitiesLayer);
                
                // Store reference to the connection line
                if (!sourceUtility.connectionLines) sourceUtility.connectionLines = [];
                if (!targetUtility.connectionLines) targetUtility.connectionLines = [];
                
                sourceUtility.connectionLines.push(connectionLine);
                targetUtility.connectionLines.push(connectionLine);
            }
            
            function createTapConnection(serviceUtility, mainUtility) {
                // Only works if target is a main and has a polyline
                if (mainUtility.lineType !== 'main' || !mainUtility.polyline || serviceUtility.lineType !== 'service') {
                    createDirectConnection(serviceUtility, mainUtility);
                    return;
                }
                
                // Get service endpoint
                const servicePoint = serviceUtility.geometry === 'point' ? 
                                    serviceUtility.points[0] : 
                                    getClosestEndpoint(serviceUtility.points, mainUtility.points[0]);
                
                // Find closest point on main line
                const mainPoints = mainUtility.polyline.getLatLngs();
                let minDist = Infinity;
                let closestPoint = null;
                
                for (let i = 0; i < mainPoints.length - 1; i++) {
                    const p1 = mainPoints[i];
                    const p2 = mainPoints[i + 1];
                    
                    const point = getClosestPointOnSegment(servicePoint, p1, p2);
                    const dist = map.distance(servicePoint, point);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestPoint = point;
                    }
                }
                
                if (!closestPoint) return;
                
                // Create a polyline connecting them
                const connectionLine = L.polyline([servicePoint, closestPoint], {
                    color: getUtilityColor(serviceUtility.type),
                    weight: 3,
                    opacity: 0.8
                }).addTo(window.utilitiesLayer);
                
                // Store reference to the connection line
                if (!serviceUtility.connectionLines) serviceUtility.connectionLines = [];
                if (!mainUtility.connectionLines) mainUtility.connectionLines = [];
                
                serviceUtility.connectionLines.push(connectionLine);
                mainUtility.connectionLines.push(connectionLine);
                
                // Add a tap marker
                const tapIcon = L.divIcon({
                    html: `<div style="width:10px; height:10px; background-color:${getUtilityColor(serviceUtility.type)}; border:2px solid white; border-radius:50%;"></div>`,
                    className: '',
                    iconSize: [10, 10],
                    iconAnchor: [5, 5]
                });
                
                const tapMarker = L.marker(closestPoint, {
                    icon: tapIcon
                }).addTo(window.utilitiesLayer);
                
                // Store reference
                if (!serviceUtility.markers) serviceUtility.markers = [];
                serviceUtility.markers.push(tapMarker);
            }
            
            function createOffsetConnection(sourceUtility, targetUtility) {
                // Get endpoints
                let sourcePoint, targetPoint;
                
                if (sourceUtility.geometry === 'point') {
                    sourcePoint = sourceUtility.points[0];
                } else {
                    // Use the endpoint closest to the target
                    const start = sourceUtility.points[0];
                    const end = sourceUtility.points[sourceUtility.points.length - 1];
                    
                    let targetRefPoint;
                    if (targetUtility.geometry === 'point') {
                        targetRefPoint = targetUtility.points[0];
                    } else {
                        targetRefPoint = getClosestEndpoint(targetUtility.points, start);
                    }
                    
                    sourcePoint = map.distance(start, targetRefPoint) < map.distance(end, targetRefPoint) ? start : end;
                }
                
                if (targetUtility.geometry === 'point') {
                    targetPoint = targetUtility.points[0];
                } else {
                    // Use the endpoint closest to the source
                    const start = targetUtility.points[0];
                    const end = targetUtility.points[targetUtility.points.length - 1];
                    
                    targetPoint = map.distance(sourcePoint, start) < map.distance(sourcePoint, end) ? start : end;
                }
                
                // Calculate midpoint with slight offset
                const dx = targetPoint.lng - sourcePoint.lng;
                const dy = targetPoint.lat - sourcePoint.lat;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate perpendicular offset
                const offsetX = -dy / dist * 0.0001; // Slight offset perpendicular to line
                const offsetY = dx / dist * 0.0001;
                
                const midpoint = L.latLng(
                    (sourcePoint.lat + targetPoint.lat) / 2 + offsetY,
                    (sourcePoint.lng + targetPoint.lng) / 2 + offsetX
                );
                
                // Create a polyline with the midpoint
                const connectionLine = L.polyline([sourcePoint, midpoint, targetPoint], {
                    color: getUtilityColor(sourceUtility.type),
                    weight: 3,
                    opacity: 0.8,
                    dashArray: '5,5'
                }).addTo(window.utilitiesLayer);
                
                // Store reference to the connection line
                if (!sourceUtility.connectionLines) sourceUtility.connectionLines = [];
                if (!targetUtility.connectionLines) targetUtility.connectionLines = [];
                
                sourceUtility.connectionLines.push(connectionLine);
                targetUtility.connectionLines.push(connectionLine);
            }
            
            function createUtilityToStructureConnection(utility, structure, connectionType) {
                // Get connection points
                let utilityPoint;
                const structurePoint = structure.position;
                
                if (utility.geometry === 'point') {
                    utilityPoint = utility.points[0];
                } else {
                    // Use the endpoint closest to the structure
                    const start = utility.points[0];
                    const end = utility.points[utility.points.length - 1];
                    
                    utilityPoint = map.distance(start, structurePoint) < map.distance(end, structurePoint) ? start : end;
                }
                
                // Create connection based on type
                if (connectionType === 'direct' || connectionType === 'tap') {
                    // Create a direct line
                    const connectionLine = L.polyline([utilityPoint, structurePoint], {
                        color: getUtilityColor(utility.type),
                        weight: 3,
                        opacity: 0.8
                    }).addTo(window.utilitiesLayer);
                    
                    // Store reference to the connection line
                    if (!utility.connectionLines) utility.connectionLines = [];
                    if (!structure.connectionLines) structure.connectionLines = [];
                    
                    utility.connectionLines.push(connectionLine);
                    structure.connectionLines.push(connectionLine);
                } else if (connectionType === 'offset') {
                    // Calculate midpoint with slight offset
                    const dx = structurePoint.lng - utilityPoint.lng;
                    const dy = structurePoint.lat - utilityPoint.lat;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate perpendicular offset
                    const offsetX = -dy / dist * 0.0001;
                    const offsetY = dx / dist * 0.0001;
                    
                    const midpoint = L.latLng(
                        (utilityPoint.lat + structurePoint.lat) / 2 + offsetY,
                        (utilityPoint.lng + structurePoint.lng) / 2 + offsetX
                    );
                    
                    // Create a polyline with the midpoint
                    const connectionLine = L.polyline([utilityPoint, midpoint, structurePoint], {
                        color: getUtilityColor(utility.type),
                        weight: 3,
                        opacity: 0.8,
                        dashArray: '5,5'
                    }).addTo(window.utilitiesLayer);
                    
                    // Store reference to the connection line
                    if (!utility.connectionLines) utility.connectionLines = [];
                    if (!structure.connectionLines) structure.connectionLines = [];
                    
                    utility.connectionLines.push(connectionLine);
                    structure.connectionLines.push(connectionLine);
                }
            }
            
            function createStructureConnection(sourceStructure, targetStructure, connectionType) {
                const sourcePoint = sourceStructure.position;
                const targetPoint = targetStructure.position;
                
                // Determine the utility type to use for color
                // For sewer structures, use sewer color
                let connectionColor = '#757575'; // Default gray
                
                if (sourceStructure.structureType === 'catch-basin' || 
                    sourceStructure.structureType === 'manhole' ||
                    targetStructure.structureType === 'catch-basin' || 
                    targetStructure.structureType === 'manhole') {
                    connectionColor = getUtilityColor('sewer');
                } else if (sourceStructure.structureType === 'electrical-box' || 
                          targetStructure.structureType === 'electrical-box') {
                    connectionColor = getUtilityColor('electric');
                } else if (sourceStructure.structureType === 'valve' || 
                          targetStructure.structureType === 'valve') {
                    connectionColor = getUtilityColor('water');
                }
                
                // Create connection based on type
                if (connectionType === 'direct') {
                    // Create a direct line
                    const connectionLine = L.polyline([sourcePoint, targetPoint], {
                        color: connectionColor,
                        weight: 3,
                        opacity: 0.8
                    }).addTo(window.utilitiesLayer);
                    
                    // Store reference to the connection line
                    if (!sourceStructure.connectionLines) sourceStructure.connectionLines = [];
                    if (!targetStructure.connectionLines) targetStructure.connectionLines = [];
                    
                    sourceStructure.connectionLines.push(connectionLine);
                    targetStructure.connectionLines.push(connectionLine);
                } else if (connectionType === 'offset' || connectionType === 'tap') {
                    // Calculate midpoint with slight offset
                    const dx = targetPoint.lng - sourcePoint.lng;
                    const dy = targetPoint.lat - sourcePoint.lat;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Calculate perpendicular offset
                    const offsetX = -dy / dist * 0.0001;
                    const offsetY = dx / dist * 0.0001;
                    
                    const midpoint = L.latLng(
                        (sourcePoint.lat + targetPoint.lat) / 2 + offsetY,
                        (sourcePoint.lng + targetPoint.lng) / 2 + offsetX
                    );
                    
                    // Create a polyline with the midpoint
                    const connectionLine = L.polyline([sourcePoint, midpoint, targetPoint], {
                        color: connectionColor,
                        weight: 3,
                        opacity: 0.8,
                        dashArray: connectionType === 'offset' ? '5,5' : null
                    }).addTo(window.utilitiesLayer);
                    
                    // Store reference to the connection line
                    if (!sourceStructure.connectionLines) sourceStructure.connectionLines = [];
                    if (!targetStructure.connectionLines) targetStructure.connectionLines = [];
                    
                    sourceStructure.connectionLines.push(connectionLine);
                    targetStructure.connectionLines.push(connectionLine);
                }
            }
            
            function cancelConnecting() {
                // Reset connecting state
                isConnecting = false;
                
                // Unhighlight if source exists
                if (connectingSource) {
                    unhighlightElement(connectingSource);
                    connectingSource = null;
                }
                
                // Update status
                updateStatus('Connection canceled');
            }
            
            function highlightElement(element) {
                if (!element) return;
                
                if (element.type === 'utility') {
                    if (element.geometry === 'line' && element.object.polyline) {
                        element.object.polyline.setStyle({
                            weight: element.object.lineType === 'main' ? 8 : 6,
                            dashArray: '10,5',
                            opacity: 1
                        });
                    }
                    
                    if (element.object.marker) {
                        element.object.marker._icon.classList.add('animate__animated', 'animate__pulse');
                        element.object.marker._icon.style.animationIterationCount = 'infinite';
                    }
                } else if (element.type === 'structure') {
                    if (element.object.marker) {
                        element.object.marker._icon.classList.add('animate__animated', 'animate__pulse');
                        element.object.marker._icon.style.animationIterationCount = 'infinite';
                    }
                }
            }
            
            function unhighlightElement(element) {
                if (!element) return;
                
                if (element.type === 'utility') {
                    if (element.geometry === 'line' && element.object.polyline) {
                        const weight = element.object.lineType === 'main' ? 6 : 4;
                        element.object.polyline.setStyle({
                            weight: weight,
                            dashArray: null,
                            opacity: 1
                        });
                    }
                    
                    if (element.object.marker && element.object.marker._icon) {
                        element.object.marker._icon.classList.remove('animate__animated', 'animate__pulse');
                        element.object.marker._icon.style.animationIterationCount = '';
                    }
                } else if (element.type === 'structure') {
                    if (element.object.marker && element.object.marker._icon) {
                        element.object.marker._icon.classList.remove('animate__animated', 'animate__pulse');
                        element.object.marker._icon.style.animationIterationCount = '';
                    }
                }
            }
            
            // ============ Measurement Functions ============
            function toggleMeasureMode() {
                if (isMeasuring) {
                    cancelMeasurement();
                    document.getElementById('measure-button').classList.remove('active');
                    updateStatus('Measurement mode canceled');
                } else {
                    startMeasurement();
                    document.getElementById('measure-button').classList.add('active');
                    updateStatus('Tap on the map to set starting point for measurement');
                }
            }
            
            function startMeasurement() {
                isMeasuring = true;
                measureStartPoint = null;
                
                // Cancel any other active modes
                cancelDrawing();
                cancelPrecisionEdit();
                cancelConnecting();
                resetActions();
            }
            
            function handleMeasurementClick(latlng) {
                if (!measureStartPoint) {
                    // First click - set start point
                    measureStartPoint = latlng;
                    
                    // Create marker for start point
                    L.circleMarker(latlng, {
                        radius: 5,
                        color: '#2196f3',
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(window.measurementsLayer);
                    
                    updateStatus('Tap on the map to set endpoint and measure distance');
                } else {
                    // Second click - complete measurement
                    const endPoint = latlng;
                    
                    // Create final measurement
                    finalizeMeasurement(measureStartPoint, endPoint);
                    
                    // Reset for next measurement
                    measureStartPoint = null;
                    updateStatus('Measurement added. Tap on the map to start a new measurement');
                }
            }
            
            function updateMeasurementLine(startPoint, endPoint) {
                // Remove previous temporary line and tooltip
                if (measureLine) {
                    window.measurementsLayer.removeLayer(measureLine);
                }
                
                if (measureTooltip) {
                    window.measurementsLayer.removeLayer(measureTooltip);
                }
                
                // Create new line
                measureLine = L.polyline([startPoint, endPoint], {
                    color: '#2196f3',
                    weight: 3,
                    opacity: 0.7,
                    dashArray: '5,5',
                    className: 'measurement-line'
                }).addTo(window.measurementsLayer);
                
                // Calculate distance
                const distance = map.distance(startPoint, endPoint);
                const formattedDistance = formatDistance(distance);
                
                // Create tooltip
                const midPoint = L.latLng(
                    (startPoint.lat + endPoint.lat) / 2,
                    (startPoint.lng + endPoint.lng) / 2
                );
                
                const tooltipIcon = L.divIcon({
                    html: `<div class="measurement-tooltip">${formattedDistance}</div>`,
                    className: '',
                    iconSize: [80, 24],
                    iconAnchor: [40, 12]
                });
                
                measureTooltip = L.marker(midPoint, {
                    icon: tooltipIcon,
                    interactive: false
                }).addTo(window.measurementsLayer);
            }
            
            function finalizeMeasurement(startPoint, endPoint) {
                // Create marker for end point
                L.circleMarker(endPoint, {
                    radius: 5,
                    color: '#2196f3',
                    fillColor: '#fff',
                    fillOpacity: 1,
                    weight: 2
                }).addTo(window.measurementsLayer);
                
                // Create permanent line
                const line = L.polyline([startPoint, endPoint], {
                    color: '#2196f3',
                    weight: 3,
                    opacity: 0.9,
                    className: 'measurement-line'
                }).addTo(window.measurementsLayer);
                
                // Calculate distance
                const distance = map.distance(startPoint, endPoint);
                const formattedDistance = formatDistance(distance);
                
                // Create permanent tooltip
                const midPoint = L.latLng(
                    (startPoint.lat + endPoint.lat) / 2,
                    (startPoint.lng + endPoint.lng) / 2
                );
                
                const tooltipIcon = L.divIcon({
                    html: `<div class="measurement-tooltip">${formattedDistance}</div>`,
                    className: '',
                    iconSize: [80, 24],
                    iconAnchor: [40, 12]
                });
                
                const tooltip = L.marker(midPoint, {
                    icon: tooltipIcon
                }).addTo(window.measurementsLayer);
                
                // Add click handler to remove the measurement
                tooltip.on('click', function() {
                    // Remove all elements of this measurement
                    window.measurementsLayer.removeLayer(line);
                    window.measurementsLayer.removeLayer(tooltip);
                    
                    // Remove from the measurements array
                    const index = measurements.findIndex(m => m.line === line);
                    if (index !== -1) {
                        measurements.splice(index, 1);
                    }
                    
                    showNotification('Measurement removed', 'info');
                });
                
                // Store measurement data
                measurements.push({
                    startPoint: startPoint,
                    endPoint: endPoint,
                    distance: distance,
                    line: line,
                    tooltip: tooltip
                });
                
                // Clean up temporary elements
                if (measureLine) {
                    window.measurementsLayer.removeLayer(measureLine);
                    measureLine = null;
                }
                
                if (measureTooltip) {
                    window.measurementsLayer.removeLayer(measureTooltip);
                    measureTooltip = null;
                }
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-measurement',
                    startPoint: startPoint,
                    endPoint: endPoint,
                    line: line,
                    tooltip: tooltip
                });
                
                showNotification('Measurement added: ' + formattedDistance, 'success');
            }
            
            function startMeasureFromElement() {
                if (!selectedElement) return;
                
                // Enter measurement mode
                startMeasurement();
                document.getElementById('measure-button').classList.add('active');
                
                // Set start point based on element type
                if (selectedElement.type === 'utility') {
                    if (selectedElement.geometry === 'point') {
                        measureStartPoint = selectedElement.object.points[0];
                    } else {
                        // For lines, use closest endpoint to map center
                        const mapCenter = map.getCenter();
                        measureStartPoint = getClosestEndpoint(selectedElement.object.points, mapCenter);
                    }
                } else if (selectedElement.type === 'structure') {
                    measureStartPoint = selectedElement.object.position;
                }
                
                if (measureStartPoint) {
                    // Create marker for start point
                    L.circleMarker(measureStartPoint, {
                        radius: 5,
                        color: '#2196f3',
                        fillColor: '#fff',
                        fillOpacity: 1,
                        weight: 2
                    }).addTo(window.measurementsLayer);
                    
                    updateStatus('Now tap on the map to measure distance from selected element');
                }
            }
            
            function cancelMeasurement() {
                isMeasuring = false;
                
                // Clean up any temporary elements
                if (measureLine) {
                    window.measurementsLayer.removeLayer(measureLine);
                    measureLine = null;
                }
                
                if (measureTooltip) {
                    window.measurementsLayer.removeLayer(measureTooltip);
                    measureTooltip = null;
                }
                
                measureStartPoint = null;
                document.getElementById('measure-button').classList.remove('active');
            }
            
            // ============ Annotation Functions ============
            function startAnnotation() {
                // Cancel any other active modes
                cancelDrawing();
                cancelMeasurement();
                cancelPrecisionEdit();
                cancelConnecting();
                resetActions();
                
                // Set active button
                document.getElementById('annotate-button').classList.add('active');
                
                // Show annotation modal
                showModal('add-annotation-modal');
            }
            
            function startAnnotationFromElement() {
                if (!selectedElement) return;
                
                // Show annotation modal
                showModal('add-annotation-modal');
                
                // Store element reference in the form
                document.getElementById('annotation-modal').dataset.elementId = selectedElement.id;
                document.getElementById('annotation-modal').dataset.elementType = selectedElement.type;
            }
            
            function confirmAddAnnotation() {
                const text = document.getElementById('annotation-text').value.trim();
                
                if (!text) {
                    showNotification('Please enter annotation text', 'warning');
                    return;
                }
                
                // Get annotation type
                const type = document.querySelector('input[name="annotation-type"]:checked').value;
                
                // Get position - either from mouse or from element
                let position;
                
                const elementId = document.getElementById('annotation-modal').dataset.elementId;
                const elementType = document.getElementById('annotation-modal').dataset.elementType;
                
                if (elementId && elementType) {
                    // Position based on element
                    if (elementType === 'utility') {
                        const utility = findUtilityById(elementId);
                        if (utility) {
                            if (utility.geometry === 'point') {
                                position = utility.points[0];
                            } else {
                                // For lines, use midpoint
                                const points = utility.points;
                                const midIndex = Math.floor(points.length / 2);
                                position = points[midIndex];
                            }
                        }
                    } else if (elementType === 'structure') {
                        const structure = findStructureById(elementId);
                        if (structure) {
                            position = structure.position;
                        }
                    }
                } else {
                    // Use map center as fallback
                    position = map.getCenter();
                }
                
                if (!position) {
                    hideModal('add-annotation-modal');
                    showNotification('Could not determine annotation position', 'error');
                    return;
                }
                
                // Create annotation
                addAnnotation(position, text, type);
                
                // Reset form
                document.getElementById('annotation-text').value = '';
                document.getElementById('annotation-modal').dataset.elementId = '';
                document.getElementById('annotation-modal').dataset.elementType = '';
                
                // Hide modal
                hideModal('add-annotation-modal');
                
                // Reset button state
                document.getElementById('annotate-button').classList.remove('active');
            }
            
            function addAnnotation(position, text, type) {
                // Create annotation data
                const annotationId = 'annotation-' + Date.now();
                const annotation = {
                    id: annotationId,
                    position: position,
                    text: text,
                    type: type
                };
                
                // Create marker with appropriate icon
                let iconClass, iconColor;
                
                switch(type) {
                    case 'measurement':
                        iconClass = 'fas fa-ruler';
                        iconColor = '#2196f3';
                        break;
                    case 'warning':
                        iconClass = 'fas fa-exclamation-triangle';
                        iconColor = '#ff9800';
                        break;
                    case 'note':
                    default:
                        iconClass = 'fas fa-info-circle';
                        iconColor = '#4caf50';
                        break;
                }
                
                const labelIcon = L.divIcon({
                    html: `
                        <div class="annotation-label">
                            <i class="${iconClass}" style="color: ${iconColor}"></i>
                            ${text}
                        </div>
                    `,
                    className: '',
                    iconSize: [150, 30],
                    iconAnchor: [75, 15]
                });
                
                const marker = L.marker(position, {
                    icon: labelIcon,
                    draggable: true
                }).addTo(window.annotationsLayer);
                
                // Store marker reference
                annotation.marker = marker;
                
                // Add click handler to edit/remove
                marker.on('click', function() {
                    // Show context menu for annotation
                    const menu = L.popup()
                        .setLatLng(position)
                        .setContent(`
                            <div style="text-align:center">
                                <div style="margin-bottom:8px">${text}</div>
                                <button class="btn btn-text annotation-edit">Edit</button>
                                <button class="btn btn-text annotation-delete">Delete</button>
                            </div>
                        `)
                        .openOn(map);
                    
                    // Add handlers for buttons
                    L.DomEvent.on(menu._contentNode.querySelector('.annotation-edit'), 'click', function() {
                        map.closePopup();
                        editAnnotation(annotation);
                    });
                    
                    L.DomEvent.on(menu._contentNode.querySelector('.annotation-delete'), 'click', function() {
                        map.closePopup();
                        deleteAnnotation(annotation);
                    });
                });
                
                // Store in annotations array
                annotations.push(annotation);
                
                // Add to undo stack
                addToUndoStack({
                    type: 'add-annotation',
                    annotation: annotation
                });
                
                showNotification('Annotation added', 'success');
            }
            
            function editAnnotation(annotation) {
                // Populate the annotation modal
                document.getElementById('annotation-text').value = annotation.text;
                
                // Set the radio button for type
                document.querySelector(`input[name="annotation-type"][value="${annotation.type}"]`).checked = true;
                
                // Store annotation ID for reference
                document.getElementById('annotation-modal').dataset.annotationId = annotation.id;
                
                // Show the modal
                showModal('add-annotation-modal');
                
                // Update the confirm button
                document.getElementById('annotation-confirm').textContent = 'Update Annotation';
                
                // Add a special handler for update
                document.getElementById('annotation-confirm').onclick = function() {
                    const text = document.getElementById('annotation-text').value.trim();
                    
                    if (!text) {
                        showNotification('Please enter annotation text', 'warning');
                        return;
                    }
                    
                    // Get annotation type
                    const type = document.querySelector('input[name="annotation-type"]:checked').value;
                    
                    // Update the annotation
                    annotation.text = text;
                    annotation.type = type;
                    
                    // Update the marker icon
                    let iconClass, iconColor;
                    
                    switch(type) {
                        case 'measurement':
                            iconClass = 'fas fa-ruler';
                            iconColor = '#2196f3';
                            break;
                        case 'warning':
                            iconClass = 'fas fa-exclamation-triangle';
                            iconColor = '#ff9800';
                            break;
                        case 'note':
                        default:
                            iconClass = 'fas fa-info-circle';
                            iconColor = '#4caf50';
                            break;
                    }
                    
                    const labelIcon = L.divIcon({
                        html: `
                            <div class="annotation-label">
                                <i class="${iconClass}" style="color: ${iconColor}"></i>
                                ${text}
                            </div>
                        `,
                        className: '',
                        iconSize: [150, 30],
                        iconAnchor: [75, 15]
                    });
                    
                    annotation.marker.setIcon(labelIcon);
                    
                    // Reset modal
                    document.getElementById('annotation-text').value = '';
                    document.getElementById('annotation-modal').dataset.annotationId = '';
                    
                    // Hide modal
                    hideModal('add-annotation-modal');
                    
                    // Reset confirm button
                    document.getElementById('annotation-confirm').textContent = 'Add Annotation';
                    document.getElementById('annotation-confirm').onclick = confirmAddAnnotation;
                    
                    showNotification('Annotation updated', 'success');
                };
            }
            
            function deleteAnnotation(annotation) {
                // Remove marker from map
                if (annotation.marker) {
                    window.annotationsLayer.removeLayer(annotation.marker);
                }
                
                // Remove from annotations array
                const index = annotations.findIndex(a => a.id === annotation.id);
                if (index !== -1) {
                    annotations.splice(index, 1);
                }
                
                // Add to undo stack
                addToUndoStack({
                    type: 'delete-annotation',
                    annotation: annotation
                });
                
                showNotification('Annotation deleted', 'info');
            }
            
            // ============ Data Management Functions ============
            function saveData() {
                try {
                    // Create data object
                    const data = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        mapCenter: map.getCenter(),
                        mapZoom: map.getZoom(),
                        utilities: utilities,
                        structures: structures,
                        annotations: annotations,
                        measurements: measurements.map(m => ({
                            startPoint: m.startPoint,
                            endPoint: m.endPoint,
                            distance: m.distance
                        }))
                    };
                    
                    // Convert to JSON
                    const jsonData = JSON.stringify(data);
                    
                    // Save to localStorage
                    localStorage.setItem('cacUtilityProData', jsonData);
                    
                    showNotification('Data saved successfully', 'success');
                } catch (error) {
                    console.error('Error saving data:', error);
                    showNotification('Error saving data: ' + error.message, 'error');
                }
            }
            
            function loadSavedData() {
                try {
                    // Get data from localStorage
                    const jsonData = localStorage.getItem('cacUtilityProData');
                    
                    if (!jsonData) {
                        // No saved data
                        return false;
                    }
                    
                    // Parse JSON
                    const data = JSON.parse(jsonData);
                    
                    // Check version compatibility
                    if (data.version !== '1.0') {
                        showNotification('Warning: Loading data from a different version', 'warning');
                    }
                    
                    // Clear existing data
                    clearAllData(false); // Silent clear
                    
                    // Restore map center and zoom
                    if (data.mapCenter) {
                        map.setView([data.mapCenter.lat, data.mapCenter.lng], data.mapZoom || 16);
                    }
                    
                    // Load utilities
                    if (data.utilities) {
                        for (const type in data.utilities) {
                            utilities[type] = [...data.utilities[type]];
                            
                            // Restore objects on map
                            utilities[type].forEach(utility => {
                                // Convert string coordinates to LatLng objects
                                if (utility.points) {
                                    utility.points = utility.points.map(point => 
                                        L.latLng(point.lat, point.lng)
                                    );
                                }
                                
                                // Add to map
                                addUtilityToMap(utility);
                            });
                        }
                    }
                    
                    // Load structures
                    if (data.structures) {
                        data.structures.forEach(structure => {
                            // Convert string coordinates to LatLng objects
                            if (structure.position) {
                                structure.position = L.latLng(structure.position.lat, structure.position.lng);
                            }
                            
                            // Add to structures array
                            structures.push(structure);
                            
                            // Add to map
                            addStructureToMap(structure);
                        });
                    }
                    
                    // Load annotations
                    if (data.annotations) {
                        data.annotations.forEach(annotation => {
                            // Convert string coordinates to LatLng objects
                            if (annotation.position) {
                                annotation.position = L.latLng(annotation.position.lat, annotation.position.lng);
                                addAnnotation(annotation.position, annotation.text, annotation.type);
                            }
                        });
                    }
                    
                    // Load measurements
                    if (data.measurements) {
                        data.measurements.forEach(measurement => {
                            // Convert string coordinates to LatLng objects
                            if (measurement.startPoint && measurement.endPoint) {
                                const startPoint = L.latLng(measurement.startPoint.lat, measurement.startPoint.lng);
                                const endPoint = L.latLng(measurement.endPoint.lat, measurement.endPoint.lng);
                                finalizeMeasurement(startPoint, endPoint);
                            }
                        });
                    }
                    
                    showNotification('Data loaded successfully', 'success');
                    return true;
                } catch (error) {
                    console.error('Error loading data:', error);
                    showNotification('Error loading data: ' + error.message, 'error');
                    return false;
                }
            }
            
            function exportData() {
                try {
                    // Create data object
                    const data = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        mapCenter: map.getCenter(),
                        mapZoom: map.getZoom(),
                        utilities: utilities,
                        structures: structures,
                        annotations: annotations,
                        measurements: measurements.map(m => ({
                            startPoint: m.startPoint,
                            endPoint: m.endPoint,
                            distance: m.distance
                        }))
                    };
                    
                    // Convert to JSON
                    const jsonData = JSON.stringify(data);
                    
                    // Create a blob
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    
                    // Create download link
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'cac-utility-pro-data.json';
                    
                    // Trigger download
                    document.body.appendChild(a);
                    a.click();
                    
                    // Cleanup
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                    
                    showNotification('Data exported successfully', 'success');
                } catch (error) {
                    console.error('Error exporting data:', error);
                    showNotification('Error exporting data: ' + error.message, 'error');
                }
            }
            
            function importData() {
                try {
                    // Create file input
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.json';
                    
                    // Handle file selection
                    fileInput.onchange = function(e) {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        const reader = new FileReader();
                        
                        reader.onload = function(event) {
                            try {
                                // Parse JSON
                                const data = JSON.parse(event.target.result);
                                
                                // Check version compatibility
                                if (data.version !== '1.0') {
                                    showNotification('Warning: Importing data from a different version', 'warning');
                                }
                                
                                // Confirm before replacing data
                                if (confirm('This will replace all current data. Continue?')) {
                                    // Clear existing data
                                    clearAllData(false); // Silent clear
                                    
                                    // Restore map center and zoom
                                    if (data.mapCenter) {
                                        map.setView([data.mapCenter.lat, data.mapCenter.lng], data.mapZoom || 16);
                                    }
                                    
                                    // Load utilities
                                    if (data.utilities) {
                                        for (const type in data.utilities) {
                                            utilities[type] = [...data.utilities[type]];
                                            
                                            // Restore objects on map
                                            utilities[type].forEach(utility => {
                                                // Convert string coordinates to LatLng objects
                                                if (utility.points) {
                                                    utility.points = utility.points.map(point => 
                                                        L.latLng(point.lat, point.lng)
                                                    );
                                                }
                                                
                                                // Add to map
                                                addUtilityToMap(utility);
                                            });
                                        }
                                    }
                                    
                                    // Load structures
                                    if (data.structures) {
                                        data.structures.forEach(structure => {
                                            // Convert string coordinates to LatLng objects
                                            if (structure.position) {
                                                structure.position = L.latLng(structure.position.lat, structure.position.lng);
                                            }
                                            
                                            // Add to structures array
                                            structures.push(structure);
                                            
                                            // Add to map
                                            addStructureToMap(structure);
                                        });
                                    }
                                    
                                    // Load annotations
                                    if (data.annotations) {
                                        data.annotations.forEach(annotation => {
                                            // Convert string coordinates to LatLng objects
                                            if (annotation.position) {
                                                annotation.position = L.latLng(annotation.position.lat, annotation.position.lng);
                                                addAnnotation(annotation.position, annotation.text, annotation.type);
                                            }
                                        });
                                    }
                                    
                                    // Load measurements
                                    if (data.measurements) {
                                        data.measurements.forEach(measurement => {
                                            // Convert string coordinates to LatLng objects
                                            if (measurement.startPoint && measurement.endPoint) {
                                                const startPoint = L.latLng(measurement.startPoint.lat, measurement.startPoint.lng);
                                                const endPoint = L.latLng(measurement.endPoint.lat, measurement.endPoint.lng);
                                                finalizeMeasurement(startPoint, endPoint);
                                            }
                                        });
                                    }
                                    
                                    showNotification('Data imported successfully', 'success');
                                }
                            } catch (error) {
                                console.error('Error parsing imported data:', error);
                                showNotification('Error importing data: ' + error.message, 'error');
                            }
                        };
                        
                        reader.onerror = function() {
                            showNotification('Error reading file', 'error');
                        };
                        
                        reader.readAsText(file);
                    };
                    
                    // Trigger file selection
                    fileInput.click();
                } catch (error) {
                    console.error('Error importing data:', error);
                    showNotification('Error importing data: ' + error.message, 'error');
                }
            }
            
            function clearAllData(showConfirm = true) {
                if (showConfirm) {
                    // Show confirmation modal
                    showModal('clear-confirm-modal');
                    return;
                }
                
                // Clear all layers
                window.utilitiesLayer.clearLayers();
                window.structuresLayer.clearLayers();
                window.annotationsLayer.clearLayers();
                window.measurementsLayer.clearLayers();
                window.tempLayer.clearLayers();
                window.controlsLayer.clearLayers();
                
                // Reset data structures
                for (const type in utilities) {
                    utilities[type] = [];
                }
                
                structures.length = 0;
                annotations.length = 0;
                measurements.length = 0;
                undoStack.length = 0;
                
                // Reset states
                cancelDrawing();
                cancelMeasurement();
                cancelPrecisionEdit();
                cancelConnecting();
                
                if (showConfirm !== false) {
                    showNotification('All data cleared', 'success');
                }
            }
            
            function confirmClearAll() {
                clearAllData();
                hideModal('clear-confirm-modal');
            }
            
            // ============ Undo System ============
            function addToUndoStack(action) {
                undoStack.push(action);
                
                // Limit stack size
                if (undoStack.length > 50) {
                    undoStack.shift(); // Remove oldest action
                }
                
                // Update undo button state
                document.getElementById('undo-button').classList.add('active');
            }
            
            function undoLastAction() {
                if (undoStack.length === 0) {
                    showNotification('Nothing to undo', 'info');
                    return;
                }
                
                const action = undoStack.pop();
                
                // Handle different action types
                switch(action.type) {
                    case 'add-utility':
                        // Remove utility from map and data
                        if (action.utility.marker) {
                            window.utilitiesLayer.removeLayer(action.utility.marker);
                        }
                        
                        if (action.utility.polyline) {
                            window.utilitiesLayer.removeLayer(action.utility.polyline);
                        }
                        
                        // Remove from utilities array
                        const utilityType = action.utility.type;
                        const utilityIndex = utilities[utilityType].findIndex(u => u.id === action.utility.id);
                        if (utilityIndex !== -1) {
                            utilities[utilityType].splice(utilityIndex, 1);
                        }
                        
                        showNotification('Undid add utility', 'info');
                        break;
                        
                    case 'add-structure':
                        // Remove structure from map and data
                        if (action.structure.marker) {
                            window.structuresLayer.removeLayer(action.structure.marker);
                        }
                        
                        // Remove from structures array
                        const structureIndex = structures.findIndex(s => s.id === action.structure.id);
                        if (structureIndex !== -1) {
                            structures.splice(structureIndex, 1);
                        }
                        
                        showNotification('Undid add structure', 'info');
                        break;
                        
                    case 'add-annotation':
                        // Remove annotation from map and data
                        if (action.annotation.marker) {
                            window.annotationsLayer.removeLayer(action.annotation.marker);
                        }
                        
                        // Remove from annotations array
                        const annotationIndex = annotations.findIndex(a => a.id === action.annotation.id);
                        if (annotationIndex !== -1) {
                            annotations.splice(annotationIndex, 1);
                        }
                        
                        showNotification('Undid add annotation', 'info');
                        break;
                        
                    case 'add-measurement':
                        // Remove measurement from map
                        if (action.line) {
                            window.measurementsLayer.removeLayer(action.line);
                        }
                        
                        if (action.tooltip) {
                            window.measurementsLayer.removeLayer(action.tooltip);
                        }
                        
                        // Remove from measurements array
                        const measurementIndex = measurements.findIndex(m => m.line === action.line);
                        if (measurementIndex !== -1) {
                            measurements.splice(measurementIndex, 1);
                        }
                        
                        showNotification('Undid add measurement', 'info');
                        break;
                        
                    case 'delete-utility':
                        // Restore utility
                        utilities[action.utilityType].push(action.utility);
                        
                        // Restore on map
                        addUtilityToMap(action.utility);
                        
                        showNotification('Undid delete utility', 'info');
                        break;
                        
                    case 'delete-structure':
                        // Restore structure
                        structures.push(action.structure);
                        
                        // Restore on map
                        addStructureToMap(action.structure);
                        
                        showNotification('Undid delete structure', 'info');
                        break;
                        
                    case 'delete-annotation':
                        // Restore annotation
                        annotations.push(action.annotation);
                        
                        // Restore on map
                        if (action.annotation.position) {
                            addAnnotation(
                                action.annotation.position, 
                                action.annotation.text, 
                                action.annotation.type
                            );
                        }
                        
                        showNotification('Undid delete annotation', 'info');
                        break;
                        
                    case 'edit-utility-points':
                        // Find the utility
                        const editedUtility = findUtilityById(action.utilityId);
                        if (editedUtility && editedUtility.polyline) {
                            // Restore original points
                            editedUtility.points = [...action.originalPoints];
                            
                            // Update polyline
                            editedUtility.polyline.setLatLngs(action.originalPoints);
                            
                            showNotification('Undid precision edit', 'info');
                        }
                        break;
                        
                    case 'add-connection':
                        // Find connected elements
                        let source, target;
                        
                        if (action.connection.sourceType === 'utility') {
                            source = findUtilityById(action.connection.sourceId);
                        } else if (action.connection.sourceType === 'structure') {
                            source = findStructureById(action.connection.sourceId);
                        }
                        
                        if (action.connection.targetType === 'utility') {
                            target = findUtilityById(action.connection.targetId);
                        } else if (action.connection.targetType === 'structure') {
                            target = findStructureById(action.connection.targetId);
                        }
                        
                        // Remove connection lines
                        if (source && source.connectionLines) {
                            source.connectionLines.forEach(line => {
                                if (window.utilitiesLayer.hasLayer(line)) {
                                    window.utilitiesLayer.removeLayer(line);
                                }
                            });
                        }
                        
                        if (target && target.connectionLines) {
                            target.connectionLines.forEach(line => {
                                if (window.utilitiesLayer.hasLayer(line)) {
                                    window.utilitiesLayer.removeLayer(line);
                                }
                            });
                        }
                        
                        // Remove connection from data
                        if (source && source.connections) {
                            source.connections = source.connections.filter(c => c.id !== action.connection.id);
                        }
                        
                        if (target && target.connections) {
                            target.connections = target.connections.filter(c => c.id !== action.connection.id);
                        }
                        
                        showNotification('Undid connection', 'info');
                        break;
                }
                
                // Update undo button state
                if (undoStack.length === 0) {
                    document.getElementById('undo-button').classList.remove('active');
                }
            }
            
            // ============ User Location Functions ============
            function getUserLocation() {
                if (navigator.geolocation) {
                    // Show loading
                    showNotification('Getting your location...', 'info');
                    
                    navigator.geolocation.getCurrentPosition(function(position) {
                        // Get coordinates
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        
                        // Center map
                        map.setView([lat, lng], 19);
                        
                        // Add/update user marker
                        if (userMarker) {
                            userMarker.setLatLng([lat, lng]);
                        } else {
                            userMarker = L.circleMarker([lat, lng], {
                                radius: 8,
                                color: '#2196f3',
                                fillColor: '#2196f3',
                                fillOpacity: 0.5,
                                weight: 2
                            }).addTo(map);
                        }
                        
                        // Store current position
                        currentPosition = [lat, lng];
                        
                        showNotification('Location found', 'success');
                        
                        // Start watching position for updates
                        startWatchingPosition();
                    }, function(error) {
                        let message = 'Unable to get your location';
                        
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                message = 'Location permission denied';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                message = 'Location information unavailable';
                                break;
                            case error.TIMEOUT:
                                message = 'Location request timed out';
                                break;
                        }
                        
                        showNotification(message, 'error');
                    });
                } else {
                    showNotification('Geolocation is not supported by your browser', 'error');
                }
            }
            
            function startWatchingPosition() {
                if (navigator.geolocation) {
                    // Start watching position
                    const watchId = navigator.geolocation.watchPosition(function(position) {
                        // Get coordinates
                        const lat = position.coords.latitude;
                        const lng = position.coords.longitude;
                        
                        // Update user marker
                        if (userMarker) {
                            userMarker.setLatLng([lat, lng]);
                        }
                        
                        // Store current position
                        currentPosition = [lat, lng];
                    }, function(error) {
                        console.error('Error watching position:', error);
                    }, {
                        enableHighAccuracy: true,
                        maximumAge: 30000,
                        timeout: 27000
                    });
                    
                    // Store watch ID for cleanup
                    window.positionWatchId = watchId;
                }
            }
            
            function stopWatchingPosition() {
                if (window.positionWatchId) {
                    navigator.geolocation.clearWatch(window.positionWatchId);
                    window.positionWatchId = null;
                }
            }
            
            // ============ UI Helper Functions ============
            function showModal(modalId) {
                const modal = document.getElementById(modalId);
                modal.classList.add('visible');
                
                // Animate the modal
                const modalContainer = modal.querySelector('.modal');
                modalContainer.classList.add('animate__animated', 'animate__fadeInUp');
                
                // Remove animation class after it completes
                setTimeout(() => {
                    modalContainer.classList.remove('animate__animated', 'animate__fadeInUp');
                }, 500);
            }
            
            function hideModal(modalId) {
                const modal = document.getElementById(modalId);
                
                // Animate the modal out
                const modalContainer = modal.querySelector('.modal');
                modalContainer.classList.add('animate__animated', 'animate__fadeOutDown');
                
                // Wait for animation to complete before hiding
                setTimeout(() => {
                    modal.classList.remove('visible');
                    modalContainer.classList.remove('animate__animated', 'animate__fadeOutDown');
                }, 300);
            }
            
            function showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                const notificationText = document.getElementById('notification-text');
                
                // Set the message and icon
                notificationText.textContent = message;
                
                // Set icon based on type
                const iconElement = notification.querySelector('i');
                iconElement.className = ''; // Reset class
                
                switch(type) {
                    case 'success':
                        iconElement.className = 'fas fa-check-circle';
                        notification.className = 'notification success';
                        break;
                    case 'warning':
                        iconElement.className = 'fas fa-exclamation-triangle';
                        notification.className = 'notification warning';
                        break;
                    case 'error':
                        iconElement.className = 'fas fa-times-circle';
                        notification.className = 'notification error';
                        break;
                    case 'info':
                    default:
                        iconElement.className = 'fas fa-info-circle';
                        notification.className = 'notification info';
                        break;
                }
                
                // Show the notification
                notification.classList.add('visible');
                
                // Animate the notification
                notification.classList.add('animate__animated', 'animate__fadeInDown');
                
                // Clear any existing timeout
                if (window.notificationTimeout) {
                    clearTimeout(window.notificationTimeout);
                }
                
                // Hide after delay
                window.notificationTimeout = setTimeout(() => {
                    // Animate out
                    notification.classList.remove('animate__fadeInDown');
                    notification.classList.add('animate__fadeOutUp');
                    
                    setTimeout(() => {
                        notification.classList.remove('visible', 'animate__animated', 'animate__fadeOutUp');
                    }, 300);
                }, 3000);
            }
            
            function updateStatus(message) {
                const statusBar = document.getElementById('status-bar');
                const statusText = document.getElementById('status-text');
                
                // Update text
                statusText.textContent = message;
                
                // Show status bar
                statusBar.classList.add('visible');
                
                // Clear any existing timeout
                if (window.statusTimeout) {
                    clearTimeout(window.statusTimeout);
                }
                
                // Auto-hide after delay (longer than notifications)
                window.statusTimeout = setTimeout(() => {
                    statusBar.classList.remove('visible');
                }, 5000);
            }
            
            function showHelp() {
                // Show help modal or notification
                showNotification('Help documentation coming soon!', 'info');
            }
            
            function animateElement(element, animation) {
                if (!element) return;
                
                // Add animate.css classes
                element.classList.add('animate__animated', 'animate__' + animation);
                
                // Remove classes after animation completes
                setTimeout(() => {
                    element.classList.remove('animate__animated', 'animate__' + animation);
                }, 1000);
            }
            
            // ============ Utility Helper Functions ============
            function getUtilityColor(type) {
                const colors = {
                    water: '#03a9f4',
                    gas: '#ff9800',
                    electric: '#ffeb3b',
                    sewer: '#795548',
                    telecom: '#9c27b0'
                };
                
                return colors[type] || '#757575';
            }
            
            function getUtilityIcon(type) {
                const icons = {
                    water: 'fas fa-tint',
                    gas: 'fas fa-fire',
                    electric: 'fas fa-bolt',
                    sewer: 'fas fa-toilet',
                    telecom: 'fas fa-phone'
                };
                
                return icons[type] || 'fas fa-question';
            }
            
            function getStructureIcon(type) {
                const icons = {
                    'manhole': 'fas fa-circle',
                    'catch-basin': 'fas fa-drain',
                    'electrical-box': 'fas fa-box',
                    'valve': 'fas fa-life-ring',
                    'meter': 'fas fa-tachometer-alt'
                };
                
                return icons[type] || 'fas fa-question';
            }
            
            function formatStructureType(type) {
                const types = {
                    'manhole': 'Manhole',
                    'catch-basin': 'Catch Basin',
                    'electrical-box': 'Electrical Box',
                    'valve': 'Valve',
                    'meter': 'Meter'
                };
                
                return types[type] || 'Structure';
            }
            
            function formatDistance(meters) {
                if (meters < 1) {
                    return (meters * 100).toFixed(0) + ' cm';
                } else if (meters < 1000) {
                    return meters.toFixed(2) + ' m';
                } else {
                    return (meters / 1000).toFixed(2) + ' km';
                }
            }
            
            function calculateDirection(start, end) {
                const dx = end.lng - start.lng;
                const dy = end.lat - start.lat;
                
                // Calculate angle in degrees (0° = North, clockwise)
                let angle = Math.atan2(dx, dy) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                // Convert angle to cardinal direction
                const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
                const index = Math.round(angle / 45) % 8;
                
                return directions[index];
            }
            
            function getClosestEndpoint(points, reference) {
                if (!points || points.length < 2) return null;
                
                const start = points[0];
                const end = points[points.length - 1];
                
                const startDist = map.distance(reference, start);
                const endDist = map.distance(reference, end);
                
                return startDist < endDist ? start : end;
            }
            
            function getClosestPointOnSegment(point, p1, p2) {
                const x = point.lng;
                const y = point.lat;
                const x1 = p1.lng;
                const y1 = p1.lat;
                const x2 = p2.lng;
                const y2 = p2.lat;
                
                // Calculate projection parameters
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                
                // Avoid division by zero
                if (len_sq === 0) return p1;
                
                // Calculate projection parameter (0-1)
                let param = dot / len_sq;
                
                // Clamp to segment
                if (param < 0) param = 0;
                if (param > 1) param = 1;
                
                // Calculate point on segment
                return L.latLng(
                    y1 + param * D,
                    x1 + param * C
                );
            }
            
            function capitalize(string) {
                if (!string) return '';
                return string.charAt(0).toUpperCase() + string.slice(1);
            }
            
            // ============ Application Initialization ============
            // Initialize all components
            initMap();
            initUIControls();
            
            // Try to load saved data
            const dataLoaded = loadSavedData();
            
            if (!dataLoaded) {
                // Show welcome message for new users
                showNotification('Welcome to CAC UtilityPro! Tap a tool to get started.', 'info');
                
                // Default to discovery mode
                setActiveMode('discovery');
                
                // Use current location if available
                getUserLocation();
            }
            
            // Handle beforeunload event to save data
            window.addEventListener('beforeunload', function() {
                saveData(); // Autosave on exit
            });
            
            // Setup auto-save interval
            setInterval(saveData, 60000); // Save every minute
            
            // Set status ready
            updateStatus('Ready to map utilities');
        }
    </script>
</body>
</html>
